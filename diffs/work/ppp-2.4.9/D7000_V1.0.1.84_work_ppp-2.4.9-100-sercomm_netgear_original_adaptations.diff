--- work/ppp-2.4.9/pppd/auth.c	2021-01-05 00:06:37.000000000 +0100
+++ work/ppp-2.4.9/pppd/auth.c	2022-03-09 12:20:13.025674000 +0100
@@ -122,7 +122,8 @@
 #endif
 #include "pathnames.h"
 #include "session.h"
-
+#include <syslog.h>
+#include "misc.h"
 
 /* Bits in scan_authfile return value */
 #define NONWILD_SERVER	1
@@ -1055,6 +1056,10 @@ auth_withpeer_fail(int unit, int protoco
      */
     status = EXIT_AUTH_TOPEER_FAILED;
     lcp_close(unit, "Failed to authenticate ourselves to peer");
+#ifdef INET6
+	/*Sercomm*/
+    auth_script(_PATH_IPV6DOWN);
+#endif
 }
 
 /*
@@ -1128,7 +1133,16 @@ np_up(int unit, int proto)
 	status = EXIT_OK;
 	unsuccess = 0;
 	new_phase(PHASE_RUNNING);
-
+#ifdef MULTI_OFFER
+	if (p_marksuccessserver) // Initialized in pppoe.c file
+        {
+          notice("call p_marksuccessserver");
+          (*p_marksuccessserver)();
+        }else
+        {
+          notice("p_marksuccessserver is null.");
+        }
+#endif /* MULTI_OFFER */
 	if (idle_time_hook != 0)
 	    tlim = (*idle_time_hook)(NULL);
 	else
@@ -1243,11 +1257,13 @@ check_idle(void *arg)
     if (idle_time_hook != 0) {
 	tlim = idle_time_hook(&idle);
     } else {
-	itime = MIN(idle.xmit_idle, idle.recv_idle);
-	tlim = idle_time_limit - itime;
+    /* idle means transmint idle. -- Argon Cheng 2006-04-10 */
+    itime = idle.xmit_idle;
+    tlim = idle_time_limit - itime;
     }
     if (tlim <= 0) {
 	/* link is idle: shut it down. */
+    NETGEAR_SYSLOG("05 00[Internet idle-timeout]");
 	notice("Terminating connection due to lack of activity.");
 	status = EXIT_IDLE_TIMEOUT;
 	lcp_close(0, "Link inactive");
@@ -1379,17 +1395,15 @@ auth_check_options(void)
 void
 auth_reset(int unit)
 {
+    int hadchap = -1;
+
     lcp_options *go = &lcp_gotoptions[unit];
     lcp_options *ao = &lcp_allowoptions[unit];
-    int hadchap;
-
-    hadchap = -1;
-    ao->neg_upap = !refuse_pap && (passwd[0] != 0 || get_pap_passwd(NULL));
-    ao->neg_chap = (!refuse_chap || !refuse_mschap || !refuse_mschap_v2)
-	&& ((passwd[0] != 0 || explicit_passwd) ||
-	    (hadchap = have_chap_secret(user, (explicit_remote? remote_name:
-					       NULL), 0, NULL)));
+    /* Ron add for test BT chap no password issue */
+    ao->neg_upap = !refuse_pap;
+    ao->neg_chap = !refuse_chap;
     ao->neg_eap = !refuse_eap && (
+
 	passwd[0] != 0 ||
 	(hadchap == 1 || (hadchap == -1 && have_chap_secret(user,
 	    (explicit_remote? remote_name: NULL), 0, NULL))) ||
--- work/ppp-2.4.9/pppd/chap-new.c	2021-01-05 00:06:37.000000000 +0100
+++ work/ppp-2.4.9/pppd/chap-new.c	2022-03-09 12:20:13.025674000 +0100
@@ -32,6 +32,7 @@
 
 #include <stdlib.h>
 #include <string.h>
+#include <syslog.h>
 #include "pppd.h"
 #include "session.h"
 #include "chap-new.h"
@@ -559,11 +560,24 @@ chap_handle_status(struct chap_client_st
 		else
 			info("%s", msg);
 	}
-	if (code == CHAP_SUCCESS)
+	if (code == CHAP_SUCCESS) {
+	  	openlog( "syslog", 0 , LOG_SYSLOG );
+		syslog( LOG_INFO, "CHAP authentication success" );
+		closelog();
 		auth_withpeer_success(0, PPP_CHAP, cs->digest->code);
+	}
 	else {
 		cs->flags |= AUTH_FAILED;
 		error("CHAP authentication failed");
+	   	openlog( "syslog", 0 , LOG_SYSLOG );
+		syslog( LOG_INFO, "CHAP authentication failed" );
+		closelog();
+		FILE *fp=NULL;
+		fp=fopen( "/tmp/pppd.fail","w");
+		if(fp){
+			fprintf(fp,"CHAP authentication failed");
+			fclose(fp);
+		}
 		auth_withpeer_fail(0, PPP_CHAP);
 	}
 }
--- work/ppp-2.4.9/pppd/demand.c	2021-01-05 00:06:37.000000000 +0100
+++ work/ppp-2.4.9/pppd/demand.c	2022-03-09 12:35:44.815390000 +0100
@@ -304,7 +304,13 @@ demand_rexmit(int proto)
     for (; pkt != NULL; pkt = nextpkt) {
 	nextpkt = pkt->next;
 	if (PPP_PROTOCOL(pkt->data) == proto) {
-	    output(0, pkt->data, pkt->length);
+        /*
+         * Should not send these packets out because they are not NATed.
+         *                                          Argon Cheng
+         */
+#if 0
+ 	    output(0, pkt->data, pkt->length);
+#endif
 	    free(pkt);
 	} else {
 	    if (prev == NULL)
--- work/ppp-2.4.9/pppd/fsm.c	2021-01-05 00:06:37.000000000 +0100
+++ work/ppp-2.4.9/pppd/fsm.c	2022-03-09 13:46:59.210748000 +0100
@@ -47,6 +47,7 @@
  */
 
 #include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 #include <sys/types.h>
 
@@ -84,6 +85,8 @@ fsm_init(fsm *f)
     f->maxtermtransmits = DEFMAXTERMREQS;
     f->maxnakloops = DEFMAXNAKLOOPS;
     f->term_reason_len = 0;
+// Allen
+    f->last_code= UNKNOWN_CODE;
 }
 
 
@@ -356,6 +359,7 @@ fsm_input(fsm *f, u_char *inpacket, int
     /*
      * Action depends on code.
      */
+    f->last_code = code;	
     switch (code) {
     case CONFREQ:
 	fsm_rconfreq(f, id, inp, len);
@@ -372,6 +376,7 @@ fsm_input(fsm *f, u_char *inpacket, int
     
     case TERMREQ:
 	fsm_rtermreq(f, id, inp, len);
+	system("/usr/sbin/nvram set ppp_terminate=1"); // Ethan	// Peter
 	break;
     
     case TERMACK:
@@ -388,6 +393,7 @@ fsm_input(fsm *f, u_char *inpacket, int
 	    fsm_sdata(f, CODEREJ, ++f->id, inpacket, len + HEADERLEN);
 	break;
     }
+    f->last_code = UNKNOWN_CODE;		
 }
 
 
--- work/ppp-2.4.9/pppd/fsm.h	2021-01-05 00:06:37.000000000 +0100
+++ work/ppp-2.4.9/pppd/fsm.h	2022-03-09 13:48:03.642286000 +0100
@@ -58,6 +58,8 @@
 #define TERMREQ		5	/* Termination Request */
 #define TERMACK		6	/* Termination Ack */
 #define CODEREJ		7	/* Code Reject */
+//Allen
+#define UNKNOWN_CODE  (-1)
 
 
 /*
@@ -81,6 +83,8 @@ typedef struct fsm {
     struct fsm_callbacks *callbacks;	/* Callback routines */
     char *term_reason;		/* Reason for closing protocol */
     int term_reason_len;	/* Length of term_reason */
+// Allen	
+    int last_code; 		// 	the last code (recvieived packet)
 } fsm;
 
 
@@ -122,6 +126,8 @@ typedef struct fsm_callbacks {
 #define ACKRCVD		7	/* We've received a Config Ack */
 #define ACKSENT		8	/* We've sent a Config Ack */
 #define OPENED		9	/* Connection available */
+// Allen
+#define UNKNOWN_STATE  (-1)
 
 
 /*
--- work/ppp-2.4.9/pppd/ipcp.c	2021-01-05 00:06:37.000000000 +0100
+++ work/ppp-2.4.9/pppd/ipcp.c	2022-03-10 22:30:10.898850019 +0100
@@ -54,6 +54,7 @@
 #include <netinet/in.h>
 #include <arpa/inet.h>
 #include <net/if.h>
+#include <signal.h>
 
 #include "pppd.h"
 #include "fsm.h"
@@ -94,6 +95,10 @@ static int ipcp_is_open;		/* haven't cal
 static bool ask_for_local;		/* request our address from peer */
 static char vj_value[8];		/* string form of vj option value */
 static char netmask_str[20];		/* string form of netmask value */
+static int ip_down_st = UNKNOWN_STATE;
+static int ip_down_code = UNKNOWN_CODE;
+static int ip_up_st = UNKNOWN_STATE;
+static int ip_up_code = UNKNOWN_CODE;
 
 /*
  * Callbacks for fsm code.  (CI = Configuration Information)
@@ -169,6 +174,17 @@ static option_t ipcp_option_list[] = {
 
     { "ipparam", o_string, &ipparam,
       "Set ip script parameter", OPT_PRIO },
+    { "ipparam2", o_string, &ipparam2,
+      "Set ip script parameter", OPT_PRIO },
+    { "info_file", o_string, &ipparam2,
+      "Set ip script parameter", OPT_PRIO },
+
+    { "lcp_file", o_string, &lcp_file,
+      "Set lcp_file name", OPT_PRIO },
+    { "pppd_fail", o_string, &pppd_fail,
+      "Set pppd_fail name", OPT_PRIO },
+    { "demand_file", o_string, &demand_file,
+      "Set demand_file name", OPT_PRIO },
 
     { "noipdefault", o_bool, &disable_defaultip,
       "Don't use name for default IP adrs", 1 },
@@ -279,7 +295,7 @@ struct protent ipcp_protent = {
 };
 
 static void ipcp_clear_addrs (int, u_int32_t, u_int32_t, bool);
-static void ipcp_script (char *, int);	/* Run an up/down script */
+static void ipcp_script (char *, int, int);	/* Run an up/down script */
 static void ipcp_script_done (void *);
 
 /*
@@ -684,8 +700,13 @@ ipcp_resetci(fsm *f)
 	wo->accept_local = 1;
     if (wo->hisaddr == 0)
 	wo->accept_remote = 1;
-    wo->req_dns1 = usepeerdns;	/* Request DNS addresses from the peer */
-    wo->req_dns2 = usepeerdns;
+    /* 
+     * 2011-1-26, cindy. according to netgear spec 1.9, they want to always get dns ip address. 
+     * but in case with dynamic dhcp and fix dns, they want to use fix dns. So usepeerdns will 
+     * just indicate to use dns from pptp.
+     */
+    wo->req_dns1 =1;
+    wo->req_dns2 =1;                 
     *go = *wo;
     if (!ask_for_local)
 	go->ouraddr = 0;
@@ -1672,8 +1693,6 @@ endswitch:
 static void
 ip_check_options(void)
 {
-    struct hostent *hp;
-    u_int32_t local;
     ipcp_options *wo = &ipcp_wantoptions[0];
 
     /*
@@ -1687,11 +1706,6 @@ ip_check_options(void)
 	 * If there isn't an IP address for our hostname, too bad.
 	 */
 	wo->accept_local = 1;	/* don't insist on this default value */
-	if ((hp = gethostbyname(hostname)) != NULL) {
-	    local = *(u_int32_t *)hp->h_addr;
-	    if (local != 0 && !bad_ip_adrs(local))
-		wo->ouraddr = local;
-	}
     }
     ask_for_local = wo->ouraddr != 0 || !disable_defaultip;
 }
@@ -1719,7 +1733,7 @@ ip_demand_conf(int u)
     }
     if (!sifaddr(u, wo->ouraddr, wo->hisaddr, GetMask(wo->ouraddr)))
 	return 0;
-    ipcp_script(_PATH_IPPREUP, 1);
+    ipcp_script(_PATH_IPPREUP, 1, ip_up_code);
     if (!sifup(u))
 	return 0;
     if (!sifnpmode(u, PPP_IP, NPMODE_QUEUE))
@@ -1736,6 +1750,25 @@ ip_demand_conf(int u)
     if (wo->hisaddr)
 	notice("remote IP address %I", wo->hisaddr);
 
+	{
+		struct in_addr in1;
+		struct in_addr in2;
+		FILE * fp= NULL;
+
+		in1.s_addr = wo->ouraddr;
+		in2.s_addr = wo->hisaddr;
+
+		if( demand_file)
+			fp= fopen( demand_file, "w");
+
+		if( fp)
+		{
+			fprintf( fp, "local %s\n", inet_ntoa( in1));
+			fprintf( fp, "remote %s\n", inet_ntoa( in2));
+			fclose(fp);
+		}
+	}
+
     return 1;
 }
 
@@ -1871,7 +1904,7 @@ ipcp_up(fsm *f)
 	ifindex = if_nametoindex(ifname);
 
 	/* run the pre-up script, if any, and wait for it to finish */
-	ipcp_script(_PATH_IPPREUP, 1);
+	ipcp_script(_PATH_IPPREUP, 1, f->last_code);
 
 	/* check if preup script renamed the interface */
 	if (!if_indextoname(ifindex, ifname)) {
@@ -1929,13 +1962,16 @@ ipcp_up(fsm *f)
     if (ip_up_hook)
 	ip_up_hook();
 
+    ip_up_code = f->last_code;
+    ip_up_st = f->state;	
+
     /*
      * Execute the ip-up script, like this:
      *	/etc/ppp/ip-up interface tty speed local-IP remote-IP
      */
     if (ipcp_script_state == s_down && ipcp_script_pid == 0) {
 	ipcp_script_state = s_up;
-	ipcp_script(path_ipup, 0);
+	ipcp_script(path_ipup, 0, f->last_code);
     }
 }
 
@@ -1981,10 +2017,13 @@ ipcp_down(fsm *f)
 			 ipcp_hisoptions[f->unit].hisaddr, 0);
     }
 
+    ip_down_code = f->last_code;
+    ip_down_st = f->state;
+   
     /* Execute the ip-down script */
     if (ipcp_script_state == s_up && ipcp_script_pid == 0) {
 	ipcp_script_state = s_down;
-	ipcp_script(path_ipdown, 0);
+	ipcp_script(path_ipdown, 0, f->last_code);
     }
 }
 
@@ -2041,13 +2080,13 @@ ipcp_script_done(void *arg)
     case s_up:
 	if (ipcp_fsm[0].state != OPENED) {
 	    ipcp_script_state = s_down;
-	    ipcp_script(path_ipdown, 0);
+	    ipcp_script(path_ipdown, 0, ip_down_code);
 	}
 	break;
     case s_down:
 	if (ipcp_fsm[0].state == OPENED) {
 	    ipcp_script_state = s_up;
-	    ipcp_script(path_ipup, 0);
+	    ipcp_script(path_ipup, 0, ip_up_code);
 	}
 	break;
     }
@@ -2059,14 +2098,33 @@ ipcp_script_done(void *arg)
  * interface-name tty-name speed local-IP remote-IP.
  */
 static void
-ipcp_script(char *script, int wait)
+ipcp_script(char *script, int wait, int code)
 {
     char strspeed[32], strlocal[32], strremote[32];
-    char *argv[8];
+    char demand_opt[3],ide_opt[10], str_code[10], str_wait[10];
+    char *argv[32];
+    char rtable[8];
+    char proxy[4] = "0", force[4];
+    int wan_table = 1;
+
+    IPCPDEBUG(("ipcp_script: %s st=%d code=%d",script, wait, code));
+    if (ipparam) {
+        wan_table = atoi(ipparam);
+    }
+    if (wan_table == 0) {
+	    wan_table = 1;
+    }
+    wan_table += 100;
+    slprintf(rtable, sizeof(rtable), "%d", wan_table);
 
     slprintf(strspeed, sizeof(strspeed), "%d", baud_rate);
     slprintf(strlocal, sizeof(strlocal), "%I", ipcp_gotoptions[0].ouraddr);
     slprintf(strremote, sizeof(strremote), "%I", ipcp_hisoptions[0].hisaddr);
+    slprintf(demand_opt, sizeof(demand_opt), "%d", demand);
+    slprintf(ide_opt, sizeof(ide_opt), "%d", idle_time_limit);
+    slprintf(str_code, sizeof(str_code), "%d", code);
+    slprintf(str_wait, sizeof(str_wait), "%d", wait);
+    slprintf(force, sizeof(force), "%d", (signal_no == SIGTERM)?1:0);
 
     argv[0] = script;
     argv[1] = ifname;
@@ -2075,7 +2133,15 @@ ipcp_script(char *script, int wait)
     argv[4] = strlocal;
     argv[5] = strremote;
     argv[6] = ipparam;
-    argv[7] = NULL;
+    argv[7] = demand_opt;
+    argv[8] = ide_opt;
+    argv[9] = ipparam2;	
+    argv[10] = str_wait;
+    argv[11] = str_code;
+    argv[12] = rtable;
+    argv[13] = proxy;
+    argv[14] = force;	/* set by SIGTERM */
+    argv[15] = NULL;
     if (wait)
 	run_program(script, argv, 0, NULL, NULL, 1);
     else
--- work/ppp-2.4.9/pppd/ipv6cp.c	2021-01-05 00:06:37.000000000 +0100
+++ work/ppp-2.4.9/pppd/ipv6cp.c	2022-03-09 14:20:18.988297000 +0100
@@ -220,6 +220,8 @@ static fsm_callbacks ipv6cp_callbacks =
     "IPV6CP"			/* String name of protocol */
 };
 
+char * llv6_ntoa(eui64_t ifaceid);
+
 /*
  * Command-line options.
  */
@@ -1524,6 +1526,9 @@ ipv6cp_printpkt(u_char *p, int plen,
  */
 #define IP6_HDRLEN	40	/* bytes */
 #define IP6_NHDR_FRAG	44	/* fragment IPv6 header */
+#ifndef IPPROTO_TCP
+#define IPPROTO_TCP	6
+#endif
 #define TCP_HDRLEN	20
 #define TH_FIN		0x01
 
--- work/ppp-2.4.9/pppd/ipxcp.c	2021-01-05 00:06:37.000000000 +0100
+++ work/ppp-2.4.9/pppd/ipxcp.c	2022-03-09 14:28:57.976510000 +0100
@@ -290,10 +290,10 @@ setipxnode(char **argv)
     memset (our_node, 0, 6);
     memset (his_node, 0, 6);
 
-    end = setipxnodevalue ((u_char *)*argv, our_node);
+    end = (u_char *)setipxnodevalue ((u_char *)*argv, our_node);
     if (*end == ':') {
 	have_his = 1;
-	end = setipxnodevalue (++end, his_node);
+	end = (u_char *)setipxnodevalue (++end, his_node);
     }
 
     if (*end == '\0') {
@@ -332,7 +332,7 @@ printipxnode(option_t *opt, void (*print
 static int
 setipxname (char **argv)
 {
-    u_char *dest = ipxcp_wantoptions[0].name;
+    u_char *dest = (u_char *)ipxcp_wantoptions[0].name;
     char *src  = *argv;
     int  count;
     char ch;
@@ -1358,7 +1358,7 @@ ipxcp_script(fsm *f, char *script)
 {
     char strspeed[32],	 strlocal[32],	   strremote[32];
     char strnetwork[32], strpid[32];
-    char *argv[14],	 strproto_lcl[32], strproto_rmt[32];
+    char *argv[15],	 strproto_lcl[32], strproto_rmt[32];
 
     slprintf(strpid, sizeof(strpid), "%d", getpid());
     slprintf(strspeed, sizeof(strspeed),"%d", baud_rate);
@@ -1408,7 +1408,8 @@ ipxcp_script(fsm *f, char *script)
     argv[10] = (char *)ho->name;
     argv[11] = ipparam;
     argv[12] = strpid;
-    argv[13] = NULL;
+    argv[13] = ipparam2;
+    argv[14] = NULL;
     run_program(script, argv, 0, NULL, NULL, 0);
 }
 
--- work/ppp-2.4.9/pppd/lcp.c	2021-01-05 00:06:37.000000000 +0100
+++ work/ppp-2.4.9/pppd/lcp.c	2022-03-10 12:09:19.016794000 +0100
@@ -43,6 +43,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
+#include <syslog.h>
 
 #include "pppd.h"
 #include "fsm.h"
@@ -194,6 +195,8 @@ static int lcp_echo_timer_running = 0;
 
 static u_char nak_buffer[PPP_MRU];	/* where we construct a nak packet */
 
+extern int cable_just_up;
+
 /*
  * Callbacks for fsm code.  (CI = Configuration Information)
  */
@@ -317,6 +320,23 @@ printendpoint(option_t *opt, void (*prin
 	printer(arg, "%s", epdisc_to_str(&lcp_wantoptions[0].endpoint));
 }
 #endif /* HAVE_MULTILINK */
+/* Ron */
+void my_lcp_status(char *msg)
+{
+	FILE *fp;
+    	openlog( "syslog", 0 , LOG_SYSLOG );
+	syslog( LOG_INFO, msg );
+	closelog();
+	if( lcp_file != NULL)
+	{
+		fp=fopen( lcp_file,"w");
+		if(fp){
+			fprintf(fp,"%s",msg);
+			fclose(fp);
+		}
+	}
+}
+/* Ron */
 
 /*
  * lcp_init - Initialize LCP.
@@ -354,6 +374,7 @@ lcp_init(int unit)
     ao->neg_pcompression = 1;
     ao->neg_accompression = 1;
     ao->neg_endpoint = 1;
+    my_lcp_status("Initialize LCP.");
 }
 
 
@@ -372,6 +393,7 @@ lcp_open(int unit)
     if (wo->silent)
 	f->flags |= OPT_SILENT;
     fsm_open(f);
+	my_lcp_status("LCP is allowed to come up.");
 }
 
 
@@ -394,6 +416,7 @@ lcp_close(int unit, char *reason)
     oldstate = f->state;
 
     fsm_close(f, reason);
+    my_lcp_status("LCP down.");
     if (oldstate == STOPPED && f->flags & (OPT_PASSIVE|OPT_SILENT|DELAYED_UP)) {
 	/*
 	 * This action is not strictly according to the FSM in RFC1548,
@@ -535,6 +558,7 @@ lcp_rprotrej(fsm *f, u_char *inp, int le
 
     if (len < 2) {
 	LCPDEBUG(("lcp_rprotrej: Rcvd short Protocol-Reject packet!"));
+	my_lcp_status(("lcp_rprotrej: Rcvd short Protocol-Reject packet!"));
 	return;
     }
 
@@ -544,10 +568,8 @@ lcp_rprotrej(fsm *f, u_char *inp, int le
      * Protocol-Reject packets received in any state other than the LCP
      * OPENED state SHOULD be silently discarded.
      */
-    if( f->state != OPENED ){
-	LCPDEBUG(("Protocol-Reject discarded: LCP in state %d", f->state));
+    if( f->state != OPENED )
 	return;
-    }
 
     pname = protocol_name(prot);
 
@@ -1487,6 +1509,8 @@ lcp_reqci(fsm *f, u_char *inp, int *lenp
 	    p[1] < 2 ||			/*  CI length too small or */
 	    p[1] > l) {			/*  CI length too big? */
 	    LCPDEBUG(("lcp_reqci: bad CI length!"));
+	    /* Ron Add for lcp debug */
+	    dbglog("lcp_reqci: bad CI length! l==%d p[1]==%d",l,p[1]);
 	    orc = CONFREJ;		/* Reject bad CI */
 	    cilen = l;			/* Reject till end of packet */
 	    l = 0;			/* Don't loop again */
@@ -1502,6 +1526,8 @@ lcp_reqci(fsm *f, u_char *inp, int *lenp
 	case CI_MRU:
 	    if (!ao->neg_mru ||		/* Allow option? */
 		cilen != CILEN_SHORT) {	/* Check CI length */
+	    /* Ron Add for lcp debug */
+	    dbglog("CI_MRU:ao->neg_mru==%d cilen==%d",ao->neg_mru,cilen);
 		orc = CONFREJ;		/* Reject CI */
 		break;
 	    }
@@ -1513,6 +1539,8 @@ lcp_reqci(fsm *f, u_char *inp, int *lenp
 	     * we'll just ignore it.
 	     */
 	    if (cishort < MINMRU) {
+	    /* Ron Add for lcp debug */
+	    dbglog("CI_MRU:cishort==%d",cishort);
 		orc = CONFNAK;		/* Nak CI */
 		PUTCHAR(CI_MRU, nakp);
 		PUTCHAR(CILEN_SHORT, nakp);
@@ -1526,6 +1554,8 @@ lcp_reqci(fsm *f, u_char *inp, int *lenp
 	case CI_ASYNCMAP:
 	    if (!ao->neg_asyncmap ||
 		cilen != CILEN_LONG) {
+	    /* Ron Add for lcp debug */
+	    dbglog("CI_ASYNCMAP:ao->neg_asyncmap==%d cilen=%d",ao->neg_asyncmap,cilen);
 		orc = CONFREJ;
 		break;
 	    }
@@ -1536,6 +1566,8 @@ lcp_reqci(fsm *f, u_char *inp, int *lenp
 	     * which are set in lcp_allowoptions[unit].asyncmap.
 	     */
 	    if ((ao->asyncmap & ~cilong) != 0) {
+	    /* Ron Add for lcp debug */
+	    dbglog("CI_ASYNCMAP:ao->asyncmap==%d cilong=%d",ao->asyncmap,cilong);
 		orc = CONFNAK;
 		PUTCHAR(CI_ASYNCMAP, nakp);
 		PUTCHAR(CILEN_LONG, nakp);
@@ -1552,6 +1584,8 @@ lcp_reqci(fsm *f, u_char *inp, int *lenp
 		/*
 		 * Reject the option if we're not willing to authenticate.
 		 */
+	    /* Ron Add for lcp debug */
+	    dbglog("CI_AUTHTYPE:cilen==%d ao->neg_upap==%d ao->neg_chap==%d",cilen,ao->neg_upap,ao->neg_chap);
 		dbglog("No auth is possible");
 		orc = CONFREJ;
 		break;
@@ -1574,10 +1608,14 @@ lcp_reqci(fsm *f, u_char *inp, int *lenp
 		if (ho->neg_chap || ho->neg_eap ||
 		    cilen != CILEN_SHORT) {
 		    LCPDEBUG(("lcp_reqci: rcvd AUTHTYPE PAP, rejecting..."));
+	    /* Ron Add for lcp debug */
+	    dbglog("CI_AUTHTYPE:ho->neg_chap==%d cilen==%d",ho->neg_chap,cilen);
 		    orc = CONFREJ;
 		    break;
 		}
 		if (!ao->neg_upap) {	/* we don't want to do PAP */
+	    /* Ron Add for lcp debug */
+	    dbglog("CI_AUTHTYPE:ao->neg_upap==%d",ao->neg_upap);
 		    orc = CONFNAK;	/* NAK it and suggest CHAP or EAP */
 		    PUTCHAR(CI_AUTHTYPE, nakp);
 		    if (ao->neg_eap) {
@@ -1597,11 +1635,15 @@ lcp_reqci(fsm *f, u_char *inp, int *lenp
 		/* we've already accepted PAP or EAP */
 		if (ho->neg_upap || ho->neg_eap ||
 		    cilen != CILEN_CHAP) {
+	    /* Ron Add for lcp debug */
+	    dbglog("CI_AUTHTYPE:ho->neg_upap==%d cilen==%d",ho->neg_upap,cilen);
 		    LCPDEBUG(("lcp_reqci: rcvd AUTHTYPE CHAP, rejecting..."));
 		    orc = CONFREJ;
 		    break;
 		}
 		if (!ao->neg_chap) {	/* we don't want to do CHAP */
+	    /* Ron Add for lcp debug */
+	    dbglog("CI_AUTHTYPE:ao->neg_chap==%d",ao->neg_chap);
 		    orc = CONFNAK;	/* NAK it and suggest EAP or PAP */
 		    PUTCHAR(CI_AUTHTYPE, nakp);
 		    PUTCHAR(CILEN_SHORT, nakp);
@@ -1618,6 +1660,8 @@ lcp_reqci(fsm *f, u_char *inp, int *lenp
 		     * We can't/won't do the requested type,
 		     * suggest something else.
 		     */
+	    /* Ron Add for lcp debug */
+	    dbglog("CI_AUTHTYPE:cichar==%d",cichar);
 		    orc = CONFNAK;
 		    PUTCHAR(CI_AUTHTYPE, nakp);
 		    PUTCHAR(CILEN_CHAP, nakp);
@@ -1638,6 +1682,8 @@ lcp_reqci(fsm *f, u_char *inp, int *lenp
 		}
 		if (!ao->neg_eap) {	/* we don't want to do EAP */
 		    orc = CONFNAK;	/* NAK it and suggest CHAP or PAP */
+	    /* Ron Add for lcp debug */
+	    dbglog("CI_AUTHTYPE:nakp");
 		    PUTCHAR(CI_AUTHTYPE, nakp);
 		    if (ao->neg_chap) {
 			PUTCHAR(CILEN_CHAP, nakp);
@@ -1678,6 +1724,8 @@ lcp_reqci(fsm *f, u_char *inp, int *lenp
 	    if (!ao->neg_lqr ||
 		cilen != CILEN_LQR) {
 		orc = CONFREJ;
+	    /* Ron Add for lcp debug */
+	    dbglog("CI_QUALITY:ao->neg_lqr==%d cilen==%d",ao->neg_lqr,cilen);
 		break;
 	    }
 
@@ -1690,6 +1738,7 @@ lcp_reqci(fsm *f, u_char *inp, int *lenp
 	     */
 	    if (cishort != PPP_LQR) {
 		orc = CONFNAK;
+	    /* Ron Add for lcp debug */	    dbglog("CI_QUALITY:cishort==%d",cishort);
 		PUTCHAR(CI_QUALITY, nakp);
 		PUTCHAR(CILEN_LQR, nakp);
 		PUTSHORT(PPP_LQR, nakp);
@@ -1701,6 +1750,8 @@ lcp_reqci(fsm *f, u_char *inp, int *lenp
 	case CI_MAGICNUMBER:
 	    if (!(ao->neg_magicnumber || go->neg_magicnumber) ||
 		cilen != CILEN_LONG) {
+	    /* Ron Add for lcp debug */
+	    dbglog("CI_MAGICNUMBER:ao->neg_magicnumber==%d go->neg_magicnumber==%d cilen==%d",ao->neg_magicnumber,go->neg_magicnumber,cilen);
 		orc = CONFREJ;
 		break;
 	    }
@@ -1712,6 +1763,8 @@ lcp_reqci(fsm *f, u_char *inp, int *lenp
 	    if (go->neg_magicnumber &&
 		cilong == go->magicnumber) {
 		cilong = magic();	/* Don't put magic() inside macro! */
+	    /* Ron Add for lcp debug */
+	    dbglog("CI_MAGICNUMBER:go->neg_magicnumber==%d cilong==%d",go->neg_magicnumber,cilong);
 		orc = CONFNAK;
 		PUTCHAR(CI_MAGICNUMBER, nakp);
 		PUTCHAR(CILEN_LONG, nakp);
@@ -1726,6 +1779,8 @@ lcp_reqci(fsm *f, u_char *inp, int *lenp
 	case CI_PCOMPRESSION:
 	    if (!ao->neg_pcompression ||
 		cilen != CILEN_VOID) {
+	    /* Ron Add for lcp debug */
+	    dbglog("CI_PCOMPRESSION:ao->neg_pcompression==%d cilen==%d",ao->neg_pcompression,cilen);
 		orc = CONFREJ;
 		break;
 	    }
@@ -1735,6 +1790,8 @@ lcp_reqci(fsm *f, u_char *inp, int *lenp
 	case CI_ACCOMPRESSION:
 	    if (!ao->neg_accompression ||
 		cilen != CILEN_VOID) {
+	    /* Ron Add for lcp debug */
+	    dbglog("CI_ACCOMPRESSION:ao->neg_accompression==%d cilen==%d",ao->neg_accompression,cilen);
 		orc = CONFREJ;
 		break;
 	    }
@@ -1744,6 +1801,8 @@ lcp_reqci(fsm *f, u_char *inp, int *lenp
 	case CI_MRRU:
 	    if (!ao->neg_mrru || !multilink ||
 		cilen != CILEN_SHORT) {
+	    /* Ron Add for lcp debug */
+	    dbglog("CI_MRRU:ao->neg_mrru==%d multilink==%d cilen==%d",ao->neg_mrru,multilink,cilen);
 		orc = CONFREJ;
 		break;
 	    }
@@ -1757,6 +1816,8 @@ lcp_reqci(fsm *f, u_char *inp, int *lenp
 	case CI_SSNHF:
 	    if (!ao->neg_ssnhf || !multilink ||
 		cilen != CILEN_VOID) {
+	    /* Ron Add for lcp debug */
+	    dbglog("CI_SSNHF:ao->neg_ssnhf==%d multilink==%d cilen==%d",ao->neg_ssnhf,multilink,cilen);
 		orc = CONFREJ;
 		break;
 	    }
@@ -1767,6 +1828,8 @@ lcp_reqci(fsm *f, u_char *inp, int *lenp
 	    if (!ao->neg_endpoint ||
 		cilen < CILEN_CHAR ||
 		cilen > CILEN_CHAR + MAX_ENDP_LEN) {
+	    /* Ron Add for lcp debug */
+	    dbglog("CI_EPDISC:ao->neg_endpoint==%d cilen==%d",ao->neg_endpoint,cilen);
 		orc = CONFREJ;
 		break;
 	    }
@@ -1780,7 +1843,8 @@ lcp_reqci(fsm *f, u_char *inp, int *lenp
 	    break;
 
 	default:
-	    LCPDEBUG(("lcp_reqci: rcvd unknown option %d", citype));
+	    /* Ron Add for lcp debug */
+	    dbglog("rcvd unknown option %d",citype);
 	    orc = CONFREJ;
 	    break;
 	}
@@ -1793,14 +1857,20 @@ endswitch:
 	if (orc == CONFNAK) {		/* Nak this CI? */
 	    if (reject_if_disagree	/* Getting fed up with sending NAKs? */
 		&& citype != CI_MAGICNUMBER) {
+	    /* Ron Add for lcp debug */
+	    dbglog("endswitch:reject_if_disagree==%d citype==%d",reject_if_disagree,citype);
 		orc = CONFREJ;		/* Get tough if so */
 	    } else {
 		if (rc == CONFREJ)	/* Rejecting prior CI? */
 		    continue;		/* Don't send this one */
+	    /* Ron Add for lcp debug */
+	    dbglog("endswitch:CONFNAK");
 		rc = CONFNAK;
 	    }
 	}
 	if (orc == CONFREJ) {		/* Reject this CI */
+	    /* Ron Add for lcp debug */
+	    dbglog("endswitch:CONFREJ");
 	    rc = CONFREJ;
 	    if (cip != rejp)		/* Need to move rejected CI? */
 		BCOPY(cip, rejp, cilen); /* Move it */
@@ -1831,7 +1901,6 @@ endswitch:
 	break;
     }
 
-    LCPDEBUG(("lcp_reqci: returning CONF%s.", CODENAME(rc)));
     return (rc);			/* Return final code */
 }
 
@@ -1863,12 +1932,13 @@ lcp_up(fsm *f)
      * MTU we want to use, and our link MRU.
      */
     mtu = ho->neg_mru? ho->mru: PPP_MRU;
+    info("mtu is <%d> ao->mru is <%d>\n", mtu, ao->mru);
     mru = go->neg_mru? MAX(wo->mru, go->mru): PPP_MRU;
 #ifdef HAVE_MULTILINK
     if (!(multilink && go->neg_mrru && ho->neg_mrru))
 #endif /* HAVE_MULTILINK */
 	netif_set_mtu(f->unit, MIN(MIN(mtu, mru), ao->mru));
-    ppp_send_config(f->unit, mtu,
+    ppp_send_config(f->unit, MIN(mtu, ao->mru),
 		    (ho->neg_asyncmap? ho->asyncmap: 0xffffffff),
 		    ho->neg_pcompression, ho->neg_accompression);
     ppp_recv_config(f->unit, mru,
@@ -2218,7 +2288,22 @@ LcpEchoTimeout (void *arg)
         LcpEchoCheck ((fsm *) arg);
     }
 }
-
+#ifdef CABLE_DETECT
+/*handle signal for cable up*/
+void
+LcpEchoImmediately (unit)
+    int unit;
+{
+    fsm *f = &lcp_fsm[unit];
+    if(f->state != OPENED)
+        return;
+    lcp_echos_pending = 0;
+    if (lcp_echo_timer_running != 0) {
+        UNTIMEOUT (LcpEchoTimeout, f);
+        LcpEchoTimeout(f);
+    }
+}
+#endif
 /*
  * LcpEchoReply - LCP has received a reply to the echo
  */
@@ -2242,6 +2327,13 @@ lcp_received_echo_reply (fsm *f, int id,
 
     /* Reset the number of outstanding echo frames */
     lcp_echos_pending = 0;
+#ifdef CABLE_DETECT
+    if(cable_just_up)
+    {
+        system("/usr/sbin/led_app on 20");
+        cable_just_up = 0;
+    }
+#endif
 }
 
 /*
@@ -2253,15 +2345,26 @@ LcpSendEchoRequest (fsm *f)
 {
     u_int32_t lcp_magic;
     u_char pkt[4], *pktp;
-
-    /*
-     * Detect the failure of the peer at this point.
-     */
-    if (lcp_echo_fails != 0) {
-        if (lcp_echos_pending >= lcp_echo_fails) {
-            LcpLinkFailure(f);
-	    lcp_echos_pending = 0;
-	}
+    /* 2005.11.3 add to fix LCP down issue */
+    struct pppd_stats stats;
+    static int bytes_in=0;
+
+    get_ppp_stats(0, &stats);
+    if(stats.bytes_in != bytes_in) {
+        /* We got some packets from Server, treat it as LCP echo reply. -- Argon */
+        lcp_echos_pending=0;
+        bytes_in=stats.bytes_in;
+    }
+    else {
+        /*
+         * Detect the failure of the peer at this point.
+         */
+        if (lcp_echo_fails != 0) {
+            if (lcp_echos_pending >= lcp_echo_fails) {
+                LcpLinkFailure(f);
+                lcp_echos_pending = 0;
+            }
+        }
     }
 
     /*
--- work/ppp-2.4.9/pppd/lcp.h	2021-01-05 00:06:37.000000000 +0100
+++ work/ppp-2.4.9/pppd/lcp.h	2022-03-09 14:31:33.731398000 +0100
@@ -125,6 +125,9 @@ void lcp_close(int, char *);
 void lcp_lowerup(int);
 void lcp_lowerdown(int);
 void lcp_sprotrej(int, u_char *, int);	/* send protocol reject */
+#ifdef CABLE_DETECT
+void LcpEchoImmediately (int unit);
+#endif
 
 extern struct protent lcp_protent;
 
--- work/ppp-2.4.9/pppd/main.c	2021-01-05 00:06:37.000000000 +0100
+++ work/ppp-2.4.9/pppd/main.c	2022-03-11 17:10:36.287992465 +0100
@@ -87,7 +87,7 @@
 #include <sys/socket.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
-
+#include <sys/sysinfo.h>
 #include "pppd.h"
 #include "magic.h"
 #include "fsm.h"
@@ -160,6 +160,7 @@ int (*new_phase_hook)(int) = NULL;
 void (*snoop_recv_hook)(unsigned char *p, int len) = NULL;
 void (*snoop_send_hook)(unsigned char *p, int len) = NULL;
 
+static void setup_usr1_signals(void);
 static int conn_running;	/* we have a [dis]connector running */
 static int fd_loop;		/* fd for getting demand-dial packets */
 
@@ -174,6 +175,18 @@ int listen_time;
 int got_sigusr2;
 int got_sigterm;
 int got_sighup;
+#ifdef CABLE_DETECT
+int cable_just_up = 0;
+#endif
+int signal_no;
+/*
+ * Add by Argon 2003-7-6
+ * Only in dial on demand mode.
+ *
+ * If we got SIGUSR1, set it to 1, then we should dial(when no link active)
+ * PPP link in Dial-On-Demand mode.
+ */
+int got_user_cmd = 0;
 
 static sigset_t signals_handled;
 static int waiting;
@@ -235,8 +248,11 @@ static void kill_my_pg(int);
 static void hup(int);
 static void term(int);
 static void chld(int);
-static void toggle_debug(int);
+static void sig_connect(int sig);
 static void open_ccp(int);
+#ifdef CABLE_DETECT
+static void kick_lcp_echo __P((int));
+#endif
 static void bad_signal(int);
 static void holdoff_end(void *);
 static void forget_child(int pid, int status);
@@ -254,8 +270,14 @@ static void handle_events(void);
 void print_link_stats(void);
 
 extern	char	*getlogin(void);
+
+void (*set_line_discipline_hook) __P((int fd));
+void (*reset_line_discipline_hook) __P((int));
+
 int main(int, char *[]);
 
+static int get_current_time(struct timeval *tv, struct timezone *tz);
+
 /*
  * PPP Data Link Layer "protocol" table.
  * One entry per supported protocol.
@@ -284,6 +306,10 @@ struct protent *protocols[] = {
     NULL
 };
 
+#ifdef MULTI_OFFER
+void (*p_marksuccessserver)() = NULL;
+#endif
+
 int
 main(int argc, char *argv[])
 {
@@ -296,6 +322,7 @@ main(int argc, char *argv[])
     strlcpy(path_ipup, _PATH_IPUP, sizeof(path_ipup));
     strlcpy(path_ipdown, _PATH_IPDOWN, sizeof(path_ipdown));
 
+    get_current_time(&start_time, NULL);
     link_stats_valid = 0;
     new_phase(PHASE_INITIALIZE);
 
@@ -349,6 +376,21 @@ main(int argc, char *argv[])
 	exit(EXIT_OPTION_ERROR);
     devnam_fixed = 1;		/* can no longer change device name */
 
+	// Allen
+	if( lcp_file == NULL)
+		lcp_file = "/tmp/lcp";
+	if( pppd_fail == NULL)
+		pppd_fail = "/tmp/pppd.fail";
+
+	if( demand_file == NULL)
+		demand_file = "/tmp/demand";
+
+	printf("pppd: unit=%d\n",req_unit);
+	
+	// Ron	
+    	unlink(pppd_fail);
+    	unlink(lcp_file);
+
     /*
      * Work out the device name, if it hasn't already been specified,
      * and parse the tty's options file.
@@ -386,9 +428,9 @@ main(int argc, char *argv[])
     for (i = 0; (protp = protocols[i]) != NULL; ++i)
 	if (protp->check_options != NULL)
 	    (*protp->check_options)();
-    if (the_channel->check_options)
+    if (the_channel->check_options) {
 	(*the_channel->check_options)();
-
+    }
 
     if (dump_options || dryrun) {
 	init_pr_log(NULL, LOG_INFO);
@@ -415,20 +457,6 @@ main(int argc, char *argv[])
      */
     sys_init();
 
-#ifdef USE_TDB
-    pppdb = tdb_open(_PATH_PPPDB, 0, 0, O_RDWR|O_CREAT, 0644);
-    if (pppdb != NULL) {
-	slprintf(db_key, sizeof(db_key), "pppd%d", getpid());
-	update_db_entry();
-    } else {
-	warn("Warning: couldn't open ppp database %s", _PATH_PPPDB);
-	if (multilink) {
-	    warn("Warning: disabling multilink");
-	    multilink = 0;
-	}
-    }
-#endif
-
     /*
      * Detach ourselves from the terminal, if required,
      * and identify who is running us.
@@ -472,11 +500,23 @@ main(int argc, char *argv[])
 	demand_conf();
     }
 
+    info("setting line discipline hook");
+    set_line_discipline_hook = the_channel->set_line_discipline_hook;
+    reset_line_discipline_hook = the_channel->reset_line_discipline_hook;
+
     do_callback = 0;
     for (;;) {
 
 	bundle_eof = 0;
 	bundle_terminating = 0;
+	setup_usr1_signals();
+#ifdef TRAFFIC_METER
+	if (access("/tmp/tm_block_internet", F_OK) == 0)
+	{
+		sleep(1); // sleep a while to low cpu load
+		continue;
+	}
+#endif
 	listen_time = 0;
 	need_holdoff = 1;
 	devfd = -1;
@@ -498,6 +538,11 @@ main(int argc, char *argv[])
 		    break;
 		if (get_loop_output())
 		    break;
+            if (got_user_cmd){
+                info("Got connect command.");
+                got_user_cmd = 0;
+                break;
+            }
 	    }
 	    remove_fd(fd_loop);
 	    if (asked_to_quit)
@@ -510,7 +555,9 @@ main(int argc, char *argv[])
 	    info("Starting link");
 	}
 
-	get_time(&start_time);
+	signal(SIGUSR1, SIG_IGN);
+
+	get_current_time(&start_time, NULL);
 	script_unsetenv("CONNECT_TIME");
 	script_unsetenv("BYTES_SENT");
 	script_unsetenv("BYTES_RCVD");
@@ -545,13 +592,44 @@ main(int argc, char *argv[])
 	t = need_holdoff? holdoff: 0;
 	if (holdoff_hook)
 	    t = (*holdoff_hook)();
+#ifdef CABLE_DETECT
+	/*netgear spec 1.9: When the physical link is down, 
+	the Internet state is set to as no IP address acquired, 
+	so the LED first shows amber after the physical link 
+	comes back. When the router detects that the physical
+	link is back, it should send out a LCP echo request 
+	immediately. If the echo reply is received, the LED 
+	goes green. If there is no reply after 3 retires, 
+	the link is treated down and the IP address should be released. 
+	If the auto-reconnect option is selected, the router 
+	re-attempts to connect the link right away, or a 
+	connection is re-attempted when there is a demand, 
+	and the LED becomes green after the PPP link is up 
+	and an IP address is acquired.*/
+	if(cable_just_up)
+	{
+	    /*connection down when cable up again*/
+	    cable_just_up = 0;
+	    t = 0;/*reconnect asap*/
+	}
+#endif	
 	if (t > 0) {
+	    info("Try to reconnect after %d seconds\n",t);
 	    new_phase(PHASE_HOLDOFF);
 	    TIMEOUT(holdoff_end, NULL, t);
 	    do {
 		handle_events();
 		if (kill_link)
 		    new_phase(PHASE_DORMANT); /* allow signal to end holdoff */
+#ifdef CABLE_DETECT
+		if(cable_just_up)
+		{
+		    info("Cable up, reconnect right away\n");
+		    cable_just_up = 0;
+		    UNTIMEOUT(holdoff_end, NULL);
+		    holdoff_end(NULL);
+		}
+#endif
 	    } while (phase == PHASE_HOLDOFF);
 	    if (!persist)
 		break;
@@ -629,6 +707,38 @@ handle_events(void)
 }
 
 /*
+ * setup_usr1_signals - initialize signal handling.
+ */
+static void
+setup_usr1_signals(void)
+{
+    struct sigaction sa;
+    sigset_t mask;
+
+    /*
+     * Compute mask of all interesting signals and install signal handlers
+     * for each.  Only one signal handler may be active at a time.  Therefore,
+     * all other signals should be masked when any handler is executing.
+     */
+    sigemptyset(&mask);
+    sigaddset(&mask, SIGHUP);
+    sigaddset(&mask, SIGINT);
+    sigaddset(&mask, SIGTERM);
+    sigaddset(&mask, SIGCHLD);
+    sigaddset(&mask, SIGUSR2);
+
+#define SIGNAL(s, handler)	do { \
+	sa.sa_handler = handler; \
+	if (sigaction(s, &sa, NULL) < 0) \
+	    fatal("Couldn't establish signal handler (%d): %m", s); \
+    } while (0)
+
+    sa.sa_mask = mask;
+    sa.sa_flags = 0;
+    SIGNAL(SIGUSR1, sig_connect);		/* Hangup */
+}
+
+/*
  * setup_signals - initialize signal handling.
  */
 static void
@@ -669,9 +779,12 @@ setup_signals(void)
     SIGNAL(SIGTERM, term);		/* Terminate */
     SIGNAL(SIGCHLD, chld);
 
-    SIGNAL(SIGUSR1, toggle_debug);	/* Toggle debug flag */
+    SIGNAL(SIGUSR1, sig_connect);   /* Connect PPP link in dod mode */
     SIGNAL(SIGUSR2, open_ccp);		/* Reopen CCP */
 
+#ifdef CABLE_DETECT
+    SIGNAL(50,kick_lcp_echo);
+#endif
     /*
      * Install a handler for other signals which would otherwise
      * cause pppd to exit without cleaning up.
@@ -759,6 +872,7 @@ detach(void)
     if ((pid = fork()) < 0) {
 	error("Couldn't detach (fork failed: %m)");
 	die(1);			/* or just return? */
+	return;
     }
     if (pid != 0) {
 	/* parent */
@@ -1203,7 +1317,7 @@ reset_link_stats(int u)
 {
     if (!get_ppp_stats(u, &old_link_stats))
 	return;
-    get_time(&start_time);
+    get_current_time(&start_time, NULL);
 }
 
 /*
@@ -1216,7 +1330,7 @@ update_link_stats(int u)
     char numbuf[32];
 
     if (!get_ppp_stats(u, &link_stats)
-	|| get_time(&now) < 0)
+	|| get_current_time(&now, NULL) < 0)
 	return;
     link_connect_time = now.tv_sec - start_time.tv_sec;
     link_stats_valid = 1;
@@ -1260,7 +1374,7 @@ timeout(void (*func)(void *), void *arg,
 	fatal("Out of memory in timeout()!");
     newp->c_arg = arg;
     newp->c_func = func;
-    get_time(&timenow);
+    get_current_time(&timenow, NULL);
     newp->c_time.tv_sec = timenow.tv_sec + secs;
     newp->c_time.tv_usec = timenow.tv_usec + usecs;
     if (newp->c_time.tv_usec >= 1000000) {
@@ -1312,7 +1426,7 @@ calltimeout(void)
     while (callout != NULL) {
 	p = callout;
 
-	if (get_time(&timenow) < 0)
+	if (get_current_time(&timenow, NULL) < 0)
 	    fatal("Failed to get time of day: %m");
 	if (!(p->c_time.tv_sec < timenow.tv_sec
 	      || (p->c_time.tv_sec == timenow.tv_sec
@@ -1336,7 +1450,7 @@ timeleft(struct timeval *tvp)
     if (callout == NULL)
 	return NULL;
 
-    get_time(&timenow);
+    get_current_time(&timenow, NULL);
     tvp->tv_sec = callout->c_time.tv_sec - timenow.tv_sec;
     tvp->tv_usec = callout->c_time.tv_usec - timenow.tv_usec;
     if (tvp->tv_usec < 0) {
@@ -1425,6 +1539,7 @@ term(int sig)
 {
     /* can't log a message here, it can deadlock */
     got_sigterm = sig;
+    signal_no = SIGTERM;
     if (conn_running)
 	/* Send the signal to the [dis]connector process(es) also */
 	kill_my_pg(sig);
@@ -1446,25 +1561,11 @@ chld(int sig)
 	write(sigpipe[1], &sig, sizeof(sig));
 }
 
-
-/*
- * toggle_debug - Catch SIGUSR1 signal.
- *
- * Toggle debug flag.
- */
-/*ARGSUSED*/
-static void
-toggle_debug(int sig)
+static void sig_connect(int sig)
 {
-    debug = !debug;
-    if (debug) {
-	setlogmask(LOG_UPTO(LOG_DEBUG));
-    } else {
-	setlogmask(LOG_UPTO(LOG_WARNING));
-    }
+    got_user_cmd = 1;
 }
 
-
 /*
  * open_ccp - Catch SIGUSR2 signal.
  *
@@ -1479,6 +1580,15 @@ open_ccp(int sig)
 	write(sigpipe[1], &sig, sizeof(sig));
 }
 
+#ifdef CABLE_DETECT
+static void
+kick_lcp_echo(sig)
+    int sig;
+{
+    cable_just_up = 1;
+    LcpEchoImmediately(0);
+}
+#endif
 
 /*
  * bad_signal - We've caught a fatal signal.  Clean up state and exit.
@@ -2105,8 +2215,6 @@ update_db_entry(void)
     key.dsize = strlen(db_key);
     dbuf.dptr = vbuf;
     dbuf.dsize = vlen;
-    if (tdb_store(pppdb, key, dbuf, TDB_REPLACE))
-	error("tdb_store failed: %s", tdb_errorstr(pppdb));
 
     if (vbuf)
         free(vbuf);
@@ -2125,8 +2233,6 @@ add_db_key(const char *str)
     key.dsize = strlen(str);
     dbuf.dptr = db_key;
     dbuf.dsize = strlen(db_key);
-    if (tdb_store(pppdb, key, dbuf, TDB_REPLACE))
-	error("tdb_store key failed: %s", tdb_errorstr(pppdb));
 }
 
 /*
@@ -2139,7 +2245,6 @@ delete_db_key(const char *str)
 
     key.dptr = (char *) str;
     key.dsize = strlen(str);
-    tdb_delete(pppdb, key);
 }
 
 /*
@@ -2154,9 +2259,29 @@ cleanup_db(void)
 
     key.dptr = db_key;
     key.dsize = strlen(db_key);
-    tdb_delete(pppdb, key);
     for (i = 0; (p = script_env[i]) != 0; ++i)
 	if (p[-1])
 	    delete_db_key(p);
 }
 #endif /* USE_TDB */
+
+/*
+ * get_current_time() -- function to replace gettimeofday() because
+ *                       gettimeofday() is related to UTC time but router's UTC time will be changed by NTP.
+ *                       This will cause time function not correct.
+ *                       We use system uptime as time.
+ */
+static int get_current_time(struct timeval *tv, struct timezone *tz) {
+    struct sysinfo info;
+    int ret;
+
+    ret = sysinfo(&info);
+    if(ret) {
+        /* something wrong */
+        return ret;
+    }
+
+    tv->tv_sec = info.uptime;
+    tv->tv_usec = 0;
+    return 0;
+}
--- work/ppp-2.4.9/pppd/options.c	2021-01-05 00:06:37.000000000 +0100
+++ work/ppp-2.4.9/pppd/options.c	2022-03-12 14:41:27.717322487 +0100
@@ -78,6 +78,11 @@
 char *strdup(char *);
 #endif
 
+char *get_pppd_version(void);
+void pppoe_plugin_init(void);
+#ifndef _DISABLE_PPPOA_
+void pppoatm_plugin_init(void);
+#endif
 
 struct option_value {
     struct option_value *next;
@@ -105,6 +110,10 @@ bool	persist = 0;		/* Reopen link after
 char	our_name[MAXNAMELEN];	/* Our name for authentication purposes */
 bool	demand = 0;		/* do dial-on-demand */
 char	*ipparam = NULL;	/* Extra parameter for ip up/down scripts */
+char	*ipparam2 = NULL;	/* Extra parameter for ip up/down scripts */
+char	*lcp_file= NULL;	/* Extra parameter for "/tmp/lcp" */
+char	*pppd_fail = NULL;	/* Extra parameter for "/tmp/ppp.fail" */
+char	*demand_file= NULL;	
 int	idle_time_limit = 0;	/* Disconnect if idle for this many seconds */
 int	holdoff = 30;		/* # seconds to pause before reconnecting */
 bool	holdoff_specified;	/* true if a holdoff value has been given */
@@ -809,6 +818,7 @@ process_option(option_t *opt, char *cmd,
 	    return 0;
 	if (opt->flags & OPT_A2LIST) {
 	    struct option_value *ovp, *pp;
+	    void *void_pp;
 
 	    ovp = malloc(sizeof(*ovp) + strlen(*argv));
 	    if (ovp != 0) {
@@ -818,7 +828,8 @@ process_option(option_t *opt, char *cmd,
 		if (opt->addr2 == NULL) {
 		    opt->addr2 = ovp;
 		} else {
-		    for (pp = opt->addr2; pp->next != NULL; pp = pp->next)
+ 		    void_pp = opt->addr2;
+		    for (pp = (struct option_value *)void_pp; pp->next != NULL; pp = pp->next)
 			;
 		    pp->next = ovp;
 		}
@@ -898,6 +909,23 @@ add_options(option_t *opt)
 }
 
 /*
+ * remove_option - permanently remove an option from consideration...
+ * for use by modules to remove choices which no longer make sense.
+ * returns true if found an option
+ */
+int
+remove_option(name)
+    char *name;
+{
+    option_t *o;
+    o = find_option(name);
+    if (o == NULL)
+	return 0;
+    o->name = "";
+    return 1;
+}
+
+/*
  * check_options - check that options are valid and consistent.
  */
 void
@@ -999,7 +1027,7 @@ print_option(option_t *opt, option_t *ma
 		break;
 
 	default:
-		printer(arg, "# %s value (type %d\?\?)", opt->name, opt->type);
+		printer(arg, "# %s value (type %d)", opt->name, opt->type);
 		break;
 	}
 	printer(arg, "\t\t# (from %s)\n", mainopt->source);
@@ -1573,53 +1601,29 @@ static int
 loadplugin(char **argv)
 {
     char *arg = *argv;
-    void *handle;
-    const char *err;
-    void (*init)(void);
-    char *path = arg;
     const char *vers;
 
-    if (strchr(arg, '/') == 0) {
-	const char *base = _PATH_PLUGIN;
-	int l = strlen(base) + strlen(arg) + 2;
-	path = malloc(l);
-	if (path == 0)
-	    novm("plugin file path");
-	strlcpy(path, base, l);
-	strlcat(path, "/", l);
-	strlcat(path, arg, l);
-    }
-    handle = dlopen(path, RTLD_GLOBAL | RTLD_NOW);
-    if (handle == 0) {
-	err = dlerror();
-	if (err != 0)
-	    option_error("%s", err);
-	option_error("Couldn't load plugin %s", arg);
-	goto err;
-    }
-    init = (void (*)(void))dlsym(handle, "plugin_init");
-    if (init == 0) {
-	option_error("%s has no initialization entry point", arg);
-	goto errclose;
-    }
-    vers = (const char *) dlsym(handle, "pppd_version");
-    if (vers == 0) {
-	warn("Warning: plugin %s has no version information", arg);
-    } else if (strcmp(vers, VERSION) != 0) {
+    vers = get_pppd_version();
+    if (strcmp(vers, VERSION) != 0) {
 	option_error("Plugin %s is for pppd version %s, this is %s",
-		     arg, vers, VERSION);
-	goto errclose;
+		     vers, VERSION);
+	return 0;
     }
+
     info("Plugin %s loaded.", arg);
-    (*init)();
+    if (strcmp(arg, "pppoe") == 0) {
+    	pppoe_plugin_init();
+    } else if (strcmp(arg, "pppoa") == 0) {
+    #ifndef _DISABLE_PPPOA_
+	pppoatm_plugin_init();
+    #endif
+    }
+    else {
+	option_error("Invalid plugin %s", arg);
+	return (0);
+    }
+    info("Plugin %s called.", arg);
     return 1;
-
- errclose:
-    dlclose(handle);
- err:
-    if (path != arg)
-	free(path);
-    return 0;
 }
 #endif /* PLUGIN */
 
--- work/ppp-2.4.9/pppd/plugins/pppoatm/atmbr2684.h	1970-01-01 01:00:00.000000000 +0100
+++ work/ppp-2.4.9/pppd/plugins/pppoatm/atmbr2684.h	2021-12-16 16:38:08.000000000 +0100
@@ -0,0 +1,189 @@
+#ifndef _LINUX_ATMBR2684_H
+#define _LINUX_ATMBR2684_H
+
+#include <linux/atm.h>
+//#include <linux/if.h>		/* For IFNAMSIZ */
+#define IFNAMSIZ 16
+#define T2A_PVC		  1	/* address is PVC */
+#define SOL_SOCKET	0xffff
+#define SO_SNDBUF	0x1001	/* Send buffer size. */
+#define SOL_IP		0
+#define SOL_TCP		6
+#define SOL_UDP		17
+#define SOL_IPV6	41
+#define SOL_ICMPV6	58
+#define SOL_RAW		255
+#define SOL_IPX		256
+#define SOL_AX25	257
+#define SOL_ATALK	258
+#define SOL_NETROM	259
+#define SOL_ROSE	260
+#define SOL_DECNET	261
+#define	SOL_X25		262
+#define SOL_PACKET	263
+#define SOL_ATM		264	/* ATM layer (cell level) */
+#define SOL_AAL		265	/* ATM Adaption Layer (packet level) */
+#define SOL_IRDA        266
+#define PF_UNSPEC	AF_UNSPEC
+#define PF_UNIX		AF_UNIX
+#define PF_LOCAL	AF_LOCAL
+#define PF_INET		AF_INET
+#define PF_AX25		AF_AX25
+#define PF_IPX		AF_IPX
+#define PF_APPLETALK	AF_APPLETALK
+#define	PF_NETROM	AF_NETROM
+#define PF_BRIDGE	AF_BRIDGE
+#define PF_ATMPVC	AF_ATMPVC
+#define PF_X25		AF_X25
+#define PF_INET6	AF_INET6
+#define PF_ROSE		AF_ROSE
+#define PF_DECnet	AF_DECnet
+#define PF_NETBEUI	AF_NETBEUI
+#define PF_SECURITY	AF_SECURITY
+#define PF_KEY		AF_KEY
+#define PF_NETLINK	AF_NETLINK
+#define PF_ROUTE	AF_ROUTE
+#define PF_PACKET	AF_PACKET
+#define PF_ASH		AF_ASH
+#define PF_ECONET	AF_ECONET
+#define PF_ATMSVC	AF_ATMSVC
+#define PF_SNA		AF_SNA
+#define PF_IRDA		AF_IRDA
+#define PF_PPPOX	AF_PPPOX
+#define PF_MAX		AF_MAX
+#define AF_UNSPEC	0
+#define AF_UNIX		1	/* Unix domain sockets 		*/
+#define AF_LOCAL	1	/* POSIX name for AF_UNIX	*/
+#define AF_INET		2	/* Internet IP Protocol 	*/
+#define AF_AX25		3	/* Amateur Radio AX.25 		*/
+#define AF_IPX		4	/* Novell IPX 			*/
+#define AF_APPLETALK	5	/* AppleTalk DDP 		*/
+#define AF_NETROM	6	/* Amateur Radio NET/ROM 	*/
+#define AF_BRIDGE	7	/* Multiprotocol bridge 	*/
+#define AF_ATMPVC	8	/* ATM PVCs			*/
+#define AF_X25		9	/* Reserved for X.25 project 	*/
+#define AF_INET6	10	/* IP version 6			*/
+#define AF_ROSE		11	/* Amateur Radio X.25 PLP	*/
+#define AF_DECnet	12	/* Reserved for DECnet project	*/
+#define AF_NETBEUI	13	/* Reserved for 802.2LLC project*/
+#define AF_SECURITY	14	/* Security callback pseudo AF */
+#define AF_KEY		15      /* PF_KEY key management API */
+#define AF_NETLINK	16
+#define AF_ROUTE	AF_NETLINK /* Alias to emulate 4.4BSD */
+#define AF_PACKET	17	/* Packet family		*/
+#define AF_ASH		18	/* Ash				*/
+#define AF_ECONET	19	/* Acorn Econet			*/
+#define AF_ATMSVC	20	/* ATM SVCs			*/
+#define AF_SNA		22	/* Linux SNA Project (nutters!) */
+#define AF_IRDA		23	/* IRDA sockets			*/
+#define AF_PPPOX	24	/* PPPoX sockets		*/
+#define AF_MAX		32	/* For now.. */
+#define SOCK_DGRAM	1		/* datagram (conn.less) socket	*/
+#define SOCK_STREAM	2		/* stream (connection) socket	*/
+#define SOCK_RAW	3		/* raw socket			*/
+#define SOCK_RDM	4		/* reliably-delivered message	*/
+#define SOCK_SEQPACKET	5		/* sequential packet socket	*/
+#define SOCK_PACKET	10		/* linux specific way of	*/
+
+
+
+/*
+ * Type of media we're bridging (ethernet, token ring, etc)  Currently only
+ * ethernet is supported
+ */
+#define BR2684_MEDIA_ETHERNET	(0)	/* 802.3 */
+#define BR2684_MEDIA_802_4	(1)	/* 802.4 */
+#define BR2684_MEDIA_TR		(2)	/* 802.5 - token ring */
+#define BR2684_MEDIA_FDDI	(3)
+#define BR2684_MEDIA_802_6	(4)	/* 802.6 */
+
+/*
+ * Is there FCS inbound on this VC?  This currently isn't supported.
+ */
+#define BR2684_FCSIN_NO		(0)
+#define BR2684_FCSIN_IGNORE	(1)
+#define BR2684_FCSIN_VERIFY	(2)
+
+/*
+ * Is there FCS outbound on this VC?  This currently isn't supported.
+ */
+#define BR2684_FCSOUT_NO	(0)
+#define BR2684_FCSOUT_SENDZERO	(1)
+#define BR2684_FCSOUT_GENERATE	(2)
+
+/*
+ * Does this VC include LLC encapsulation?
+ */
+#define BR2684_ENCAPS_VC	(0)	/* VC-mux */
+#define BR2684_ENCAPS_LLC	(1)
+#define BR2684_ENCAPS_AUTODETECT (2)	/* Unsuported */
+
+/*
+ * This is for the ATM_NEWBACKENDIF call - these are like socket families:
+ * the first element of the structure is the backend number and the rest
+ * is per-backend specific
+ */
+struct atm_newif_br2684 {
+	atm_backend_t	backend_num;	/* ATM_BACKEND_BR2684 */
+	int		media;		/* BR2684_MEDIA_* */
+	char		ifname[IFNAMSIZ];
+	int		mtu;
+};
+
+/*
+ * This structure is used to specify a br2684 interface - either by a
+ * positive integer (returned by ATM_NEWBACKENDIF) or the interfaces name
+ */
+#define BR2684_FIND_BYNOTHING	(0)
+#define BR2684_FIND_BYNUM	(1)
+#define BR2684_FIND_BYIFNAME	(2)
+struct br2684_if_spec {
+	int method;			/* BR2684_FIND_* */
+	union {
+		char		ifname[IFNAMSIZ];
+		int		devnum;
+	} spec;
+};
+
+/*
+ * This is for the ATM_SETBACKEND call - these are like socket families:
+ * the first element of the structure is the backend number and the rest
+ * is per-backend specific
+ */
+struct atm_backend_br2684 {
+	atm_backend_t	backend_num;	/* ATM_BACKEND_BR2684 */
+	struct br2684_if_spec ifspec;
+	int	fcs_in;		/* BR2684_FCSIN_* */
+	int	fcs_out;	/* BR2684_FCSOUT_* */
+	int	fcs_auto;	/* 1: fcs_{in,out} disabled if no FCS rx'ed */
+	int	encaps;		/* BR2684_ENCAPS_* */
+	int	has_vpiid;	/* 1: use vpn_id - Unsupported */
+	unsigned char	vpn_id[7];
+	//__u8	vpn_id[7];
+	int	send_padding;	/* unsupported */
+	int	min_size;	/* we will pad smaller packets than this */
+        int     flag;           /* brcm -- protocol filter flag */
+};
+
+/*
+ * The BR2684_SETFILT ioctl is an experimental mechanism for folks
+ * terminating a large number of IP-only vcc's.  When netfilter allows
+ * efficient per-if in/out filters, this support will be removed
+ */
+struct br2684_filter {
+	unsigned int	prefix;		/* network byte order */
+	unsigned int	netmask;	/* 0 = disable filter */
+	//__u32	prefix;		/* network byte order */
+	//__u32	netmask;	/* 0 = disable filter */
+};
+
+struct br2684_filter_set {
+	struct br2684_if_spec ifspec;
+	struct br2684_filter filter;
+};
+
+#define BR2684_SETFILT	_IOW( 'a', ATMIOC_BACKEND + 0, \
+				struct br2684_filter_set)
+#define BR2684_DEL	253
+
+#endif /* _LINUX_ATMBR2684_H */
--- work/ppp-2.4.9/pppd/plugins/pppoatm/atmdev.h	1970-01-01 01:00:00.000000000 +0100
+++ work/ppp-2.4.9/pppd/plugins/pppoatm/atmdev.h	2021-12-16 16:38:08.000000000 +0100
@@ -0,0 +1,529 @@
+/* atmdev.h - ATM device driver declarations and various related items */
+ 
+/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */
+ 
+
+#ifndef LINUX_ATMDEV_H
+#define LINUX_ATMDEV_H
+
+
+#include <linux/atmapi.h>
+#include <linux/atm.h>
+#include <linux/atmioc.h>
+
+
+#define ESI_LEN		6
+
+#define ATM_OC3_PCR	(155520000/270*260/8/53)
+			/* OC3 link rate:  155520000 bps
+			   SONET overhead: /270*260 (9 section, 1 path)
+			   bits per cell:  /8/53
+			   max cell rate:  353207.547 cells/sec */
+#define ATM_25_PCR	((25600000/8-8000)/54)
+			/* 25 Mbps ATM cell rate (59111) */
+#define ATM_OC12_PCR	(622080000/1080*1040/8/53)
+			/* OC12 link rate: 622080000 bps
+			   SONET overhead: /1080*1040
+			   bits per cell:  /8/53
+			   max cell rate:  1412830.188 cells/sec */
+#define ATM_DS3_PCR	(8000*12)
+			/* DS3: 12 cells in a 125 usec time slot */
+
+
+#define __AAL_STAT_ITEMS \
+    __HANDLE_ITEM(tx);			/* TX okay */ \
+    __HANDLE_ITEM(tx_err);		/* TX errors */ \
+    __HANDLE_ITEM(rx);			/* RX okay */ \
+    __HANDLE_ITEM(rx_err);		/* RX errors */ \
+    __HANDLE_ITEM(rx_drop);		/* RX out of memory */
+
+struct atm_aal_stats {
+#define __HANDLE_ITEM(i) int i
+	__AAL_STAT_ITEMS
+#undef __HANDLE_ITEM
+};
+
+
+struct atm_dev_stats {
+	struct atm_aal_stats aal0;
+	struct atm_aal_stats aal34;
+	struct atm_aal_stats aal5;
+} __ATM_API_ALIGN;
+
+
+#define ATM_GETLINKRATE	_IOW('a',ATMIOC_ITF+1,struct atmif_sioc)
+					/* get link rate */
+#define ATM_GETNAMES	_IOW('a',ATMIOC_ITF+3,struct atm_iobuf)
+					/* get interface names (numbers) */
+#define ATM_GETTYPE	_IOW('a',ATMIOC_ITF+4,struct atmif_sioc)
+					/* get interface type name */
+#define ATM_GETESI	_IOW('a',ATMIOC_ITF+5,struct atmif_sioc)
+					/* get interface ESI */
+#define ATM_GETADDR	_IOW('a',ATMIOC_ITF+6,struct atmif_sioc)
+					/* get itf's local ATM addr. list */
+#define ATM_RSTADDR	_IOW('a',ATMIOC_ITF+7,struct atmif_sioc)
+					/* reset itf's ATM address list */
+#define ATM_ADDADDR	_IOW('a',ATMIOC_ITF+8,struct atmif_sioc)
+					/* add a local ATM address */
+#define ATM_DELADDR	_IOW('a',ATMIOC_ITF+9,struct atmif_sioc)
+					/* remove a local ATM address */
+#define ATM_GETCIRANGE	_IOW('a',ATMIOC_ITF+10,struct atmif_sioc)
+					/* get connection identifier range */
+#define ATM_SETCIRANGE	_IOW('a',ATMIOC_ITF+11,struct atmif_sioc)
+					/* set connection identifier range */
+#define ATM_SETESI	_IOW('a',ATMIOC_ITF+12,struct atmif_sioc)
+					/* set interface ESI */
+#define ATM_SETESIF	_IOW('a',ATMIOC_ITF+13,struct atmif_sioc)
+					/* force interface ESI */
+#define ATM_ADDLECSADDR	_IOW('a', ATMIOC_ITF+14, struct atmif_sioc)
+					/* register a LECS address */
+#define ATM_DELLECSADDR	_IOW('a', ATMIOC_ITF+15, struct atmif_sioc)
+					/* unregister a LECS address */
+#define ATM_GETLECSADDR	_IOW('a', ATMIOC_ITF+16, struct atmif_sioc)
+					/* retrieve LECS address(es) */
+
+#define ATM_GETSTAT	_IOW('a',ATMIOC_SARCOM+0,struct atmif_sioc)
+					/* get AAL layer statistics */
+#define ATM_GETSTATZ	_IOW('a',ATMIOC_SARCOM+1,struct atmif_sioc)
+					/* get AAL layer statistics and zero */
+#define ATM_GETLOOP	_IOW('a',ATMIOC_SARCOM+2,struct atmif_sioc)
+					/* get loopback mode */
+#define ATM_SETLOOP	_IOW('a',ATMIOC_SARCOM+3,struct atmif_sioc)
+					/* set loopback mode */
+#define ATM_QUERYLOOP	_IOW('a',ATMIOC_SARCOM+4,struct atmif_sioc)
+					/* query supported loopback modes */
+#define ATM_SETSC	_IOW('a',ATMIOC_SPECIAL+1,int)
+					/* enable or disable single-copy */
+#define ATM_SETBACKEND	_IOW('a',ATMIOC_SPECIAL+2,atm_backend_t)
+					/* set backend handler */
+#define ATM_NEWBACKENDIF _IOW('a',ATMIOC_SPECIAL+3,atm_backend_t)
+					/* use backend to make new if */
+#define ATM_ADDPARTY  	_IOW('a', ATMIOC_SPECIAL+4,struct atm_iobuf)
+ 					/* add party to p2mp call */
+#ifdef CONFIG_COMPAT
+/* It actually takes struct sockaddr_atmsvc, not struct atm_iobuf */
+#define COMPAT_ATM_ADDPARTY  	_IOW('a', ATMIOC_SPECIAL+4,struct compat_atm_iobuf)
+#endif
+#define ATM_DROPPARTY 	_IOW('a', ATMIOC_SPECIAL+5,int)
+					/* drop party from p2mp call */
+#ifdef CONFIG_MIPS_BRCM
+#define ATM_EXTBACKENDIF _IOW('a',ATMIOC_SPECIAL+6,atm_backend_t)
+#define ATM_SETEXTFILT  _IOW('a',ATMIOC_SPECIAL+7,atm_backend_t)
+#endif
+
+
+/*
+ * These are backend handkers that can be set via the ATM_SETBACKEND call
+ * above.  In the future we may support dynamic loading of these - for now,
+ * they're just being used to share the ATMIOC_BACKEND ioctls
+ */
+#define ATM_BACKEND_RAW		0	
+#define ATM_BACKEND_PPP		1	/* PPPoATM - RFC2364 */
+#define ATM_BACKEND_BR2684	2	/* Bridged RFC1483/2684 */
+
+#if defined(CONFIG_MIPS_BRCM)
+#define ATM_BACKEND_RT2684       3  /* Routed RFC1483/2684 */
+#define ATM_BACKEND_BR2684_BCM   4  /* Bridged RFC1483/2684 uses Broadcom ATMAPI*/
+#define ATM_BACKEND_PPP_BCM      5  /* PPPoA uses Broadcom bcmxtmrt driver */
+#define ATM_BACKEND_PPP_BCM_DISCONN    6  /* PPPoA LCP disconnect */
+#define ATM_BACKEND_PPP_BCM_CLOSE_DEV  7  /* PPPoA close device */
+#endif
+
+
+/* for ATM_GETTYPE */
+#define ATM_ITFTYP_LEN	8	/* maximum length of interface type name */
+
+/*
+ * Loopback modes for ATM_{PHY,SAR}_{GET,SET}LOOP
+ */
+
+/* Point of loopback				CPU-->SAR-->PHY-->line--> ... */
+#define __ATM_LM_NONE	0	/* no loop back     ^     ^     ^      ^      */
+#define __ATM_LM_AAL	1	/* loop back PDUs --'     |     |      |      */
+#define __ATM_LM_ATM	2	/* loop back ATM cells ---'     |      |      */
+/* RESERVED		4	loop back on PHY side  ---'		      */
+#define __ATM_LM_PHY	8	/* loop back bits (digital) ----'      |      */
+#define __ATM_LM_ANALOG 16	/* loop back the analog signal --------'      */
+
+/* Direction of loopback */
+#define __ATM_LM_MKLOC(n)	((n))	    /* Local (i.e. loop TX to RX) */
+#define __ATM_LM_MKRMT(n)	((n) << 8)  /* Remote (i.e. loop RX to TX) */
+
+#define __ATM_LM_XTLOC(n)	((n) & 0xff)
+#define __ATM_LM_XTRMT(n)	(((n) >> 8) & 0xff)
+
+#define ATM_LM_NONE	0	/* no loopback */
+
+#define ATM_LM_LOC_AAL	__ATM_LM_MKLOC(__ATM_LM_AAL)
+#define ATM_LM_LOC_ATM	__ATM_LM_MKLOC(__ATM_LM_ATM)
+#define ATM_LM_LOC_PHY	__ATM_LM_MKLOC(__ATM_LM_PHY)
+#define ATM_LM_LOC_ANALOG __ATM_LM_MKLOC(__ATM_LM_ANALOG)
+
+#define ATM_LM_RMT_AAL	__ATM_LM_MKRMT(__ATM_LM_AAL)
+#define ATM_LM_RMT_ATM	__ATM_LM_MKRMT(__ATM_LM_ATM)
+#define ATM_LM_RMT_PHY	__ATM_LM_MKRMT(__ATM_LM_PHY)
+#define ATM_LM_RMT_ANALOG __ATM_LM_MKRMT(__ATM_LM_ANALOG)
+
+/*
+ * Note: ATM_LM_LOC_* and ATM_LM_RMT_* can be combined, provided that
+ * __ATM_LM_XTLOC(x) <= __ATM_LM_XTRMT(x)
+ */
+
+
+/* for ATM_GETCIRANGE / ATM_SETCIRANGE */
+
+#define ATM_CI_MAX      -1              /* use maximum range of VPI/VCI */
+ 
+struct atm_cirange {
+	signed char	vpi_bits;	/* 1..8, ATM_CI_MAX (-1) for maximum */
+	signed char	vci_bits;	/* 1..16, ATM_CI_MAX (-1) for maximum */
+};
+
+/* for ATM_SETSC; actually taken from the ATM_VF number space */
+
+#define ATM_SC_RX	1024		/* enable RX single-copy */
+#define ATM_SC_TX	2048		/* enable TX single-copy */
+
+#define ATM_BACKLOG_DEFAULT 32 /* if we get more, we're likely to time out
+				  anyway */
+
+/* MF: change_qos (Modify) flags */
+
+#define ATM_MF_IMMED	 1	/* Block until change is effective */
+#define ATM_MF_INC_RSV	 2	/* Change reservation on increase */
+#define ATM_MF_INC_SHP	 4	/* Change shaping on increase */
+#define ATM_MF_DEC_RSV	 8	/* Change reservation on decrease */
+#define ATM_MF_DEC_SHP	16	/* Change shaping on decrease */
+#define ATM_MF_BWD	32	/* Set the backward direction parameters */
+
+#define ATM_MF_SET	(ATM_MF_INC_RSV | ATM_MF_INC_SHP | ATM_MF_DEC_RSV | \
+			  ATM_MF_DEC_SHP | ATM_MF_BWD)
+
+/*
+ * ATM_VS_* are used to express VC state in a human-friendly way.
+ */
+
+#define ATM_VS_IDLE	0	/* VC is not used */
+#define ATM_VS_CONNECTED 1	/* VC is connected */
+#define ATM_VS_CLOSING	2	/* VC is closing */
+#define ATM_VS_LISTEN	3	/* VC is listening for incoming setups */
+#define ATM_VS_INUSE	4	/* VC is in use (registered with atmsigd) */
+#define ATM_VS_BOUND	5	/* VC is bound */
+
+#define ATM_VS2TXT_MAP \
+    "IDLE", "CONNECTED", "CLOSING", "LISTEN", "INUSE", "BOUND"
+
+#define ATM_VF2TXT_MAP \
+    "ADDR",	"READY",	"PARTIAL",	"REGIS", \
+    "RELEASED", "HASQOS",	"LISTEN",	"META", \
+    "256",	"512",		"1024",		"2048", \
+    "SESSION",	"HASSAP",	"BOUND",	"CLOSE"
+
+
+#ifdef __KERNEL__
+
+#include <linux/device.h>
+#include <linux/wait.h> /* wait_queue_head_t */
+#include <linux/time.h> /* struct timeval */
+#include <linux/net.h>
+#include <linux/skbuff.h> /* struct sk_buff */
+#include <linux/uio.h>
+#include <net/sock.h>
+#include <asm/atomic.h>
+
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+
+extern struct proc_dir_entry *atm_proc_root;
+#endif
+
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+struct compat_atm_iobuf {
+	int length;
+	compat_uptr_t buffer;
+};
+#endif
+
+struct k_atm_aal_stats {
+#define __HANDLE_ITEM(i) atomic_t i
+	__AAL_STAT_ITEMS
+#undef __HANDLE_ITEM
+};
+
+struct atm_iobuf {
+	int length;
+	void __user *buffer;
+};
+
+
+struct k_atm_dev_stats {
+	struct k_atm_aal_stats aal0;
+	struct k_atm_aal_stats aal34;
+	struct k_atm_aal_stats aal5;
+};
+
+
+enum {
+	ATM_VF_ADDR,		/* Address is in use. Set by anybody, cleared
+				   by device driver. */
+	ATM_VF_READY,		/* VC is ready to transfer data. Set by device
+				   driver, cleared by anybody. */
+	ATM_VF_PARTIAL,		/* resources are bound to PVC (partial PVC
+				   setup), controlled by socket layer */
+	ATM_VF_REGIS,		/* registered with demon, controlled by SVC
+				   socket layer */
+	ATM_VF_BOUND,		/* local SAP is set, controlled by SVC socket
+				   layer */
+	ATM_VF_RELEASED,	/* demon has indicated/requested release,
+				   controlled by SVC socket layer */
+	ATM_VF_HASQOS,		/* QOS parameters have been set */
+	ATM_VF_LISTEN,		/* socket is used for listening */
+	ATM_VF_META,		/* SVC socket isn't used for normal data
+				   traffic and doesn't depend on signaling
+				   to be available */
+	ATM_VF_SESSION,		/* VCC is p2mp session control descriptor */
+	ATM_VF_HASSAP,		/* SAP has been set */
+	ATM_VF_CLOSE,		/* asynchronous close - treat like VF_RELEASED*/
+	ATM_VF_WAITING,		/* waiting for reply from sigd */
+	ATM_VF_IS_CLIP,		/* in use by CLIP protocol */
+};
+
+
+#define ATM_VF2VS(flags) \
+    (test_bit(ATM_VF_READY,&(flags)) ? ATM_VS_CONNECTED : \
+     test_bit(ATM_VF_RELEASED,&(flags)) ? ATM_VS_CLOSING : \
+     test_bit(ATM_VF_LISTEN,&(flags)) ? ATM_VS_LISTEN : \
+     test_bit(ATM_VF_REGIS,&(flags)) ? ATM_VS_INUSE : \
+     test_bit(ATM_VF_BOUND,&(flags)) ? ATM_VS_BOUND : ATM_VS_IDLE)
+
+
+enum {
+	ATM_DF_REMOVED,		/* device was removed from atm_devs list */
+};
+
+
+#define ATM_PHY_SIG_LOST    0	/* no carrier/light */
+#define ATM_PHY_SIG_UNKNOWN 1	/* carrier/light status is unknown */
+#define ATM_PHY_SIG_FOUND   2	/* carrier/light okay */
+
+#define ATM_ATMOPT_CLP	1	/* set CLP bit */
+
+struct atm_vcc {
+	/* struct sock has to be the first member of atm_vcc */
+	struct sock	sk;
+	unsigned long	flags;		/* VCC flags (ATM_VF_*) */
+	short		vpi;		/* VPI and VCI (types must be equal */
+					/* with sockaddr) */
+	int 		vci;
+	unsigned long	aal_options;	/* AAL layer options */
+	unsigned long	atm_options;	/* ATM layer options */
+	struct atm_dev	*dev;		/* device back pointer */
+	struct atm_qos	qos;		/* QOS */
+	struct atm_sap	sap;		/* SAP */
+	void (*push)(struct atm_vcc *vcc,struct sk_buff *skb);
+	void (*pop)(struct atm_vcc *vcc,struct sk_buff *skb); /* optional */
+	int (*push_oam)(struct atm_vcc *vcc,void *cell);
+	int (*send)(struct atm_vcc *vcc,struct sk_buff *skb);
+	void		*dev_data;	/* per-device data */
+	void		*proto_data;	/* per-protocol data */
+	struct k_atm_aal_stats *stats;	/* pointer to AAL stats group */
+	/* SVC part --- may move later ------------------------------------- */
+	short		itf;		/* interface number */
+	struct sockaddr_atmsvc local;
+	struct sockaddr_atmsvc remote;
+	/* Multipoint part ------------------------------------------------- */
+	struct atm_vcc	*session;	/* session VCC descriptor */
+	/* Other stuff ----------------------------------------------------- */
+	void		*user_back;	/* user backlink - not touched by */
+					/* native ATM stack. Currently used */
+					/* by CLIP and sch_atm. */
+};
+
+static inline struct atm_vcc *atm_sk(struct sock *sk)
+{
+	return (struct atm_vcc *)sk;
+}
+
+static inline struct atm_vcc *ATM_SD(struct socket *sock)
+{
+	return atm_sk(sock->sk);
+}
+
+static inline struct sock *sk_atm(struct atm_vcc *vcc)
+{
+	return (struct sock *)vcc;
+}
+
+struct atm_dev_addr {
+	struct sockaddr_atmsvc addr;	/* ATM address */
+	struct list_head entry;		/* next address */
+};
+
+enum atm_addr_type_t { ATM_ADDR_LOCAL, ATM_ADDR_LECS };
+
+struct atm_dev {
+	const struct atmdev_ops *ops;	/* device operations; NULL if unused */
+	const struct atmphy_ops *phy;	/* PHY operations, may be undefined */
+					/* (NULL) */
+	const char	*type;		/* device type name */
+	int		number;		/* device index */
+	void		*dev_data;	/* per-device data */
+	void		*phy_data;	/* private PHY date */
+	unsigned long	flags;		/* device flags (ATM_DF_*) */
+	struct list_head local;		/* local ATM addresses */
+	struct list_head lecs;		/* LECS ATM addresses learned via ILMI */
+	unsigned char	esi[ESI_LEN];	/* ESI ("MAC" addr) */
+	struct atm_cirange ci_range;	/* VPI/VCI range */
+	struct k_atm_dev_stats stats;	/* statistics */
+	char		signal;		/* signal status (ATM_PHY_SIG_*) */
+	int		link_rate;	/* link rate (default: OC3) */
+	atomic_t	refcnt;		/* reference count */
+	spinlock_t	lock;		/* protect internal members */
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *proc_entry; /* proc entry */
+	char *proc_name;		/* proc entry name */
+#endif
+	struct device class_dev;	/* sysfs device */
+	struct list_head dev_list;	/* linkage */
+};
+
+ 
+/* OF: send_Oam Flags */
+
+#define ATM_OF_IMMED  1		/* Attempt immediate delivery */
+#define ATM_OF_INRATE 2		/* Attempt in-rate delivery */
+
+
+/*
+ * ioctl, getsockopt, and setsockopt are optional and can be set to NULL.
+ */
+
+struct atmdev_ops { /* only send is required */
+	void (*dev_close)(struct atm_dev *dev);
+	int (*open)(struct atm_vcc *vcc);
+	void (*close)(struct atm_vcc *vcc);
+	int (*ioctl)(struct atm_dev *dev,unsigned int cmd,void __user *arg);
+#ifdef CONFIG_COMPAT
+	int (*compat_ioctl)(struct atm_dev *dev,unsigned int cmd,
+			    void __user *arg);
+#endif
+	int (*getsockopt)(struct atm_vcc *vcc,int level,int optname,
+	    void __user *optval,int optlen);
+	int (*setsockopt)(struct atm_vcc *vcc,int level,int optname,
+	    void __user *optval,int optlen);
+	int (*send)(struct atm_vcc *vcc,struct sk_buff *skb);
+	int (*send_oam)(struct atm_vcc *vcc,void *cell,int flags);
+	void (*phy_put)(struct atm_dev *dev,unsigned char value,
+	    unsigned long addr);
+	unsigned char (*phy_get)(struct atm_dev *dev,unsigned long addr);
+	int (*change_qos)(struct atm_vcc *vcc,struct atm_qos *qos,int flags);
+	int (*proc_read)(struct atm_dev *dev,loff_t *pos,char *page);
+	struct module *owner;
+};
+
+struct atmphy_ops {
+	int (*start)(struct atm_dev *dev);
+	int (*ioctl)(struct atm_dev *dev,unsigned int cmd,void __user *arg);
+	void (*interrupt)(struct atm_dev *dev);
+	int (*stop)(struct atm_dev *dev);
+};
+
+struct atm_skb_data {
+	struct atm_vcc	*vcc;		/* ATM VCC */
+	unsigned long	atm_options;	/* ATM layer options */
+};
+
+#define VCC_HTABLE_SIZE 32
+
+extern struct hlist_head vcc_hash[VCC_HTABLE_SIZE];
+extern rwlock_t vcc_sklist_lock;
+
+#define ATM_SKB(skb) (((struct atm_skb_data *) (skb)->cb))
+
+struct atm_dev *atm_dev_register(const char *type,const struct atmdev_ops *ops,
+    int number,unsigned long *flags); /* number == -1: pick first available */
+struct atm_dev *atm_dev_lookup(int number);
+void atm_dev_deregister(struct atm_dev *dev);
+void vcc_insert_socket(struct sock *sk);
+
+
+/*
+ * This is approximately the algorithm used by alloc_skb.
+ *
+ */
+
+static inline int atm_guess_pdu2truesize(int size)
+{
+	return (SKB_DATA_ALIGN(size) + sizeof(struct skb_shared_info));
+}
+
+
+static inline void atm_force_charge(struct atm_vcc *vcc,int truesize)
+{
+	atomic_add(truesize, &sk_atm(vcc)->sk_rmem_alloc);
+}
+
+
+static inline void atm_return(struct atm_vcc *vcc,int truesize)
+{
+	atomic_sub(truesize, &sk_atm(vcc)->sk_rmem_alloc);
+}
+
+
+static inline int atm_may_send(struct atm_vcc *vcc,unsigned int size)
+{
+	return (size + atomic_read(&sk_atm(vcc)->sk_wmem_alloc)) <
+	       sk_atm(vcc)->sk_sndbuf;
+}
+
+
+static inline void atm_dev_hold(struct atm_dev *dev)
+{
+	atomic_inc(&dev->refcnt);
+}
+
+
+static inline void atm_dev_put(struct atm_dev *dev)
+{
+	if (atomic_dec_and_test(&dev->refcnt)) {
+		BUG_ON(!test_bit(ATM_DF_REMOVED, &dev->flags));
+		if (dev->ops->dev_close)
+			dev->ops->dev_close(dev);
+		put_device(&dev->class_dev);
+	}
+}
+
+
+int atm_charge(struct atm_vcc *vcc,int truesize);
+struct sk_buff *atm_alloc_charge(struct atm_vcc *vcc,int pdu_size,
+    gfp_t gfp_flags);
+int atm_pcr_goal(const struct atm_trafprm *tp);
+
+void vcc_release_async(struct atm_vcc *vcc, int reply);
+
+struct atm_ioctl {
+	struct module *owner;
+	/* A module reference is kept if appropriate over this call.
+	 * Return -ENOIOCTLCMD if you don't handle it. */
+	int (*ioctl)(struct socket *, unsigned int cmd, unsigned long arg);
+	struct list_head list;
+};
+
+/**
+ * register_atm_ioctl - register handler for ioctl operations
+ *
+ * Special (non-device) handlers of ioctl's should
+ * register here. If you're a normal device, you should
+ * set .ioctl in your atmdev_ops instead.
+ */
+void register_atm_ioctl(struct atm_ioctl *);
+
+/**
+ * deregister_atm_ioctl - remove the ioctl handler
+ */
+void deregister_atm_ioctl(struct atm_ioctl *);
+
+#endif /* __KERNEL__ */
+
+#endif
--- work/ppp-2.4.9/pppd/plugins/pppoatm/atmrt2684.h	1970-01-01 01:00:00.000000000 +0100
+++ work/ppp-2.4.9/pppd/plugins/pppoatm/atmrt2684.h	2021-12-16 16:38:08.000000000 +0100
@@ -0,0 +1,48 @@
+#ifndef _LINUX_ATMRT2684_H
+#define _LINUX_ATMRT2684_H
+
+#include <linux/atm.h>
+#include <linux/if.h>		/* For IFNAMSIZ */
+
+#define RT2684_ENCAPS_NULL	(0)	/* VC-mux */
+#define RT2684_ENCAPS_LLC	(1)
+#define RT2684_ENCAPS_AUTODETECT (2)	/* Unsuported */
+
+/*
+ * This is for the ATM_NEWBACKENDIF call - these are like socket families:
+ * the first element of the structure is the backend number and the rest
+ * is per-backend specific
+ */
+struct atm_newif_rt2684 {
+	atm_backend_t	backend_num;	/* ATM_BACKEND_RT2684 */
+	char		ifname[IFNAMSIZ];
+};
+
+/*
+ * This structure is used to specify a rt2684 interface - either by a
+ * positive integer (returned by ATM_NEWBACKENDIF) or the interfaces name
+ */
+#define RT2684_FIND_BYNOTHING	(0)
+#define RT2684_FIND_BYNUM	(1)
+#define RT2684_FIND_BYIFNAME	(2)
+struct rt2684_if_spec {
+	int method;			/* RT2684_FIND_* */
+	union {
+		char		ifname[IFNAMSIZ];
+		int		devnum;
+	} spec;
+};
+
+/*
+ * This is for the ATM_SETBACKEND call - these are like socket families:
+ * the first element of the structure is the backend number and the rest
+ * is per-backend specific
+ */
+struct atm_backend_rt2684 {
+	atm_backend_t	backend_num;	/* ATM_BACKEND_RT2684 */
+	struct rt2684_if_spec ifspec;
+	unsigned char	encaps;		/* RT2684_ENCAPS_* */
+};
+
+
+#endif /* _LINUX_ATMRT2684_H */
--- work/ppp-2.4.9/pppd/plugins/pppoatm/pppoatm.c	2021-01-05 00:06:37.000000000 +0100
+++ work/ppp-2.4.9/pppd/plugins/pppoatm/pppoatm.c	2022-03-10 17:40:50.379802000 +0100
@@ -20,8 +20,8 @@
 #include "pathnames.h"
 #include "fsm.h" /* Needed for lcp.h to include cleanly */
 #include "lcp.h"
-#include <atm.h>
-#include <linux/atmdev.h>
+#include "atm.h"
+#include "atmdev.h"
 #include <linux/atmppp.h>
 #include <sys/stat.h>
 #include <net/if.h>
@@ -37,8 +37,9 @@ static int device_got_set = 0;
 static int pppoatm_max_mtu, pppoatm_max_mru;
 static int setdevname_pppoatm(const char *cp, const char **argv, int doit);
 struct channel pppoa_channel;
-static int pppoa_fd = -1;
+static int fd_pppoa = -1;
 
+static void set_line_discipline_pppoatm(int fd);
 static option_t pppoa_options[] = {
 	{ "device name", o_wild, (void *) &setdevname_pppoatm,
 	  "ATM service provider IDs: VPI.VCI",
@@ -69,7 +70,6 @@ int (*old_setdevname_hook)(const char* c
 static int setdevname_pppoatm(const char *cp, const char **argv, int doit)
 {
 	struct sockaddr_atmpvc addr;
-	extern struct stat devstat;
 
 	if (device_got_set)
 		return 0;
@@ -77,6 +77,7 @@ static int setdevname_pppoatm(const char
 	memset(&addr, 0, sizeof addr);
 	if (text2atm(cp, (struct sockaddr *) &addr, sizeof(addr),
 	    T2A_PVC | T2A_NAME | T2A_WILDCARD) < 0) {
+		info("text2atm return error");
 		if (doit)
 			info("cannot parse the ATM address: %s", cp);
 		return 0;
@@ -86,7 +87,6 @@ static int setdevname_pppoatm(const char
 
 	memcpy(&pvcaddr, &addr, sizeof pvcaddr);
 	strlcpy(devnam, cp, sizeof devnam);
-	devstat.st_mode = S_IFSOCK;
 	if (the_channel != &pppoa_channel) {
 		the_channel = &pppoa_channel;
 		lcp_wantoptions[0].neg_accompression = 0;
@@ -110,7 +110,7 @@ static void set_line_discipline_pppoatm(
 {
 	struct atm_backend_ppp be;
 
-	be.backend_num = ATM_BACKEND_PPP;
+	be.backend_num = ATM_BACKEND_PPP_BCM;
 	if (!llc_encaps)
 		be.encaps = PPPOATM_ENCAPS_VC;
 	else if (!vc_encaps)
@@ -122,16 +122,7 @@ static void set_line_discipline_pppoatm(
 		fatal("ioctl(ATM_SETBACKEND): %m");
 }
 
-#if 0
-static void reset_line_discipline_pppoatm(int fd)
-{
-	atm_backend_t be = ATM_BACKEND_RAW;
-	/* 2.4 doesn't support this yet */
-	(void) ioctl(fd, ATM_SETBACKEND, &be);
-}
-#endif
-
-static int connect_pppoatm(void)
+static int open_device_pppoatm(void)
 {
 	int fd;
 	struct atm_qos qos;
@@ -141,6 +132,8 @@ static int connect_pppoatm(void)
 	fd = socket(AF_ATMPVC, SOCK_DGRAM, 0);
 	if (fd < 0)
 		fatal("failed to create socket: %m");
+	// brcm
+	fd_pppoa = fd;
 	memset(&qos, 0, sizeof qos);
 	qos.txtp.traffic_class = qos.rxtp.traffic_class = ATM_UBR;
 	/* TODO: support simplified QoS setting */
@@ -159,17 +152,23 @@ static int connect_pppoatm(void)
 	pppoatm_max_mtu = lcp_allowoptions[0].mru;
 	pppoatm_max_mru = lcp_wantoptions[0].mru;
 	set_line_discipline_pppoatm(fd);
-	strlcpy(ppp_devnam, devnam, sizeof(ppp_devnam));
-	pppoa_fd = fd;
 	return fd;
 }
-
-static void disconnect_pppoatm(void)
+// brcm begin
+static void close_device_pppoatm(void)
 {
-	close(pppoa_fd);
+   if (fd_pppoa > 0) {
+      struct atm_backend_ppp be;
+      be.backend_num = ATM_BACKEND_PPP_BCM_CLOSE_DEV;
+      if (ioctl(fd_pppoa, ATM_SETBACKEND, &be) < 0)
+         fatal("ioctl(ATM_SETBACKEND): %m");
+      close(fd_pppoa);
+      fd_pppoa= -1;
+   }
 }
+// brcm end
 
-void plugin_init(void)
+void pppoatm_plugin_init(void)
 {
 #ifdef linux
 	extern int new_style_driver;	/* From sys-linux.c */
@@ -186,12 +185,13 @@ struct channel pppoa_channel = {
     options: pppoa_options,
     process_extra_options: NULL,
     check_options: NULL,
-    connect: &connect_pppoatm,
-    disconnect: &disconnect_pppoatm,
+    connect: &open_device_pppoatm,
+    disconnect: &close_device_pppoatm,
     establish_ppp: &generic_establish_ppp,
     disestablish_ppp: &generic_disestablish_ppp,
     send_config: NULL,
     recv_config: NULL,
+    set_line_discipline_hook:NULL,
     close: NULL,
     cleanup: NULL
 };
--- work/ppp-2.4.9/pppd/plugins/pppoe/libpppoe.c	1970-01-01 01:00:00.000000000 +0100
+++ work/ppp-2.4.9/pppd/plugins/pppoe/libpppoe.c	2021-12-16 16:38:08.000000000 +0100
@@ -0,0 +1,720 @@
+/* PPPoE support library "libpppoe"
+ *
+ * Copyright 2000 Michal Ostrowski <mostrows@styx.uwaterloo.ca>,
+ *		  Jamal Hadi Salim <hadi@cyberus.ca>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ */
+
+#include "pppoe.h"
+#include "link.h"
+
+
+int disc_sock=-1;
+
+int verify_packet( struct session *ses, struct pppoe_packet *p);
+
+#define TAG_DATA(type,tag_ptr) ((type *) ((struct pppoe_tag*)tag_ptr)->tag_data)
+
+
+/***************************************************************************
+ *
+ * Return the location where the next tag can be pu
+ *
+ **************************************************************************/
+static  struct pppoe_tag *next_tag(struct pppoe_hdr *ph)
+{
+    return (struct pppoe_tag *)
+	(((char *) &ph->tag) + ntohs(ph->length));
+}
+
+/**************************************************************************
+ *
+ * Update header to reflect the addition of a new tag
+ *
+ **************************************************************************/
+static  void add_tag(struct pppoe_hdr *ph, struct pppoe_tag *pt)
+{
+    int len = (ntohs(ph->length) +
+	       ntohs(pt->tag_len) +
+	       sizeof(struct pppoe_tag));
+
+    if (pt != next_tag(ph))
+	printf("PPPoE add_tag caller is buggy\n");
+
+    ph->length = htons(len);
+}
+
+/*************************************************************************
+ *
+ * Look for a tag of a specific type
+ *
+ ************************************************************************/
+struct pppoe_tag *get_tag(struct pppoe_hdr *ph, u_int16_t idx)
+{
+    char *end = (char *) next_tag(ph);
+    char *ptn = NULL;
+    struct pppoe_tag *pt = &ph->tag[0];
+
+    /*
+     * Keep processing tags while a tag header will still fit.
+     *
+     * This check will ensure that the entire tag header pointed
+     * to by pt will fit inside the message, and thus it will be
+     * valid to check the tag_type and tag_len fields.
+     */
+    while ((char *)(pt + 1) <= end) {
+	/*
+	 * If the tag data would go past the end of the packet, abort.
+	 */
+	ptn = (((char *) (pt + 1)) + ntohs(pt->tag_len));
+	if (ptn > end)
+	    return NULL;
+
+	if (pt->tag_type == idx)
+	    return pt;
+
+	pt = (struct pppoe_tag *) ptn;
+    }
+
+    return NULL;
+}
+
+static int tag_map[] = { PTT_SRV_NAME,
+			 PTT_AC_NAME,
+			 PTT_HOST_UNIQ,
+			 PTT_AC_COOKIE,
+			 PTT_VENDOR,
+			 PTT_RELAY_SID,
+			 PTT_SRV_ERR,
+			 PTT_SYS_ERR,
+			 PTT_GEN_ERR,
+			 PTT_EOL
+};
+
+/* We want to use tag names to reference into arrays  containing the tag data.
+   This takes an RFC 2516 tag identifier and maps it into a local one.
+   The reverse mapping is accomplished via the tag_map array */
+#define UNMAP_TAG(x) case PTT_##x : return TAG_##x
+static inline int tag_index(int tag){
+    switch(tag){
+	UNMAP_TAG(SRV_NAME);
+	UNMAP_TAG(AC_NAME);
+	UNMAP_TAG(HOST_UNIQ);
+	UNMAP_TAG(AC_COOKIE);
+	UNMAP_TAG(VENDOR);
+	UNMAP_TAG(RELAY_SID);
+	UNMAP_TAG(SRV_ERR);
+	UNMAP_TAG(SYS_ERR);
+	UNMAP_TAG(GEN_ERR);
+	UNMAP_TAG(EOL);
+    };
+    return -1;
+}
+
+/*************************************************************************
+ *
+ * Makes a copy of a tag into a PPPoE packe
+ *
+ ************************************************************************/
+void copy_tag(struct pppoe_packet *dest, struct pppoe_tag *pt)
+{
+    struct pppoe_tag *end_tag = get_tag(dest->hdr, PTT_EOL);
+    int tagid;
+    int tag_len;
+    if( !pt ) {
+	return;
+    }
+    tagid = tag_index(pt->tag_type);
+
+    tag_len = sizeof(struct pppoe_tag) + ntohs(pt->tag_len);
+
+    if( end_tag ){
+	memcpy(((char*)end_tag)+tag_len ,
+	       end_tag, sizeof(struct pppoe_tag));
+
+	dest->tags[tagid]=end_tag;
+	dest->tags[TAG_EOL] = (struct pppoe_tag*)((char*)dest->tags[TAG_EOL] + tag_len);
+	memcpy(end_tag, pt, tag_len);
+	dest->hdr->length = htons(ntohs(dest->hdr->length) + tag_len);
+
+    }else{
+	memcpy(next_tag(dest->hdr),pt, tag_len);
+	dest->tags[tagid]=next_tag(dest->hdr);
+	add_tag(dest->hdr,next_tag(dest->hdr));
+    }
+
+
+}
+
+
+/*************************************************************************
+ *
+ * Put tags from a packet into a nice array
+ *
+ ************************************************************************/
+static void extract_tags(struct pppoe_hdr *ph, struct pppoe_tag** buf){
+    int i=0;
+    for(;i<MAX_TAGS;++i){
+	buf[i] = get_tag(ph,tag_map[i]);
+    }
+}
+
+
+/*************************************************************************
+ *
+ * Verify that a packet has a tag containint a specific value
+ *
+ ************************************************************************/
+static int verify_tag(struct session* ses,
+		      struct pppoe_packet* p,
+		      unsigned short id,
+		      char* data,
+		      int data_len)
+{
+    int len;
+    struct pppoe_tag *pt = p->tags[id];
+
+    if( !pt ){
+	poe_info(ses,"Missing tag %d. Expected %s\n",
+		 id,data);
+	return 0;
+    }
+    len = ntohs(pt->tag_len);
+    if(len != data_len){
+	poe_info(ses,"Length mismatch on tag %d: expect: %d got: %d\n",
+		 id, data_len, len);
+	return 0;
+    }
+
+    if( 0!=memcmp(pt->tag_data,data,data_len)){
+	poe_info(ses,"Tag data mismatch on tag %d: expect: %s vs %s\n",
+		 id, data,pt->tag_data);
+	return 0;
+    }
+    return 1;
+}
+
+
+/*************************************************************************
+ *
+ * Verify the existence of an ethernet device.
+ * Construct an AF_PACKET address struct to match.
+ *
+ ************************************************************************/
+int get_sockaddr_ll(const char *devnam,struct sockaddr_ll* sll){
+    struct ifreq ifr;
+    int retval;
+
+    if(disc_sock<0){
+
+	disc_sock = socket(PF_PACKET, SOCK_DGRAM, 0);
+	if( disc_sock < 0 ){
+	    return -1;
+	}
+    }
+
+    strncpy(ifr.ifr_name, devnam, sizeof(ifr.ifr_name));
+
+    retval = ioctl( disc_sock , SIOCGIFINDEX, &ifr);
+
+    if( retval < 0 ){
+//	error("Bad device name: %s  (%m)",devnam);
+	return 0;
+    }
+
+    if(sll) sll->sll_ifindex = ifr.ifr_ifindex;
+
+    retval = ioctl (disc_sock, SIOCGIFHWADDR, &ifr);
+    if( retval < 0 ){
+//	error("Bad device name: %s  (%m)",devnam);
+	return 0;
+    }
+
+    if (ifr.ifr_hwaddr.sa_family != ARPHRD_ETHER) {
+	error("Interface %s is not Ethernet!", devnam);
+	return 0;
+    }
+    if(sll){
+	sll->sll_family	= AF_PACKET;
+	sll->sll_protocol= ntohs(ETH_P_PPP_DISC);
+	sll->sll_hatype	= ARPHRD_ETHER;
+	sll->sll_pkttype = PACKET_BROADCAST;
+	sll->sll_hatype	= ETH_ALEN;
+	memcpy( sll->sll_addr , ifr.ifr_hwaddr.sa_data, ETH_ALEN);
+    }
+    return 1;
+}
+
+#ifdef _RECORD_SID_
+/*************************************************************************
+ *
+ * Construct and send a init PADT message.
+ *
+ ************************************************************************/
+int send_padt(struct session *ses, struct pppoe_packet *p)
+{
+    char buf[60];   /* 60 bytes is enough */
+    struct pppoe_hdr *ph=(struct pppoe_hdr *)buf;
+    struct pppoe_tag *tag;
+    struct sockaddr_ll addr;
+    int error = 0;
+    char *sid = nvram_get(PPPOE_SID);
+    char *srv = nvram_get(PPPOE_SRV_ADDR);
+
+    memset(buf, 0, sizeof(buf));
+    /*
+     * Generate PADT buffer
+     */
+    ph->ver  = 1;
+    ph->type = 1;
+    ph->code = PADT_CODE;
+    /* Set SID as the recorded value */
+    if(sid) {
+        ph->sid = atoi(sid);
+    }
+    ph->length = __constant_htons(0);
+
+    /* Add Generic Error tag */
+	tag = next_tag(ph);
+	tag->tag_type = PTT_GEN_ERR;
+	tag->tag_len = __constant_htons(0);;
+	add_tag(ph, tag);
+
+    /*
+     * Generate addr
+     */
+    memcpy(&addr, &ses->remote, sizeof(addr));
+    if(srv) {
+        sscanf(srv, "%02hhX:%02hhX:%02hhX:%02hhX:%02hhX:%02hhX",
+        /*
+         * NOTE!!!
+         * Never use sscanf %X with char *!
+         * Sscanf will put int value to your point, this will overwrite your stack!
+         *
+         *   sscanf(srv, "%02X:%02X:%02X:%02X:%02X:%02X",
+         *                                                  Argon Cheng
+         */
+            &addr.sll_addr[0],
+            &addr.sll_addr[1],
+            &addr.sll_addr[2],
+            &addr.sll_addr[3],
+            &addr.sll_addr[4],
+            &addr.sll_addr[5]);
+    }
+
+    /*
+     * Send it
+     */
+    error = sendto(disc_sock, buf, sizeof(buf), 0,
+		   (struct sockaddr*) &addr,
+		   sizeof(struct sockaddr_ll));
+
+    if(error < 0) {
+	    poe_error(ses,"sendto returned: %m\n");
+    }
+    sleep(3);   /* Follow WNR2000v3, sleep a while after PADT send */
+    return error;
+}
+#endif
+
+/*************************************************************************
+ *
+ * Construct and send a discovery message.
+ *
+ ************************************************************************/
+int send_disc(struct session *ses, struct pppoe_packet *p)
+{
+    char buf[MAX_PAYLOAD + sizeof(struct pppoe_hdr)];
+    int data_len = sizeof(struct pppoe_hdr);
+
+    struct pppoe_hdr *ph = NULL;
+    struct pppoe_tag *tag = NULL;
+    int i, error = 0;
+    int got_host_uniq = 0;
+    int got_srv_name = 0;
+    int got_ac_name = 0;
+
+    for (i = 0; i < MAX_TAGS; i++) {
+	if (!p->tags[i])
+	    continue;
+
+	got_host_uniq |= (p->tags[i]->tag_type == PTT_HOST_UNIQ);
+
+	/* Relay identifiers qualify as HOST_UNIQ's:
+	   we need HOST_UNIQ to uniquely identify the packet,
+	   PTT_RELAY_SID is sufficient for us for outgoing packets */
+	got_host_uniq |= (p->tags[i]->tag_type == PTT_RELAY_SID);
+
+	got_srv_name |= (p->tags[i]->tag_type == PTT_SRV_NAME);
+	got_ac_name  |= (p->tags[i]->tag_type == PTT_AC_NAME);
+
+	data_len += (ntohs(p->tags[i]->tag_len) +
+		     sizeof(struct pppoe_tag));
+    }
+
+    ph = (struct pppoe_hdr *) buf;
+
+
+    memcpy(ph, p->hdr, sizeof(struct pppoe_hdr));
+    ph->length = __constant_htons(0);
+
+    /* if no HOST_UNIQ tags --- add one with process id */
+    if (!got_host_uniq){
+	data_len += (sizeof(struct pppoe_tag) +
+		     sizeof(struct session *));
+	tag = next_tag(ph);
+	tag->tag_type = PTT_HOST_UNIQ;
+	tag->tag_len = htons(sizeof(struct session *));
+	memcpy(tag->tag_data,
+	       &ses,
+	       sizeof(struct session *));
+
+	add_tag(ph, tag);
+    }
+
+    if( !got_srv_name ){
+	data_len += sizeof(struct pppoe_tag);
+	tag = next_tag(ph);
+	tag->tag_type = PTT_SRV_NAME;
+	tag->tag_len = 0;
+	add_tag(ph, tag);
+    }
+
+    if(!got_ac_name && ph->code==PADO_CODE){
+	data_len += sizeof(struct pppoe_tag);
+	tag = next_tag(ph);
+	tag->tag_type = PTT_AC_NAME;
+	tag->tag_len = 0;
+	add_tag(ph, tag);
+    }
+
+    for (i = 0; i < MAX_TAGS; i++) {
+	if (!p->tags[i])
+	    continue;
+
+	tag = next_tag(ph);
+	memcpy(tag, p->tags[i],
+	       sizeof(struct pppoe_tag) + ntohs(p->tags[i]->tag_len));
+
+	add_tag(ph, tag);
+    }
+
+    /* Now fixup the packet struct to make sure all of its pointers
+       are self-contained */
+    memcpy( p->hdr , ph, data_len );
+    extract_tags( p->hdr, p->tags);
+
+    error = sendto(disc_sock, buf, data_len, 0,
+		   (struct sockaddr*) &p->addr,
+		   sizeof(struct sockaddr_ll));
+
+    if(error < 0)
+	poe_error(ses,"sendto returned: %m\n");
+
+    return error;
+}
+
+/*************************************************************************
+ *
+ * Verify that a packet is legal
+ *
+ *************************************************************************/
+int verify_packet( struct session *ses, struct pppoe_packet *p){
+    struct session * hu_val;
+
+    /* This code here should do all of the error checking and
+       validation on the incoming packet */
+
+
+    /* If we receive any error tags, abort */
+#define CHECK_TAG(name, val)					\
+    if((NULL==p->tags[name])== val){				\
+	poe_error(ses,"Tag error: " #name );			\
+	return -1;						\
+    }
+
+
+
+    CHECK_TAG(TAG_SRV_ERR,0);
+    CHECK_TAG(TAG_SYS_ERR,0);
+    CHECK_TAG(TAG_GEN_ERR,0);
+
+    /* A HOST_UNIQ must be present */
+    CHECK_TAG(TAG_HOST_UNIQ,1);
+
+    hu_val = *TAG_DATA(struct session* ,p->tags[TAG_HOST_UNIQ]);
+
+    if( hu_val != ses ){
+	poe_info(ses,"HOST_UNIQ mismatch: %08x %i\n",(int)hu_val,getpid());
+	return -1;
+    }
+
+    if(ses->filt->htag &&
+       !verify_tag(ses,p,TAG_HOST_UNIQ,ses->filt->htag->tag_data,(int)ntohs(ses->filt->htag->tag_len)))
+	return -1;
+    else
+	poe_info(ses,"HOST_UNIQ successful match\n");
+
+
+    if(ses->filt->ntag &&
+       !verify_tag(ses,p,TAG_AC_NAME,ses->filt->ntag->tag_data,(int)ntohs(ses->filt->ntag->tag_len))){
+	poe_info(ses,"AC_NAME failure");
+	return -1;
+    }
+
+    if(ses->filt->stag &&
+       !verify_tag(ses,p,TAG_SRV_NAME,ses->filt->stag->tag_data,(int)ntohs(ses->filt->stag->tag_len))){
+	poe_info(ses,"SRV_NAME failure");
+	return -1;
+    }
+    return 0;
+}
+
+
+/*************************************************************************
+ *
+ * Receive and verify an incoming packet.
+ *
+ *************************************************************************/
+static int recv_disc( struct session *ses,
+		      struct pppoe_packet *p){
+    int error = 0;
+    unsigned int from_len = sizeof(struct sockaddr_ll);
+
+    p->hdr = (struct pppoe_hdr*)p->buf;
+
+    error = recvfrom( disc_sock, p->buf, 1500, 0,
+		      (struct sockaddr*)&p->addr, &from_len);
+
+    if(error < 0) return error;
+
+    extract_tags(p->hdr,p->tags);
+
+    return 1;
+}
+
+
+/*************************************************************************
+ *
+ * Send a PADT
+ *
+ *************************************************************************/
+int session_disconnect(struct session *ses){
+    struct pppoe_packet padt;
+
+    memset(&padt,0,sizeof(struct pppoe_packet));
+    memcpy(&padt.addr, &ses->remote, sizeof(struct sockaddr_ll));
+
+    padt.hdr = (struct pppoe_hdr*) ses->curr_pkt.buf;
+    padt.hdr->ver  = 1;
+    padt.hdr->type = 1;
+    padt.hdr->code = PADT_CODE;
+    padt.hdr->sid  = ses->sp.sa_addr.pppoe.sid;
+
+    send_disc(ses,&padt);
+    ses->sp.sa_addr.pppoe.sid = 0 ;
+    ses->state = PADO_CODE;
+    return 0;
+
+}
+
+
+/*************************************************************************
+ *
+ * Make a connection -- behaviour depends on callbacks specified in "ses"
+ *
+ *************************************************************************/
+int session_connect(struct session *ses)
+{
+    struct pppoe_packet *p_out=NULL;
+    struct pppoe_packet rcv_packet;
+    int ret;
+
+
+    if(ses->init_disc){
+	ret = (*ses->init_disc)(ses, NULL, &p_out);
+	if( ret != 0 ) return ret;
+    }
+
+    /* main discovery loop */
+
+	struct port_link_status_s *wan_status;
+    char flag = 0;
+    while(ses->retransmits < ses->retries || ses->retries==-1 ){
+    fd_set in;
+	struct timeval tv;
+	FD_ZERO(&in);
+
+	FD_SET(disc_sock,&in);
+
+	if(ses->retransmits>=0){
+//	    ++ses->retransmits;
+        wan_status = get_wan_port_link_status(); 
+        if(wan_status->link == LINK_UP) {
+            if (flag)
+                ses->retransmits = 0;
+            tv.tv_sec = 1 << ses->retransmits;
+        }
+        else{
+            tv.tv_sec = 5;
+            flag = 1;
+        }
+	    tv.tv_usec = 0;
+	    ret = select(disc_sock+1, &in, NULL, NULL, &tv);
+	}else{
+	    ret = select(disc_sock+1, &in, NULL, NULL, NULL);
+	}
+
+	/*SJ modify here,select() may interupt by singal,it is a normal case,it return -1 
+	  with errno EINTR.We can't treat it as a fatal error and finish cycle,
+	  we should continue and select again*/ 
+	if( ret == 0 || (ret < 0 && errno == EINTR)){
+	    if( DEB_DISC ){
+		poe_dbglog(ses, "Re-sending ...");
+	    }
+
+	    if( ses->timeout ){
+		ret = (*ses->timeout)(ses, NULL, &p_out);
+		if( ret != 0 )
+		    return ret;
+
+	    }else if(p_out){
+		++ses->retransmits;
+		send_disc(ses,p_out);
+	    }
+	    continue;
+	}
+
+	ret = recv_disc(ses, &rcv_packet);
+
+	/* Should differentiate between system errors and
+	   bad packets and the like... */
+	if( ret < 0 && errno != EINTR){
+
+	    return -1;
+	}
+
+
+
+
+	switch (rcv_packet.hdr->code) {
+
+	case PADI_CODE:
+	{
+	    if(ses->rcv_padi){
+		ret = (*ses->rcv_padi)(ses,&rcv_packet,&p_out);
+
+		if( ret != 0){
+		    return ret;
+		}
+	    }
+	    break;
+	}
+
+	case PADO_CODE:		/* wait for PADO */
+	{
+	    if(ses->rcv_pado){
+		ret = (*ses->rcv_pado)(ses,&rcv_packet,&p_out);
+
+		if( ret != 0){
+		    return ret;
+		}
+	    }
+	    break;
+	}
+
+	case PADR_CODE:
+	{
+	    if(ses->rcv_padr){
+		ret = (*ses->rcv_padr)(ses,&rcv_packet,&p_out);
+
+		if( ret != 0){
+		    return ret;
+		}
+	    }
+	    break;
+	}
+
+	case PADS_CODE:
+	{
+	    if(ses->rcv_pads){
+		ret = (*ses->rcv_pads)(ses,&rcv_packet,&p_out);
+
+		if( ret != 0){
+		    return ret;
+		}
+	    }
+	    break;
+	}
+
+	case PADT_CODE:
+	{
+	    if( rcv_packet.hdr->sid != ses->sp.sa_addr.pppoe.sid ){
+		--ses->retransmits;
+		continue;
+	    }
+	    if(ses->rcv_padt){
+		ret = (*ses->rcv_padt)(ses,&rcv_packet,&p_out);
+
+		if( ret != 0){
+		    return ret;
+		}
+	    }else{
+		poe_error (ses,"connection terminated");
+		return (-1);
+	    }
+	    break;
+	}
+	default:
+	    poe_error(ses,"invalid packet %P",&rcv_packet);
+	    return (-1);
+	}
+    }
+    return (0);
+}
+
+
+/*************************************************************************
+ *
+ * Register an ethernet address as a client of relaying services.
+ *
+ *************************************************************************/
+int add_client(char *addr)
+{
+    struct pppoe_con* pc = (struct pppoe_con*)malloc(sizeof(struct pppoe_con));
+    int ret;
+    if(!pc)
+	return -ENOMEM;
+
+    memset(pc, 0 , sizeof(struct pppoe_con));
+
+    memcpy(pc->client,addr, ETH_ALEN);
+    memcpy(pc->key, addr, ETH_ALEN);
+
+    pc->key_len = ETH_ALEN;
+
+    if( (ret=store_con(pc)) < 0 ){
+	free(pc);
+    }
+    return ret;
+
+}
+
+struct pppoe_tag *make_filter_tag(short type, short length, char* data){
+    struct pppoe_tag *pt =
+	(struct pppoe_tag* )malloc( sizeof(struct pppoe_tag) + length );
+
+    if(pt == NULL) return NULL;
+
+    pt->tag_len=htons(length);
+    pt->tag_type=type;
+
+    if(length>0 && data){
+	memcpy( pt+1, data, length);
+    }
+    return pt;
+}
--- work/ppp-2.4.9/pppd/plugins/pppoe/pppd_utils.c	1970-01-01 01:00:00.000000000 +0100
+++ work/ppp-2.4.9/pppd/plugins/pppoe/pppd_utils.c	2021-12-16 16:38:08.000000000 +0100
@@ -0,0 +1,162 @@
+/* PPPoE support library "libpppoe"
+ *
+ * Copyright 2000 Michal Ostrowski <mostrows@styx.uwaterloo.ca>,
+ *		  Jamal Hadi Salim <hadi@cyberus.ca>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ */
+#include "pppoe.h"
+
+/*
+ *
+ */
+int build_ppp_opts(char *args[],struct session *ses)
+{
+    char buf[256];
+    int retval=0,i=0;
+    
+    memset(buf,0,256);
+    
+/* pppds path */
+    if ( NULL != ses->filt->pppd){
+	args[0]=(char *)malloc(strlen(ses->filt->pppd));
+        strcpy (args[0],ses->filt->pppd);
+    } else {
+	args[0]=(char *)malloc(strlen(_PATH_PPPD));
+        strcpy (args[0],_PATH_PPPD);
+    }
+    
+/*  long device name */
+    snprintf(buf, 256,"%02x:%02x:%02x:%02x:%02x:%02x/%04x/%s",
+	     ses->remote.sll_addr[0],
+	     ses->remote.sll_addr[1],
+	     ses->remote.sll_addr[2],
+	     ses->remote.sll_addr[3],
+	     ses->remote.sll_addr[4],
+	     ses->remote.sll_addr[5],
+	     ses->sp.sa_addr.pppoe.sid,
+	     ses->name);
+    args[1]=(char *)malloc(strlen(buf));
+    strcpy(args[1],buf);
+    
+    i=2;
+    
+/* override options file */
+    if (NULL != ses->filt->fname ) {
+	
+	if (!ses->filt->peermode) {
+	    args[i]=(char *)malloc(strlen("file"));
+	    strcpy (args[i],"file");
+	    i++;
+	    args[i]=(char *)malloc(strlen(ses->filt->fname)+1);
+	    strcpy (args[i],ses->filt->fname);
+	    i++;
+	} else{ /* peermode */
+	    args[i]=(char *)malloc(strlen("call"));
+	    strcpy (args[i],"call");
+	    i++;
+	    args[i]=(char *)malloc(strlen(ses->filt->fname)+1);
+	    strcpy (args[i],ses->filt->fname);
+	    i++;
+	}
+    }
+    
+/* user requested for a specific name */
+    if (NULL != ses->filt->ntag) {
+	if ( NULL != ses->filt->ntag->tag_data) {
+	    args[i]=(char *)malloc(strlen("pppoe_ac_name"));
+	    strcpy(args[i],"pppoe_ac_name");
+	    i++;
+	    args[i]=(char *)malloc(ntohs(ses->filt->ntag->tag_len));
+	    strcpy(args[i],ses->filt->ntag->tag_data);
+	    i++;
+	}
+    }
+/* user requested for a specific service name */
+    if (NULL != ses->filt->stag) {
+	if ( NULL != ses->filt->stag->tag_data) {
+	    args[i]=(char *)malloc(strlen("pppoe_srv_name"));
+	    strcpy(args[i],"pppoe_srv_name");
+	    i++;
+	    args[i]=(char *)malloc(ntohs(ses->filt->stag->tag_len));
+	    strcpy(args[i],ses->filt->stag->tag_data);
+	    i++;
+	}
+    }
+    
+/*
+ */
+    if (ses->opt_daemonize) {
+	args[i]=(char *)malloc(strlen("nodetach"));
+	strcpy(args[i],"nodetach");
+	i++;
+    }
+    
+    args[i]=NULL;
+    {
+	int j;
+	poe_info(ses,"calling pppd with %d args\n",i);
+	j=i;
+	for (i=0; i<j,NULL !=args[i]; i++) {
+	    poe_info(ses," <%d: %s > \n",i,args[i]);
+	}
+    }
+    return retval;
+}
+
+
+/*
+ *
+ */
+int ppp_connect (struct session *ses)
+{
+    int ret,pid;
+    char *args[32];
+    
+    
+    poe_info(ses,"calling ses_connect\n");
+    do{
+	ret = session_connect(ses);
+    }while(ret == 0);
+
+    if (ret > 0 )
+	if (ses->np == 1 && ret == 1)
+	    return ses->np; /* -G */
+    if (ses->np == 2)
+	return ses->np; /* -H */
+
+    if( ret <= 0){
+	return ret;
+    }
+    
+    poe_info(ses,"DONE calling ses_connect np is %d \n",ses->np);
+    
+    
+    pid = fork ();
+    if (pid < 0) {
+	poe_error (ses,"unable to fork() for pppd: %m");
+	poe_die (-1);
+    }
+    
+    
+    if(!pid) {
+	poe_info(ses,"calling build_ppp_opts\n");
+	if (0> build_ppp_opts(args,ses)) {
+	    poe_error(ses,"ppp_connect: failed to build ppp_opts\n");
+	    return -1;
+	}
+	execvp(args[0],args);
+	poe_info (ses," child got killed");
+    } else if( ses->type == SESSION_CLIENT) {
+	if (!ses->opt_daemonize)
+	    return 1;
+	pause();
+	poe_info (ses," OK we got killed");
+	return -1;
+    }
+    return 1;
+}
+
--- work/ppp-2.4.9/pppd/plugins/pppoe/pppoe.c	1970-01-01 01:00:00.000000000 +0100
+++ work/ppp-2.4.9/pppd/plugins/pppoe/pppoe.c	2022-03-12 14:41:58.541107219 +0100
@@ -0,0 +1,434 @@
+/* pppoe.c - pppd plugin to implement PPPoE protocol.
+ *
+ * Copyright 2000 Michal Ostrowski <mostrows@styx.uwaterloo.ca>,
+ *		  Jamal Hadi Salim <hadi@cyberus.ca>
+ * Borrows heavily from the PPPoATM plugin by Mitchell Blank Jr.,
+ * which is based in part on work from Jens Axboe and Paul Mackerras.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ */
+
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include "pppoe.h"
+#if _linux_
+extern int new_style_driver;    /* From sys-linux.c */
+#include <linux/ppp_defs.h>
+#include <linux/if_pppox.h>
+#include <linux/if_ppp.h>
+#else
+#error this module meant for use with linux only at this time
+#endif
+
+#include "pppd.h"
+#include "fsm.h"
+#include "lcp.h"
+#include "ipcp.h"
+#include "ccp.h"
+#include "pathnames.h"
+
+const char pppd_version[] = VERSION;
+
+#define _PATH_ETHOPT         _ROOT_PATH "/etc/ppp/options."
+
+#define PPPOE_MTU	1492
+extern int kill_link;
+static char *bad_options[] = {
+    "noaccomp",
+    "-ac",
+    "default-asyncmap",
+    "-am",
+    "asyncmap",
+    "-as",
+    "escape",
+    "multilink",
+    "receive-all",
+#ifndef _DISABLE_SERIAL_
+    "crtscts",
+    "-crtscts",
+    "nocrtscts",
+    "cdtrcts",
+    "nocdtrcts",
+    "xonxoff",
+    "modem",
+#endif
+    "local",
+    "sync",
+    "deflate",
+    "nodeflate",
+    "vj",
+    "novj",
+    "nobsdcomp",
+    "bsdcomp",
+    "-bsdcomp",
+    NULL
+};
+
+bool	pppoe_server=0;
+char	*pppoe_srv_name=NULL;
+char	*pppoe_ac_name=NULL;
+char    *hostuniq = NULL;
+int     retries = 0;
+
+int setdevname_pppoe(const char *cp);
+static void pppoe_close_fds(void);
+
+static option_t pppoe_options[] = {
+	{ "device name", o_wild, (void *) &setdevname_pppoe,
+	  "Serial port device name",
+	  OPT_DEVNAM | OPT_PRIVFIX | OPT_NOARG  | OPT_A2STRVAL | OPT_STATIC,
+	  devnam},
+	{ "pppoe_srv_name", o_string, &pppoe_srv_name,
+	  "PPPoE service name"},
+	{ "pppoe_ac_name", o_string, &pppoe_ac_name,
+	  "PPPoE access concentrator name"},
+	{ "pppoe_hostuniq", o_string, &hostuniq,
+	  "PPPoE client uniq hostid "},
+	{ "pppoe_retransmit", o_int, &retries,
+	  "PPPoE client number of retransmit tries"},
+	{ "pppoe_server", o_bool, &pppoe_server,
+	  "PPPoE listen for incoming requests",1},
+	{ NULL }
+};
+
+extern int disc_sock;
+
+struct session *ses = NULL;
+#ifdef MULTI_OFFER
+void markfailserver()
+{
+	addToBlacklist(ses->sp.sa_addr.pppoe.remote);
+}
+
+void marksuccessserver()
+{
+	removefromBlacklist(ses->sp.sa_addr.pppoe.remote);
+}
+#endif /* MULTI_OFFER */
+
+static int connect_pppoe_ses(void)
+{
+    int err=-1;
+    if( pppoe_server == 1 ){
+	srv_init_ses(ses,devnam);
+    }else{
+	client_init_ses(ses,devnam);
+    }
+    strlcpy(ppp_devnam, devnam, sizeof(ppp_devnam));
+
+    err= session_connect ( ses );
+	/*CDRouter: pppoe client session should try to connect again if not receive
+	 *			PADO after PADI (it does not specify pppoe server action)
+	 */ 
+	if (pppoe_server == 1) {
+	    if(err < 0){
+			poe_fatal(ses,"Failed to negotiate PPPoE connection: %d %m",errno,errno);
+		}
+	} else {
+		while(err <= 0) {
+			if (err < 0) {
+				poe_fatal(ses,"Failed to negotiate PPPoE connection: %d %m",
+							errno,errno);
+			}
+			client_init_ses(ses, devnam);
+			err = session_connect(ses);	
+		}
+	}
+
+    err = connect(ses->fd, (struct sockaddr*)&ses->sp,
+		  sizeof(struct sockaddr_pppox));
+
+    poe_info(ses, "Connecting PPPoE socket: %E %04x %s %p",
+	     ses->sp.sa_addr.pppoe.remote,
+	     ses->sp.sa_addr.pppoe.sid,
+	     ses->sp.sa_addr.pppoe.dev,ses);
+
+    if( err < 0 ){
+	poe_fatal(ses,"Failed to connect PPPoE socket: %d %m",errno,errno);
+	return err;
+    }
+    /* Once the logging is fixed, print a message here indicating
+       connection parameters */
+
+#ifdef _RECORD_SID_
+/*
+ * Netgear Spec V1.9
+ *
+ * To avoid the case that server will limit the PPPoE sessions accounts, client should
+ * terminate previous session before establish a new session. Client should record the
+ * session id into flash whenever the connection is established.
+ * (Client should record the session id into flash, and send PADT to terminate these
+ * sessions before sending PADI).
+ */
+    {
+        char temp[32];
+
+        sprintf(temp, "%u", ses->sp.sa_addr.pppoe.sid);
+        nvram_set(PPPOE_SID, temp);
+
+        sprintf(temp, "%02X:%02X:%02X:%02X:%02X:%02X",
+            ses->sp.sa_addr.pppoe.remote[0],
+            ses->sp.sa_addr.pppoe.remote[1],
+            ses->sp.sa_addr.pppoe.remote[2],
+            ses->sp.sa_addr.pppoe.remote[3],
+            ses->sp.sa_addr.pppoe.remote[4],
+            ses->sp.sa_addr.pppoe.remote[5]);
+        nvram_set(PPPOE_SRV_ADDR, temp);
+        nvram_commit();
+    }
+#endif
+    return ses->fd;
+}
+
+static void disconnect_pppoe_ses(void)
+{
+    int ret;
+    warn("Doing disconnect");
+    session_disconnect(ses);
+    ses->sp.sa_addr.pppoe.sid = 0;
+    ret = connect(ses->fd, (struct sockaddr*)&ses->sp,
+	    sizeof(struct sockaddr_pppox));
+
+	pppoe_close_fds();
+}
+
+static void init_device_pppoe(void)
+{
+    struct filter *filt;
+
+    ses=(void *)malloc(sizeof(struct session));
+    if(!ses){
+	fatal("No memory for new PPPoE session");
+    }
+    memset(ses,0,sizeof(struct session));
+
+    if ((ses->filt=malloc(sizeof(struct filter))) == NULL) {
+	poe_error (ses,"failed to malloc for Filter ");
+	poe_die (-1);
+    }
+
+    filt=ses->filt;  /* makes the code more readable */
+    memset(filt,0,sizeof(struct filter));
+
+    if (pppoe_ac_name !=NULL) {
+	if (strlen (pppoe_ac_name) > 255) {
+	    poe_error (ses," AC name too long (maximum allowed 256 chars)");
+	    poe_die(-1);
+	}
+	ses->filt->ntag = make_filter_tag(PTT_AC_NAME,
+					  strlen(pppoe_ac_name),
+					  pppoe_ac_name);
+
+	if ( ses->filt->ntag== NULL) {
+	    poe_error (ses,"failed to malloc for AC name");
+	    poe_die(-1);
+	}
+
+    }
+
+    if (pppoe_srv_name !=NULL) {
+	if (strlen (pppoe_srv_name) > 255) {
+	    poe_error (ses," Service name too long (maximum allowed 256 chars)");
+	    poe_die(-1);
+	}
+	ses->filt->stag = make_filter_tag(PTT_SRV_NAME,
+					  strlen(pppoe_srv_name),
+					  pppoe_srv_name);
+	if ( ses->filt->stag == NULL) {
+	    poe_error (ses,"failed to malloc for service name");
+	    poe_die(-1);
+	}
+    }
+
+    if (hostuniq) {
+	ses->filt->htag = make_filter_tag(PTT_HOST_UNIQ,
+					  strlen(hostuniq),
+					  hostuniq);
+	if ( ses->filt->htag == NULL) {
+	    poe_error (ses,"failed to malloc for Uniq Host Id ");
+	    poe_die(-1);
+	}
+    }
+
+    if (retries) {
+	ses->retries=retries;
+    }
+
+    memcpy( ses->name, devnam, IFNAMSIZ);
+    ses->opt_debug=1;
+}
+
+static void pppoe_extra_options()
+{
+    char buf[256];
+
+    snprintf(buf, 256, _PATH_ETHOPT "%s",devnam);
+    if(!options_from_file(buf, 0, 0, 1))
+	exit(EXIT_OPTION_ERROR);
+
+}
+
+static void send_config_pppoe(int mtu,
+			      u_int32_t asyncmap,
+			      int pcomp,
+			      int accomp)
+{
+    int sock;
+    struct ifreq ifr;
+
+    if (mtu > PPPOE_MTU) {
+	warn("Couldn't increase MTU to %d.", mtu);
+	mtu = PPPOE_MTU;
+    }
+    sock = socket(AF_INET, SOCK_DGRAM, 0);
+    if (sock < 0)
+	fatal("Couldn't create IP socket: %m");
+    strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
+    ifr.ifr_mtu = mtu;
+    if (ioctl(sock, SIOCSIFMTU, (caddr_t) &ifr) < 0)
+	fatal("ioctl(SIOCSIFMTU): %m");
+    (void) close (sock);
+}
+
+static void recv_config_pppoe(int mru,
+			      u_int32_t asyncmap,
+			      int pcomp,
+			      int accomp)
+{
+    if (mru > PPPOE_MTU)
+	error("Couldn't increase MRU to %d", mru);
+}
+
+struct channel pppoe_channel;
+/* Check is cp is a valid ethernet device
+ * return either 1 if "cp" is a reasonable thing to name a device
+ * or die.
+ * Note that we don't actually open the device at this point
+ * We do need to fill in:
+ *   devnam: a string representation of the device
+ */
+
+int (*old_setdevname_hook)(const char* cp) = NULL;
+int setdevname_pppoe(const char *cp)
+{
+    int ret;
+    char dev[IFNAMSIZ+1];
+    int addr[ETH_ALEN];
+    int sid;
+
+    ret =sscanf(cp, FMTSTRING(IFNAMSIZ),addr, addr+1, addr+2,
+		addr+3, addr+4, addr+5,&sid,dev);
+    if( ret != 8 ){
+
+	ret = get_sockaddr_ll(cp,NULL);
+        if (ret < 0)
+	    fatal("PPPoE: Cannot create PF_PACKET socket for PPPoE discovery\n");
+	if (ret == 1)
+	    strncpy(devnam, cp, sizeof(devnam));
+    }else{
+	/* long form parsed */
+	ret = get_sockaddr_ll(dev,NULL);
+        if (ret < 0)
+	    fatal("PPPoE: Cannot create PF_PACKET socket for PPPoE discovery\n");
+
+	strncpy(devnam, cp, sizeof(devnam));
+	ret = 1;
+    }
+
+    if( ret == 1 && the_channel != &pppoe_channel ){
+
+	the_channel = &pppoe_channel;
+
+	{
+	    char **a;
+	    for (a = bad_options; *a != NULL; a++)
+		remove_option(*a);
+	}
+#ifndef _DISABLE_SERIAL_
+	modem = 0;
+#endif
+	lcp_allowoptions[0].neg_accompression = 0;
+	lcp_wantoptions[0].neg_accompression = 0;
+
+	lcp_allowoptions[0].neg_asyncmap = 0;
+	lcp_wantoptions[0].neg_asyncmap = 0;
+
+	lcp_allowoptions[0].neg_pcompression = 0;
+	lcp_wantoptions[0].neg_pcompression = 0;
+
+	ccp_allowoptions[0].deflate = 0 ;
+	ccp_wantoptions[0].deflate = 0 ;
+
+	ipcp_allowoptions[0].neg_vj=0;
+	ipcp_wantoptions[0].neg_vj=0;
+
+	ccp_allowoptions[0].bsd_compress = 0;
+	ccp_wantoptions[0].bsd_compress = 0;
+
+	init_device_pppoe();
+
+#ifdef MULTI_OFFER
+	p_marksuccessserver = marksuccessserver;
+	InitBlacklist();
+#endif /* MULTI_OFFER */
+    }
+    return ret;
+}
+
+char *get_pppd_version(void)
+{
+    return (char *)(pppd_version);
+}
+
+void pppoe_plugin_init(void)
+{
+#if _linux_
+    if (!ppp_available() && !new_style_driver)
+	fatal("Kernel doesn't support ppp_generic needed for PPPoE");
+#else
+    fatal("No PPPoE support on this OS");
+#endif
+    add_options(pppoe_options);
+
+    info("PPPoE Plugin Initialized");
+}
+
+static void pppoe_close_fds(void)
+{
+  	if (ses->fd >= 0) {
+    	close(ses->fd);
+		ses->fd = -1;
+  	}
+	if (disc_sock >= 0) {
+    	close(disc_sock);
+		disc_sock = -1;
+	}
+}
+
+static void cleanup_pppoe(void)
+{
+  	pppoe_close_fds();
+}
+
+struct channel pppoe_channel = {
+    options: pppoe_options,
+    process_extra_options: &pppoe_extra_options,
+    check_options: NULL,
+    connect: &connect_pppoe_ses,
+    disconnect: &disconnect_pppoe_ses,
+    establish_ppp: &generic_establish_ppp,
+    disestablish_ppp: &generic_disestablish_ppp,
+    send_config: &send_config_pppoe,
+    recv_config: &recv_config_pppoe,
+    close: &pppoe_close_fds,
+    cleanup: &cleanup_pppoe
+};
+
--- work/ppp-2.4.9/pppd/plugins/pppoe/pppoe_client.c	1970-01-01 01:00:00.000000000 +0100
+++ work/ppp-2.4.9/pppd/plugins/pppoe/pppoe_client.c	2021-12-16 16:38:08.000000000 +0100
@@ -0,0 +1,472 @@
+/* PPPoE support library "libpppoe"
+ *
+ * Copyright 2000 Michal Ostrowski <mostrows@styx.uwaterloo.ca>,
+ *		  Jamal Hadi Salim <hadi@cyberus.ca>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ */
+
+#include "pppoe.h"
+
+
+extern char	*pppoe_srv_name;
+
+#ifdef MULTI_OFFER
+#define MAX_BLACKLIST_NUM  (5)
+static unsigned char blacklist[MAX_BLACKLIST_NUM][ETH_ALEN] = {{0}};
+static struct sockaddr_ll init_remote;
+
+static int isblackhost(unsigned char *addr)
+{
+	int i;
+
+	for(i = 0; i < MAX_BLACKLIST_NUM; i++)
+	{
+/*		error("isblackhost %02X:%02X:%02X:%02X:%02X:%02X",
+				blacklist[i][0],
+				blacklist[i][1],
+				blacklist[i][2],
+				blacklist[i][3],
+				blacklist[i][4],
+				blacklist[i][5]);*/
+		if (memcmp(blacklist[i], addr, sizeof(blacklist[0])) == 0)
+		{
+			return 1;
+		}
+	}
+
+	return 0;
+}
+void InitBlacklist()
+{
+	memset(blacklist, 0, sizeof(blacklist));
+}
+void removefromBlacklist(unsigned char *addr)
+{
+	int i;
+	unsigned char zero[ETH_ALEN];
+	int found = 0;
+
+	memset(zero, 0, sizeof(zero));
+
+	for (i = 0; i < MAX_BLACKLIST_NUM; i++)
+	{
+		if (!found && memcmp(blacklist[i], addr, sizeof(zero)) == 0)
+		{
+			found = 1;
+		}
+
+		if (found)
+		{
+			if (i < MAX_BLACKLIST_NUM - 1)
+			{
+				memcpy(blacklist[i], blacklist[i + 1], sizeof(zero));
+
+				if (memcmp(blacklist[i], zero, sizeof(zero)) == 0)
+				{
+					break;
+				}
+			}
+			else
+			{
+				memset(blacklist[i], 0, sizeof(zero));
+			}
+		}
+	}
+}
+
+int addToBlacklist(unsigned char *addr)
+{
+	int i;
+	unsigned char zero[ETH_ALEN];
+
+	memset(zero, 0, sizeof(zero));
+/* error("addToBlacklist %02X:%02X:%02X:%02X:%02X:%02X",
+            addr[0],
+            addr[1],
+            addr[2],
+            addr[3],
+            addr[4],
+            addr[5]); */
+	for(i = 0; i < MAX_BLACKLIST_NUM; i++)
+	{
+		if (memcmp(blacklist[i], zero, sizeof(zero)) == 0)
+		{
+			memcpy(blacklist[i], addr, sizeof(zero));
+			return 0;
+		}
+		else if (memcmp(blacklist[i], addr, sizeof(zero)) == 0)
+		{
+			return 0;
+		}
+	}
+	return 1;
+}
+static int std_rcv_timeout(struct session* ses,
+		struct pppoe_packet *p_in,
+		struct pppoe_packet **p_out)
+{
+		if(ses->state == PADO_CODE)
+		{
+			poe_info(ses,"Clear blacklist." );
+			memset(blacklist, 0, sizeof(blacklist));
+		}
+
+	    if(ses->state == PADS_CODE && ses->retransmits >= 3 /* retry 4 times*/)
+	    {
+			if (addToBlacklist((*p_out)->addr.sll_addr))
+			{
+				poe_info(ses, "Blacklist is full");
+			}else
+			{
+				poe_info(ses, "Add %E to blacklist.", (*p_out)->addr.sll_addr);
+			}
+
+			memset(&ses->curr_pkt, 0, sizeof(struct pppoe_packet));
+
+			ses->curr_pkt.hdr = (struct pppoe_hdr*) ses->curr_pkt.buf;
+			ses->curr_pkt.hdr->ver = 1;
+			ses->curr_pkt.hdr->type = 1;
+			ses->curr_pkt.hdr->code = PADI_CODE;
+
+			ses->state = PADO_CODE;
+
+			memcpy(&ses->curr_pkt.addr, &init_remote, sizeof(struct sockaddr_ll));
+
+			poe_info(ses, "Resending PADI");
+			if (DEB_DISC)
+				poe_dbglog(ses, "Resending PADI");
+
+			ses->retransmits = 0;
+
+			if (ses->filt->ntag)
+			{
+				ses->curr_pkt.tags[TAG_AC_NAME] = ses->filt->ntag;
+				poe_info(ses, "overriding AC name\n");
+			}
+
+			/* Ron fixed add pppoe srv support */
+			if (pppoe_srv_name != NULL)
+			{
+				if (strlen(pppoe_srv_name) > 255)
+				{
+					poe_error(ses,
+							" Service name too long (maximum allowed 256 chars)");
+					poe_die(-1);
+				}
+				ses->filt->stag = make_filter_tag(PTT_SRV_NAME, strlen(
+						pppoe_srv_name), pppoe_srv_name);
+				if (ses->filt->stag == NULL)
+				{
+					poe_error(ses, "failed to malloc for service name");
+					poe_die(-1);
+				}
+				printf("pppoe_srv_name=%s\n", pppoe_srv_name);
+			}
+
+			if (ses->filt->stag)
+				ses->curr_pkt.tags[TAG_SRV_NAME] = ses->filt->stag;
+			else
+				printf("ses->filt->stag==NULL\n");
+
+			if (ses->filt->htag)
+				ses->curr_pkt.tags[TAG_HOST_UNIQ] = ses->filt->htag;
+
+			send_disc(ses, &ses->curr_pkt);
+			(*p_out) = &ses->curr_pkt;
+		}else if(p_out && *p_out)
+	    {
+	    	++ses->retransmits;
+	    	send_disc(ses,*p_out);
+	    }
+
+		return 0;
+}
+#endif /* MULTI_OFFER */
+static int std_rcv_pado(struct session* ses,
+			struct pppoe_packet *p_in,
+			struct pppoe_packet **p_out){
+
+    if( verify_packet(ses, p_in) < 0)
+	return -1;
+
+    if(ses->state != PADO_CODE ){
+	poe_error(ses,"Unexpected packet: %P",p_in);
+	return 0;
+    }
+
+
+    if (DEB_DISC2) {
+	poe_dbglog (ses,"PADO received: %P", p_in);
+    }
+#ifdef MULTI_OFFER
+/*  follow Netgear spec 1.9
+	In multiple offer case from server, because GUI doesn't support to identify concentrator
+	name.
+	If router has experienced that the offer from this server is failed, router should ignore this
+	offer and wait for other offers from different servers.
+*/
+    if(isblackhost(p_in->addr.sll_addr))
+    {
+    	poe_info (ses,"Host in blacklist. %P", p_in);
+    	return 0;
+    }else
+    {
+    	poe_info (ses,"Host not in blacklist. %P", p_in);
+    }
+#endif
+    memcpy(&ses->remote, &p_in->addr, sizeof(struct sockaddr_ll));
+    memcpy( &ses->curr_pkt.addr, &ses->remote , sizeof(struct sockaddr_ll));
+
+    ses->curr_pkt.hdr->code = PADR_CODE;
+
+    /* The HOST_UNIQ has been verified already... there's no "if" about this */
+    /* if(ses->filt->htag) */
+    copy_tag(&ses->curr_pkt,get_tag(p_in->hdr,PTT_HOST_UNIQ));
+
+    if (ses->filt->ntag) {
+    	ses->curr_pkt.tags[TAG_AC_NAME]=NULL;
+    }
+//    copy_tag(&ses->curr_pkt,get_tag(p_in->hdr,PTT_AC_NAME));
+
+    if(ses->filt->stag) {
+    	ses->curr_pkt.tags[TAG_SRV_NAME]=NULL;
+    }
+    copy_tag(&ses->curr_pkt,get_tag(p_in->hdr,PTT_SRV_NAME));
+
+    copy_tag(&ses->curr_pkt,get_tag(p_in->hdr,PTT_AC_COOKIE));
+    copy_tag(&ses->curr_pkt,get_tag(p_in->hdr,PTT_RELAY_SID));
+
+    ses->state = PADS_CODE;
+
+    ses->retransmits = 0;
+
+    send_disc(ses, &ses->curr_pkt);
+    (*p_out) = &ses->curr_pkt;
+#ifdef MULTI_OFFER
+	if (addToBlacklist((*p_out)->addr.sll_addr))
+	{
+		poe_info(ses, "LINE[%d] Blacklist is full", __LINE__);
+	}else
+	{
+		poe_info(ses, "Add %E to blacklist after send PADR.", (*p_out)->addr.sll_addr);
+	}
+#endif /* MULTI_OFFER */
+    if (ses->np)
+	return 1;
+
+    return 0;
+}
+
+static int std_init_disc(struct session* ses,
+			 struct pppoe_packet *p_in,
+			 struct pppoe_packet **p_out){
+
+    memset(&ses->curr_pkt,0, sizeof(struct pppoe_packet));
+
+
+    /* Check if already connected */
+    if( ses->state != PADO_CODE ){
+	return 1;
+    }
+
+#ifdef _RECORD_SID_
+/* Send PADT before PADI to terminate old Session */
+/*
+ * Netgear Spec V1.9
+ *
+ * To avoid the case that server will limit the PPPoE sessions accounts, client should
+ * terminate previous session before establish a new session. Client should record the
+ * session id into flash whenever the connection is established.
+ * (Client should record the session id into flash, and send PADT to terminate these
+ * sessions before sending PADI).
+ */
+    poe_info (ses, "Sending PADT");
+    send_padt(ses, &ses->curr_pkt);
+#endif
+
+    ses->curr_pkt.hdr = (struct pppoe_hdr*) ses->curr_pkt.buf;
+    ses->curr_pkt.hdr->ver  = 1;
+    ses->curr_pkt.hdr->type = 1;
+    ses->curr_pkt.hdr->code = PADI_CODE;
+
+    memcpy( &ses->curr_pkt.addr, &ses->remote , sizeof(struct sockaddr_ll));
+
+    poe_info (ses,"Sending PADI");
+    if (DEB_DISC)
+	poe_dbglog (ses,"Sending PADI");
+
+    ses->retransmits = 0 ;
+
+    if(ses->filt->ntag) {
+	ses->curr_pkt.tags[TAG_AC_NAME]=ses->filt->ntag;
+	poe_info(ses,"overriding AC name\n");
+    }
+
+    /* Ron fixed add pppoe srv support */
+    if (pppoe_srv_name !=NULL) {
+	if (strlen (pppoe_srv_name) > 255) {
+	    poe_error (ses," Service name too long (maximum allowed 256 chars)");
+	    poe_die(-1);
+	}
+	ses->filt->stag = make_filter_tag(PTT_SRV_NAME,
+					  strlen(pppoe_srv_name),
+					  pppoe_srv_name);
+	if ( ses->filt->stag == NULL) {
+	    poe_error (ses,"failed to malloc for service name");
+	    poe_die(-1);
+	}
+	printf("pppoe_srv_name=%s\n",pppoe_srv_name);
+    }
+
+    if(ses->filt->stag)
+	ses->curr_pkt.tags[TAG_SRV_NAME]=ses->filt->stag;
+    else
+    	printf("ses->filt->stag==NULL\n");
+
+    if(ses->filt->htag)
+	ses->curr_pkt.tags[TAG_HOST_UNIQ]=ses->filt->htag;
+
+//#ifndef _RECORD_SID_
+//    ses->curr_pkt.hdr->code = PADT_CODE;
+//    send_disc(ses, &ses->curr_pkt);
+//#endif
+
+    ses->curr_pkt.hdr->code = PADI_CODE;
+    send_disc(ses, &ses->curr_pkt);
+    (*p_out)= &ses->curr_pkt;
+    return 0;
+}
+
+
+static int std_rcv_pads(struct session* ses,
+			struct pppoe_packet *p_in,
+			struct pppoe_packet **p_out){
+    if( verify_packet(ses, p_in) < 0)
+	return -1;
+
+    if (DEB_DISC)
+	poe_dbglog (ses,"Got connection: %x",
+		    ntohs(p_in->hdr->sid));
+    poe_info (ses,"Got connection: %x", ntohs(p_in->hdr->sid));
+
+    ses->sp.sa_family = AF_PPPOX;
+    ses->sp.sa_protocol = PX_PROTO_OE;
+    ses->sp.sa_addr.pppoe.sid = p_in->hdr->sid;
+
+    memcpy(ses->sp.sa_addr.pppoe.dev,ses->name, IFNAMSIZ);
+    memcpy(ses->sp.sa_addr.pppoe.remote, p_in->addr.sll_addr, ETH_ALEN);
+
+
+    return 1;
+}
+
+static int std_rcv_padt(struct session* ses,
+			struct pppoe_packet *p_in,
+			struct pppoe_packet **p_out){
+    ses->state = PADO_CODE;
+    return 0;
+}
+
+
+
+extern int disc_sock;
+int client_init_ses (struct session *ses, char* devnam)
+{
+    int i=0;
+    int retval;
+    char dev[IFNAMSIZ+1];
+    int addr[ETH_ALEN];
+    int sid;
+
+    /* do error checks here; session name etc are valid */
+//    poe_info (ses,"init_ses: creating socket");
+
+    /* Make socket if necessary */
+    if( disc_sock < 0 ){
+
+	disc_sock = socket(PF_PACKET, SOCK_DGRAM, 0);
+	if( disc_sock < 0 ){
+	    poe_fatal(ses,
+		      "Cannot create PF_PACKET socket for PPPoE discovery\n");
+	}
+
+    }
+
+    /* Check for long format */
+    retval =sscanf(devnam, FMTSTRING(IFNAMSIZ),addr, addr+1, addr+2,
+		   addr+3, addr+4, addr+5,&sid,dev);
+    if( retval != 8 ){
+	/* Verify the device name , construct ses->local */
+	retval = get_sockaddr_ll(devnam,&ses->local);
+	if (retval < 0)
+	    poe_fatal(ses, "client_init_ses: "
+		      "Cannot create PF_PACKET socket for PPPoE discovery\n");
+
+
+	ses->state = PADO_CODE;
+	memcpy(&ses->remote, &ses->local, sizeof(struct sockaddr_ll) );
+
+	memset( ses->remote.sll_addr, 0xff, ETH_ALEN);
+    }else{
+	/* long form parsed */
+
+	/* Verify the device name , construct ses->local */
+	retval = get_sockaddr_ll(dev,&ses->local);
+	if (retval < 0)
+	    poe_fatal(ses,"client_init_ses(2): "
+		      "Cannot create PF_PACKET socket for PPPoE discovery\n");
+	ses->state = PADS_CODE;
+	ses->sp.sa_family = AF_PPPOX;
+	ses->sp.sa_protocol = PX_PROTO_OE;
+	ses->sp.sa_addr.pppoe.sid = sid;
+
+	memcpy(&ses->remote, &ses->local, sizeof(struct sockaddr_ll) );
+
+	for(; i < ETH_ALEN ; ++i ){
+	    ses->sp.sa_addr.pppoe.remote[i] = addr[i];
+	    ses->remote.sll_addr[i]=addr[i];
+	}
+	memcpy(ses->sp.sa_addr.pppoe.dev, dev, IFNAMSIZ);
+
+
+
+    }
+    if( retval < 0 )
+	error("bad device name: %s",devnam);
+
+
+    retval = bind( disc_sock ,
+		   (struct sockaddr*)&ses->local,
+		   sizeof(struct sockaddr_ll));
+
+
+    if( retval < 0 ){
+	error("bind to PF_PACKET socket failed: %m");
+    }
+
+    ses->fd = socket(AF_PPPOX,SOCK_STREAM,PX_PROTO_OE);
+    if(ses->fd < 0)
+    {
+	poe_fatal(ses,"Failed to create PPPoE socket: %m");
+    }
+
+
+    ses->init_disc = std_init_disc;
+    ses->rcv_pado  = std_rcv_pado;
+    ses->rcv_pads  = std_rcv_pads;
+    ses->rcv_padt  = std_rcv_padt;
+#ifdef MULTI_OFFER
+    /* Jacky add */
+    memcpy(&init_remote, &ses->remote, sizeof(struct sockaddr_ll) );
+    ses->timeout = std_rcv_timeout;
+#endif
+    /* this should be filter overridable */
+    ses->retries = 10;
+
+    return ses->fd;
+}
+
--- work/ppp-2.4.9/pppd/plugins/pppoe/pppoed.c	1970-01-01 01:00:00.000000000 +0100
+++ work/ppp-2.4.9/pppd/plugins/pppoe/pppoed.c	2021-12-16 16:38:08.000000000 +0100
@@ -0,0 +1,283 @@
+/* PPPoE support library "libpppoe"
+ *
+ * Copyright 2000 Jamal Hadi Salim <hadi@cyberus.ca>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ */
+
+#include "pppoe.h"
+
+int detached=1;
+void
+sigproc (int src)
+{
+    int i;
+    fprintf (stderr,"Received signal %d", src);
+}
+
+void
+sigchild (int src)
+{
+    pid_t pid;
+    int status;
+    int i;
+    pid = waitpid (-1, &status, WNOHANG);
+    
+    if (!detached)
+	fprintf (stderr,"Child received signal %d PID %d, status %d", src, pid, status);
+    if (pid < 1) {
+	return;
+    }
+}
+
+void
+print_help ()
+{
+    
+    fprintf (stdout,"\npppoe version %d.%d build %d", VERSION_MAJOR, VERSION_MINOR,
+	     VERSION_DATE);
+    fprintf (stdout,"\nrecognized options are:");
+    fprintf (stdout,"\n -I <interface> : overrides the default interface of eth0");
+    fprintf (stdout,"\n -S : starts pppoed in server mode");
+    fprintf (stdout,"\n -R <num_retries>: forces pppoed to be restarted num_retries");
+    fprintf (stdout,"\n                   should the other end be detected to be dead.");
+    fprintf (stdout,"\n                   Needs lcp_echo. Read the INSTALL file instructions");
+    fprintf (stdout,"\n -F <filename> : specifies additional ppp options file");
+    fprintf (stdout,"\n -C <filename> : ppp options file in /etc/ppp/peers/");
+    fprintf (stdout,"\n -d <level> : sets debug level");
+    fprintf (stdout,"\n -D : prevents pppoed from detaching itself and running in the background");
+    fprintf (stdout,"\n -P <path to pppd> : selects a different pppd. Defaults to " _PATH_PPPD);
+    fprintf (stdout,"\n -A <AC name> to select a specific AC by name");
+    fprintf (stdout,"\n -E <AC service name> to select a specific AC service by name");
+    fprintf (stdout,"\n -G Do service discovery only");
+    fprintf (stdout,"\n -H Do service discovery and connection (no pppd)\n");
+}
+
+
+int 
+get_args (int argc, char **argv,struct session *sess)
+{
+    struct filter *filt;
+    struct host_tag *tg;
+    int opt;
+    
+
+    sess->opt_debug = 0;
+    DEB_DISC=0;
+    DEB_DISC2=0;
+    sess->log_to_fd = 1;
+    sess->np = 0;
+    sess->opt_daemonize = 0;
+    
+    sess->log_to_fd = fileno (stdout);
+    
+/* defaults to eth0 */
+    strcpy (sess->name, "eth0");
+    
+    
+    if ((sess->filt=malloc(sizeof(struct filter))) == NULL) {
+        poe_error (sess,"failed to malloc for Filter ");
+        poe_die (-1);
+    }
+    
+    filt=sess->filt;  /* makes the code more readable */
+    memset(filt,0,sizeof(struct filter));
+    
+    filt->num_restart=1;
+    
+/* set default filters; move this to routine */
+    /* parse options */
+    
+    while ((opt = getopt (argc, argv, "A:C:E:d:DR:I:F:L:V:P:SN:GH")) != -1)
+	
+	switch (opt) {
+	case 'R':			/* sets number of retries */
+	    filt->num_restart = strtol (optarg, (char **) NULL, 10);
+	    filt->num_restart += 1;
+	    break;
+	case 'I':			/* sets interface */
+	    if (strlen (optarg) >= IFNAMSIZ) {
+		poe_error (sess,"interface name cannot exceed %d characters", IFNAMSIZ - 1);
+		return (-1);
+	    }
+	    strncpy (sess->name, optarg, strlen(optarg)+1);
+	    break;
+	case 'C':			/* name of the file in /etc/ppp/peers */
+	    if (NULL != filt->fname) {
+		poe_error (sess,"-F can not be used with -C");
+		return (-1);
+	    }
+	    if (strlen(optarg) > MAX_FNAME) {
+		poe_error (sess,"file name cannot exceed %d characters", MAX_FNAME - 1);
+		return (-1);
+	    }
+	    filt->fname=malloc(strlen(optarg));
+	    strncpy (filt->fname, optarg, strlen(optarg));
+	    filt->peermode=1;
+	    break;
+	case 'F':			/* sets the options file */
+	    if (NULL != filt->fname) {
+		poe_error (sess,"-F can not be used with -C");
+		return (-1);
+	    }
+	    
+	    if (strlen(optarg) > MAX_FNAME) {
+		poe_error (sess,"file name cannot exceed %d characters", MAX_FNAME - 1);
+		return (-1);
+	    }
+	    filt->fname=malloc(strlen(optarg)+1);
+	    strncpy (filt->fname, optarg, strlen(optarg)+1);
+	    
+	    poe_info (sess,"selected %s as filename\n",filt->fname);
+	    break;
+	case 'D':			/* don't daemonize */
+	    sess->opt_daemonize = 1;
+	    detached=0;
+	    break;
+	case 'd':			/* debug level */
+	    sess->opt_debug = strtol (optarg, (char **) NULL, 10);
+	    if (sess->opt_debug & 0x0002)
+		DEB_DISC=1;
+	    if (sess->opt_debug & 0x0004)
+		DEB_DISC2=1;
+	    break;
+	case 'P':			/* sets the pppd binary */
+	    if (strlen(optarg) > MAX_FNAME) {
+		poe_error (sess,"pppd binary cant exceed %d characters", MAX_FNAME - 1);
+		return (-1);
+	    }
+	    filt->pppd=malloc(strlen(optarg));
+	    strncpy (filt->pppd, optarg, strlen(optarg));
+	    break;
+	case 'H':			
+	    sess->np = 2;
+	    break;
+	case 'G':			
+	    sess->np = 1;
+	    break;
+	case 'V':			/* version */
+	    fprintf (stdout,"pppoe version %d.%d build %d", VERSION_MAJOR,
+		     VERSION_MINOR, VERSION_DATE);
+	    return (0);
+	case 'S':			/* server mode */
+	    sess->type = SESSION_SERVER;
+	    break;
+	case 'A':			/* AC override */
+	    poe_info (sess,"AC name override to %s", optarg);
+	    if (strlen (optarg) > 255) {
+		poe_error (sess," AC name too long 
+			  (maximum allowed 256 chars)");
+		poe_die(-1);
+	    }
+	    if ((sess->filt->ntag= malloc (sizeof (struct pppoe_tag) + 
+					   strlen (optarg)))== NULL) {
+		poe_error (sess,"failed to malloc for AC name");
+		poe_die(-1);
+	    }
+	    sess->filt->ntag->tag_len=htons(strlen(optarg));
+	    sess->filt->ntag->tag_type=PTT_AC_NAME;
+	    poe_error (sess," pppoe_ac_name: AC name Override %p\n",
+		       sess->filt->ntag);
+	    strcpy(sess->filt->ntag->tag_data,optarg);
+	    break;
+	case 'E':			/* AC service name override */
+	    poe_info (sess,"AC service name override to %s", optarg);
+	    if (strlen (optarg) > 255) {
+		poe_error (sess," Service name too long 
+	          (maximum allowed 256 chars)");
+		poe_die(-1);
+	    }
+	    
+	    if ((filt->stag = malloc (strlen (optarg) + sizeof (struct pppoe_tag))) == NULL) {
+		poe_error (sess,"failed to malloc for service name: %m");
+		return (-1);
+	    }
+	    
+	    filt->stag->tag_len = htons (strlen (optarg));
+	    filt->stag->tag_type = PTT_SRV_NAME;
+	    strcpy ((char *) (filt->stag->tag_data), optarg);
+	    break;
+	default:
+	    poe_error (sess,"Unknown option '%c'", optopt);
+	    print_help ();
+	    return (-1);
+	}
+    
+    
+    return (1);
+    
+}
+
+
+int main(int argc, char** argv){
+    int ret;
+    struct filter *filt;
+    struct session *ses = (struct session *)malloc(sizeof(struct session));
+    char buf[256];
+    ses=(void *)malloc(sizeof(struct session));
+    
+    if(!ses){
+	return -1;
+    }
+    memset(ses,0,sizeof(struct session));
+    
+    
+    
+    openlog ("pppoed", LOG_PID | LOG_NDELAY, LOG_PPPOE);
+    setlogmask (LOG_UPTO (ses->opt_debug ? LOG_DEBUG : LOG_INFO));
+    
+    
+    if ((get_args (argc,(char **) argv,ses)) <1)
+        poe_die(-1);
+    
+    filt=ses->filt;  /* makes the code more readable */
+    
+    if (!ses->np) {
+	poe_create_pidfile (ses);
+//	signal (SIGINT, &sigproc);
+//	signal (SIGTERM, &sigproc);
+	signal (SIGCHLD, &sigchild);
+    }
+    
+    if(ses->type == SESSION_CLIENT){
+
+	poe_info(ses,"calling client_init_ses\n");
+	ret = client_init_ses(ses,ses->name);
+    
+	if( ret < 0 ){
+	    return -1;
+	}
+
+	while (ses->filt->num_restart > 0)
+	{
+	    poe_info(ses,"Restart number %d ",ses->filt->num_restart);
+	    ppp_connect (ses);
+	    ses->filt->num_restart--;
+	}
+
+    }else if( ses->type == SESSION_SERVER ){
+
+	poe_info(ses,"calling srv_init_ses\n");
+	ret = srv_init_ses(ses,ses->name);
+
+	if( ret < 0 ){
+	    return -1;
+	}
+
+	ret = 1;
+	while(ret>=0)
+	    ret = ppp_connect(ses);
+    
+    }
+
+    
+    
+    
+    poe_info(ses,"ppp_connect came back! %d",ret);
+    
+    exit(0);
+    
+}
--- work/ppp-2.4.9/pppd/plugins/pppoe/pppoefwd.c	1970-01-01 01:00:00.000000000 +0100
+++ work/ppp-2.4.9/pppd/plugins/pppoe/pppoefwd.c	2021-12-16 16:38:08.000000000 +0100
@@ -0,0 +1,61 @@
+#include "pppoe.h"
+
+void fatal (char *fmt, ...)
+{
+    va_list pvar;
+
+#if defined(__STDC__)
+    va_start(pvar, fmt);
+#else
+    char *fmt;
+    va_start(pvar);
+    fmt = va_arg(pvar, char *);
+#endif
+
+    vprintf( fmt, pvar);
+    va_end(pvar);
+
+    exit(1);			/* as promised */
+}
+
+void info (char *fmt, ...)
+{
+    va_list pvar;
+
+#if defined(__STDC__)
+    va_start(pvar, fmt);
+#else
+    char *fmt;
+    va_start(pvar);
+    fmt = va_arg(pvar, char *);
+#endif
+
+    vprintf( fmt, pvar);
+    va_end(pvar);
+
+}
+
+
+int main(int argc, char** argv){
+    int ret;
+    struct session *ses = (struct session *)malloc(sizeof(struct session));
+
+    if(!ses) return -1;
+
+    ret = relay_init_ses(ses,argv[1],argv[2]);
+    
+    if( ret < 0 ){
+	return -1;
+    }
+
+    ses->log_to_fd = 1;
+    ses->opt_debug=1;
+    while(1)
+	ret = session_connect(ses);
+    
+    
+    
+    return ret;
+
+
+}
--- work/ppp-2.4.9/pppd/plugins/pppoe/pppoe.h	2021-01-05 00:06:37.000000000 +0100
+++ work/ppp-2.4.9/pppd/plugins/pppoe/pppoe.h	2021-12-16 16:38:08.000000000 +0100
@@ -1,328 +1,279 @@
-/***********************************************************************
-*
-* pppoe.h
-*
-* Declaration of various PPPoE constants
-*
-* Copyright (C) 2000 Roaring Penguin Software Inc.
-*
-* This program may be distributed according to the terms of the GNU
-* General Public License, version 2 or (at your option) any later version.
-*
-* $Id: pppoe.h,v 1.4 2008/06/15 04:35:50 paulus Exp $
-*
-***********************************************************************/
-
-#include "config.h"
-
-#include <stdio.h>		/* For FILE */
-#include <sys/types.h>		/* For pid_t */
-#include <ctype.h>
-#include <string.h>
-
-#include "pppd/pppd.h"		/* For error */
-
-/* How do we access raw Ethernet devices? */
-#undef USE_LINUX_PACKET
-#undef USE_BPF
-
-#if defined(HAVE_NETPACKET_PACKET_H) || defined(HAVE_LINUX_IF_PACKET_H)
-#define USE_LINUX_PACKET 1
-#elif defined(HAVE_SYS_DLPI_H)
-#define USE_DLPI
-#elif defined(HAVE_NET_BPF_H)
-#define USE_BPF 1
-#endif
+/* PPPoE support library "libpppoe"
+ *
+ * Copyright 2000 Michal Ostrowski <mostrows@styx.uwaterloo.ca>,
+ *		  Jamal Hadi Salim <hadi@cyberus.ca>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ */
+
+#ifndef PPPOE_H
+#define PPPOE_H	1
+#include <stdio.h>		/* stdio               */
+#include <stdlib.h>		/* strtoul(), realloc() */
+#include <unistd.h>		/* STDIN_FILENO,exec    */
+#include <string.h>		/* memcpy()             */
+#include <errno.h>		/* errno                */
+#include <signal.h>
+#include <getopt.h>
+#include <stdarg.h>
+#include <syslog.h>
+#include <paths.h>
+
+#include <sys/types.h>		/* socket types         */
+#include <asm/types.h>
+#include <sys/time.h>
+#include <sys/wait.h>
+#include <sys/fcntl.h>
+#include <sys/ioctl.h>		/* ioctl()              */
+#include <sys/select.h>
+#include <sys/socket.h>		/* socket()             */
+#include <net/if.h>		/* ifreq struct         */
+#include <net/if_arp.h>
+#include <netinet/in.h>
 
-/* Sanity check */
-#if !defined(USE_BPF) && !defined(USE_LINUX_PACKET) && !defined(USE_DLPI)
-#error Unknown method for accessing raw Ethernet frames
+#if __GLIBC__ >= 2 && __GLIBC_MINOR >= 1
+#include <netpacket/packet.h>
+//#include <net/ethernet.h>
+#else
+#include <asm/types.h>
+#include <linux/if_packet.h>
+#include <linux/if_ether.h>
 #endif
 
-#ifdef HAVE_SYS_SOCKET_H
-#include <sys/socket.h>
-#endif
 
-/* This has to be included before Linux 4.8's linux/in.h
- * gets dragged in. */
-#include <netinet/in.h>
+#include <asm/byteorder.h>
 
-/* Ugly header files on some Linux boxes... */
-#if defined(HAVE_LINUX_IF_H)
-#include <linux/if.h>
-#elif defined(HAVE_NET_IF_H)
-#include <net/if.h>
-#endif
+/*
+  jamal: we really have to change this
+  to make it compatible to the 2.2 and
+  2.3 kernel
+*/
 
-#ifdef HAVE_NET_IF_TYPES_H
-#include <net/if_types.h>
-#endif
+#include <linux/if_pppox.h>
 
-#define BPF_BUFFER_IS_EMPTY 1
-#define BPF_BUFFER_HAS_DATA 0
 
-/* Define various integer types -- assumes a char is 8 bits */
-#if SIZEOF_UNSIGNED_SHORT == 2
-typedef unsigned short UINT16_t;
-#elif SIZEOF_UNSIGNED_INT == 2
-typedef unsigned int UINT16_t;
-#else
-#error Could not find a 16-bit integer type
+#define CONNECTED 1
+#define DISCONNECTED 0
+
+#ifndef _PATH_PPPD
+#define _PATH_PPPD "/usr/sbin/pppd"
 #endif
 
-#if SIZEOF_UNSIGNED_SHORT == 4
-typedef unsigned short UINT32_t;
-#elif SIZEOF_UNSIGNED_INT == 4
-typedef unsigned int UINT32_t;
-#elif SIZEOF_UNSIGNED_LONG == 4
-typedef unsigned long UINT32_t;
-#else
-#error Could not find a 32-bit integer type
+#ifndef LOG_PPPOE
+#define LOG_PPPOE LOG_DAEMON
 #endif
 
-#ifdef HAVE_LINUX_IF_ETHER_H
-#include <linux/if_ether.h>
-#else
+#ifdef _RECORD_SID_
+#include "nvram_var.h"
+#include "nvram.h"
+#endif
 
-#ifdef HAVE_NETINET_IF_ETHER_H
-#include <sys/types.h>
+#define VERSION_MAJOR 0
+#define VERSION_MINOR 4
+#define VERSION_DATE 991120
+
+/* Bigger than the biggest ethernet packet we'll ever see, in bytes */
+#define MAX_PACKET      2000
+
+/* references: RFC 2516 */
+/* ETHER_TYPE fields for PPPoE */
+
+#define ETH_P_PPPOE_DISC 0x8863	/* discovery stage */
+#define ETH_P_PPPOE_SESS 0x8864
+
+/* ethernet broadcast address */
+#define MAC_BCAST_ADDR "\xff\xff\xff\xff\xff\xff"
+
+/* Format for parsing long device-name */
+#define _STR(x) #x
+#define FMTSTRING(size) "%x:%x:%x:%x:%x:%x/%x/%" _STR(size) "s"
+
+/* maximum payload length */
+#define MAX_PAYLOAD 1484
 
-#ifdef HAVE_SYS_SOCKET_H
-#include <sys/socket.h>
-#endif
-#ifndef HAVE_SYS_DLPI_H
-#include <netinet/if_ether.h>
-#endif
-#endif
-#endif
 
-/* Ethernet frame types according to RFC 2516 */
-#define ETH_PPPOE_DISCOVERY 0x8863
-#define ETH_PPPOE_SESSION   0x8864
-
-/* But some brain-dead peers disobey the RFC, so frame types are variables */
-extern UINT16_t Eth_PPPOE_Discovery;
-extern UINT16_t Eth_PPPOE_Session;
-
-/* PPPoE codes */
-#define CODE_PADI           0x09
-#define CODE_PADO           0x07
-#define CODE_PADR           0x19
-#define CODE_PADS           0x65
-#define CODE_PADT           0xA7
-
-/* Extensions from draft-carrel-info-pppoe-ext-00 */
-/* I do NOT like PADM or PADN, but they are here for completeness */
-#define CODE_PADM           0xD3
-#define CODE_PADN           0xD4
-
-#define CODE_SESS           0x00
-
-/* PPPoE Tags */
-#define TAG_END_OF_LIST        0x0000
-#define TAG_SERVICE_NAME       0x0101
-#define TAG_AC_NAME            0x0102
-#define TAG_HOST_UNIQ          0x0103
-#define TAG_AC_COOKIE          0x0104
-#define TAG_VENDOR_SPECIFIC    0x0105
-#define TAG_RELAY_SESSION_ID   0x0110
-#define TAG_PPP_MAX_PAYLOAD    0x0120
-#define TAG_SERVICE_NAME_ERROR 0x0201
-#define TAG_AC_SYSTEM_ERROR    0x0202
-#define TAG_GENERIC_ERROR      0x0203
-
-/* Extensions from draft-carrel-info-pppoe-ext-00 */
-/* I do NOT like these tags one little bit */
-#define TAG_HURL               0x111
-#define TAG_MOTM               0x112
-#define TAG_IP_ROUTE_ADD       0x121
-
-/* Discovery phase states */
-#define STATE_SENT_PADI     0
-#define STATE_RECEIVED_PADO 1
-#define STATE_SENT_PADR     2
-#define STATE_SESSION       3
-#define STATE_TERMINATED    4
-
-/* How many PADI/PADS attempts? */
-#define MAX_PADI_ATTEMPTS 3
-
-/* Initial timeout for PADO/PADS */
-#define PADI_TIMEOUT 5
-
-/* States for scanning PPP frames */
-#define STATE_WAITFOR_FRAME_ADDR 0
-#define STATE_DROP_PROTO         1
-#define STATE_BUILDING_PACKET    2
-
-/* Special PPP frame characters */
-#define FRAME_ESC    0x7D
-#define FRAME_FLAG   0x7E
-#define FRAME_ADDR   0xFF
-#define FRAME_CTRL   0x03
-#define FRAME_ENC    0x20
-
-#define IPV4ALEN     4
-#define SMALLBUF   256
-
-/* There are other fixed-size buffers preventing
-   this from being increased to 16110. The buffer
-   sizes would need to be properly de-coupled from
-   the default MRU. For now, getting up to 1500 is
-   enough. */
-#define ETH_JUMBO_LEN 1508
-
-/* A PPPoE Packet, including Ethernet headers */
-typedef struct PPPoEPacketStruct {
-    struct ethhdr ethHdr;	/* Ethernet header */
-    unsigned int vertype:8;	/* PPPoE Version and Type (must both be 1) */
-    unsigned int code:8;	/* PPPoE code */
-    unsigned int session:16;	/* PPPoE session */
-    unsigned int length:16;	/* Payload length */
-    unsigned char payload[ETH_JUMBO_LEN]; /* A bit of room to spare */
-} PPPoEPacket;
-
-#define PPPOE_VER(vt)		((vt) >> 4)
-#define PPPOE_TYPE(vt)		((vt) & 0xf)
-#define PPPOE_VER_TYPE(v, t)	(((v) << 4) | (t))
-
-/* Header size of a PPPoE packet */
-#define PPPOE_OVERHEAD 6  /* type, code, session, length */
-#define HDR_SIZE (sizeof(struct ethhdr) + PPPOE_OVERHEAD)
-#define MAX_PPPOE_PAYLOAD (ETH_JUMBO_LEN - PPPOE_OVERHEAD)
-#define PPP_OVERHEAD 2  /* protocol */
-#define MAX_PPPOE_MTU (MAX_PPPOE_PAYLOAD - PPP_OVERHEAD)
-#define TOTAL_OVERHEAD (PPPOE_OVERHEAD + PPP_OVERHEAD)
-#define ETH_PPPOE_MTU (ETH_DATA_LEN - TOTAL_OVERHEAD)
-
-/* PPPoE Tag */
-
-typedef struct PPPoETagStruct {
-    unsigned int type:16;	/* tag type */
-    unsigned int length:16;	/* Length of payload */
-    unsigned char payload[ETH_JUMBO_LEN]; /* A LOT of room to spare */
-} PPPoETag;
-/* Header size of a PPPoE tag */
-#define TAG_HDR_SIZE 4
-
-/* Chunk to read from stdin */
-#define READ_CHUNK 4096
-
-/* Function passed to parsePacket */
-typedef void ParseFunc(UINT16_t type,
-		       UINT16_t len,
-		       unsigned char *data,
-		       void *extra);
-
-#define PPPINITFCS16    0xffff  /* Initial FCS value */
-
-/* Keep track of the state of a connection -- collect everything in
-   one spot */
-
-typedef struct PPPoEConnectionStruct {
-    int discoveryState;		/* Where we are in discovery */
-    int discoverySocket;	/* Raw socket for discovery frames */
-    int sessionSocket;		/* Raw socket for session frames */
-    unsigned char myEth[ETH_ALEN]; /* My MAC address */
-    unsigned char peerEth[ETH_ALEN]; /* Peer's MAC address */
-    unsigned char req_peer_mac[ETH_ALEN]; /* required peer MAC address */
-    unsigned char req_peer;	/* require mac addr to match req_peer_mac */
-    UINT16_t session;		/* Session ID */
-    char *ifName;		/* Interface name */
-    char *serviceName;		/* Desired service name, if any */
-    char *acName;		/* Desired AC name, if any */
-    int synchronous;		/* Use synchronous PPP */
-    PPPoETag hostUniq;		/* Use Host-Uniq tag */
-    int printACNames;		/* Just print AC names */
-    FILE *debugFile;		/* Debug file for dumping packets */
-    int numPADOs;		/* Number of PADO packets received */
-    PPPoETag cookie;		/* We have to send this if we get it */
-    PPPoETag relayId;		/* Ditto */
-    int error;			/* Error packet received */
-    int debug;			/* Set to log packets sent and received */
-    int discoveryTimeout;       /* Timeout for discovery packets */
-    int discoveryAttempts;      /* Number of discovery attempts */
-    int seenMaxPayload;
-    int mtu;			/* Stored MTU */
-    int mru;			/* Stored MRU */
-} PPPoEConnection;
-
-/* Structure used to determine acceptable PADO or PADS packet */
-struct PacketCriteria {
-    PPPoEConnection *conn;
-    int acNameOK;
-    int serviceNameOK;
-    int seenACName;
-    int seenServiceName;
+
+/* PPPoE tag types */
+#define MAX_TAGS		11
+
+
+/* PPPoE packet; includes Ethernet headers and such */
+struct pppoe_packet{
+	struct sockaddr_ll addr;
+	struct pppoe_tag *tags[MAX_TAGS];
+	struct pppoe_hdr *hdr;
+	char buf[MAX_PAYLOAD];		/* buffer in which tags are held */
+};
+/* Defines meaning of each "tags" element */
+
+#define TAG_SRV_NAME	0
+#define TAG_AC_NAME	1
+#define TAG_HOST_UNIQ	2
+#define TAG_AC_COOKIE	3
+#define TAG_VENDOR 	4
+#define TAG_RELAY_SID	5
+#define TAG_SRV_ERR     6
+#define TAG_SYS_ERR  	7
+#define TAG_GEN_ERR  	8
+#define TAG_EOL		9
+
+/* Debug flags */
+int DEB_DISC,DEB_DISC2;
+/*
+  #define DEB_DISC		(opt_debug & 0x0002)
+  #define DEB_DISC2		(opt_debug & 0x0004)
+*/
+#define MAX_FNAME		256
+
+
+struct session;
+
+/* return <0 --> fatal error; abor
+   return =0 --> ok, proceed
+   return >0 --> ok, qui
+*/
+typedef int (*packet_cb_t)(struct session* ses,
+			   struct pppoe_packet *p_in,
+			   struct pppoe_packet **p_out);
+
+/* various override filter tags */
+struct filter {
+	struct pppoe_tag *stag;  /* service name tag override */
+	struct pppoe_tag *ntag;  /*AC name override */
+	struct pppoe_tag *htag;  /* hostuniq override */
+	int num_restart;
+	int peermode;
+	char *fname;
+	char *pppd;
+} __attribute__ ((packed));
+
+
+struct pppoe_tag *make_filter_tag(short type, short length, char* data);
+
+/* Session type definitions */
+#define SESSION_CLIENT	0
+#define SESSION_SERVER	1
+#define SESSION_RELAY	2
+
+struct session {
+
+	/* Administrative */
+	int type;
+	int opt_debug;
+	int detached;
+	int np;
+	int log_to_fd;
+	int ifindex;			/* index of device */
+	char name[IFNAMSIZ];		/*dev name */
+	struct pppoe_packet curr_pkt;
+
+	packet_cb_t init_disc;
+	packet_cb_t rcv_pado;
+	packet_cb_t rcv_padi;
+	packet_cb_t rcv_pads;
+	packet_cb_t rcv_padr;
+	packet_cb_t rcv_padt;
+	packet_cb_t timeout;
+
+
+	/* Generic */
+	struct filter *filt;
+	struct sockaddr_ll local;
+	struct sockaddr_ll remote;
+	struct sockaddr_pppox sp;
+	int fd;				/* fd of PPPoE socket */
+
+
+	/* For client */
+	int retransmits;		/* Number of retransmission performed
+					   if < 0 , retransmissions disabled */
+	int retries;
+	int state;
+	int opt_daemonize;
+
+	/* For server */
+	int fork;
+
+	/* For forwarding */
+	int fwd_sock;
+	char fwd_name[IFNAMSIZ];	/* Name of device to forward to */
+} __attribute__ ((packed));
+
+/*
+  retransmit retries for the PADR and PADI packets
+  during discovery
+*/
+int PADR_ret;
+int PADI_ret;
+
+int log_to_fd;
+int ctrl_fd;
+int opt_debug;
+int opt_daemonize;
+
+
+/* Structure for keeping track of connection relays */
+struct pppoe_con{
+	struct pppoe_con *next;
+	int id;
+	int connected;
+	int  cl_sock;
+	int  sv_sock;
+	int ref_count;
+	char client[ETH_ALEN];
+	char server[ETH_ALEN];
+	char key_len;
+	char key[32];
 };
 
-/* Function Prototypes */
-UINT16_t etherType(PPPoEPacket *packet);
-int openInterface(char const *ifname, UINT16_t type, unsigned char *hwaddr);
-int sendPacket(PPPoEConnection *conn, int sock, PPPoEPacket *pkt, int size);
-int receivePacket(int sock, PPPoEPacket *pkt, int *size);
-void fatalSys(char const *str);
-void dumpPacket(FILE *fp, PPPoEPacket *packet, char const *dir);
-void dumpHex(FILE *fp, unsigned char const *buf, int len);
-int parsePacket(PPPoEPacket *packet, ParseFunc *func, void *extra);
-void parseLogErrs(UINT16_t typ, UINT16_t len, unsigned char *data, void *xtra);
-void syncReadFromPPP(PPPoEConnection *conn, PPPoEPacket *packet);
-void asyncReadFromPPP(PPPoEConnection *conn, PPPoEPacket *packet);
-void asyncReadFromEth(PPPoEConnection *conn, int sock, int clampMss);
-void syncReadFromEth(PPPoEConnection *conn, int sock, int clampMss);
-char *strDup(char const *str);
-void sendPADT(PPPoEConnection *conn, char const *msg);
-void sendSessionPacket(PPPoEConnection *conn,
-		       PPPoEPacket *packet, int len);
-void initPPP(void);
-void clampMSS(PPPoEPacket *packet, char const *dir, int clampMss);
-UINT16_t computeTCPChecksum(unsigned char *ipHdr, unsigned char *tcpHdr);
-UINT16_t pppFCS16(UINT16_t fcs, unsigned char *cp, int len);
-void discovery(PPPoEConnection *conn);
-unsigned char *findTag(PPPoEPacket *packet, UINT16_t tagType,
-		       PPPoETag *tag);
-
-void pppoe_printpkt(PPPoEPacket *packet,
-		    void (*printer)(void *, char *, ...), void *arg);
-void pppoe_log_packet(const char *prefix, PPPoEPacket *packet);
-
-static inline int parseHostUniq(const char *uniq, PPPoETag *tag)
-{
-    unsigned i, len = strlen(uniq);
-
-#define hex(x) \
-    (((x) <= '9') ? ((x) - '0') : \
-        (((x) <= 'F') ? ((x) - 'A' + 10) : \
-            ((x) - 'a' + 10)))
-
-    if (!len || len % 2 || len / 2 > sizeof(tag->payload))
-        return 0;
-
-    for (i = 0; i < len; i += 2) {
-        if (!isxdigit(uniq[i]) || !isxdigit(uniq[i+1]))
-            return 0;
-
-        tag->payload[i / 2] = (char)(hex(uniq[i]) << 4 | hex(uniq[i+1]));
-    }
-
-#undef hex
-
-    tag->type = htons(TAG_HOST_UNIQ);
-    tag->length = htons(len / 2);
-    return 1;
-}
-
-#define SET_STRING(var, val) do { if (var) free(var); var = strDup(val); } while(0);
-
-#define CHECK_ROOM(cursor, start, len) \
-do {\
-    if (((cursor)-(start))+(len) > MAX_PPPOE_PAYLOAD) { \
-	error("Would create too-long packet");	\
-        return; \
-    } \
-} while(0)
-
-/* True if Ethernet address is broadcast or multicast */
-#define NOT_UNICAST(e) ((e[0] & 0x01) != 0)
-#define BROADCAST(e) ((e[0] & e[1] & e[2] & e[3] & e[4] & e[5]) == 0xFF)
-#define NOT_BROADCAST(e) ((e[0] & e[1] & e[2] & e[3] & e[4] & e[5]) != 0xFF)
+/* Functions exported from utils.c. */
+
+/* Functions exported from pppoehash.c */
+struct pppoe_con *get_con(int len, char *key);
+int store_con(struct pppoe_con *pc);
+struct pppoe_con *delete_con(unsigned long len, char *key);
+
+/* exported by lib.c */
+
+extern int init_lib();
+
+extern int get_sockaddr_ll(const char *devnam,struct sockaddr_ll* sll);
+
+extern int client_init_ses (struct session *ses, char* devnam);
+extern int relay_init_ses(struct session *ses, char* from, char* to);
+extern int srv_init_ses(struct session *ses, char* from);
+extern int session_connect(struct session *ses);
+extern int session_disconnect(struct session*ses);
+
+extern int verify_packet( struct session *ses, struct pppoe_packet *p);
+
+extern void copy_tag(struct pppoe_packet *dest, struct pppoe_tag *pt);
+extern struct pppoe_tag *get_tag(struct pppoe_hdr *ph, u_int16_t idx);
+extern int send_disc(struct session *ses, struct pppoe_packet *p);
+#ifdef _RECORD_SID_
+extern int send_padt(struct session *ses, struct pppoe_packet *p);
+#endif /* _RECORD_SID_ */
+
+extern int add_client(char *addr);
+
+/* Make connections (including spawning pppd) as server/client */
+extern int ppp_connect(struct session *ses);
+
+void poe_die (int status);
+void poe_fatal (struct session *ses, char *fmt,...);
+void poe_error (struct session *ses,char *fmt,...);
+void poe_warn (struct session *ses,char *fmt,...);
+void poe_info (struct session *ses,char *fmt,...);
+void error (char *fmt, ...);
+void poe_dbglog (struct session *ses ,char *fmt,...);
+
+#ifdef MULTI_OFFER
+extern void InitBlacklist(); // defined in pppoe_client.c file;
+extern int addToBlacklist(unsigned char *addr); // defind in pppoe_client.c file.
+extern void removefromBlacklist(unsigned char *addr);
+#endif /* MULTI_OFFER */
+
+#endif
--- work/ppp-2.4.9/pppd/plugins/pppoe/pppoehash.c	1970-01-01 01:00:00.000000000 +0100
+++ work/ppp-2.4.9/pppd/plugins/pppoe/pppoehash.c	2021-12-16 16:38:08.000000000 +0100
@@ -0,0 +1,91 @@
+/* PPPoE support library "libpppoe"
+ *
+ * Copyright 2000 Michal Ostrowski <mostrows@styx.uwaterloo.ca>,
+ *		  Jamal Hadi Salim <hadi@cyberus.ca>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ */
+#include "pppoe.h"
+
+
+#define PPPOE_HASH_SIZE 16
+
+
+static inline int keycmp(char *a, char *b, int x, int y){
+    return x==y && !memcmp(a,b,x);
+}
+
+static int hash_con(int key_len, char* key)
+{
+    int i = 0;
+    char hash[sizeof(int)]={0,};
+
+    for (i = 0; i < key_len ; ++i)
+	hash[i% sizeof(int)] = hash[i%sizeof(int)] ^ key[i];
+
+    i = (*((int*)hash)) ;
+    i &= PPPOE_HASH_SIZE - 1;
+
+    return i;
+}	
+
+static struct pppoe_con *con_ht[PPPOE_HASH_SIZE] = { 0, };
+
+struct pppoe_con *get_con(int len, char *key)
+{
+    int hash = hash_con(len, key);
+    struct pppoe_con *ret;
+
+    ret = con_ht[hash];
+
+    while (ret && !keycmp(ret->key,key, ret->key_len, len))
+	ret = ret->next;
+
+    return ret;
+}
+
+int store_con(struct pppoe_con *pc)
+{
+    int hash = hash_con(pc->key_len, pc->key);
+    struct pppoe_con *ret;
+
+    ret = con_ht[hash];
+    while (ret) {
+	if (!keycmp(ret->key, pc->key, ret->key_len, pc->key_len))
+	    return -EALREADY;
+	
+	ret = ret->next;
+    }
+
+    if (!ret) {
+	pc->next = con_ht[hash];
+	con_ht[hash] = pc;
+    }
+
+    return 0;
+}
+
+struct pppoe_con *delete_con(unsigned long len, char *key)
+{
+    int hash = hash_con(len, key);
+    struct pppoe_con *ret, **src;
+
+    ret = con_ht[hash];
+    src = &con_ht[hash];
+
+    while (ret) {
+	if (keycmp(ret->key,key, ret->key_len, len)) {
+	    *src = ret->next;
+	    break;
+	}
+	
+	src = &ret->next;
+	ret = ret->next;
+    }
+
+    return ret;
+}
+
--- work/ppp-2.4.9/pppd/plugins/pppoe/pppoe_relay.c	1970-01-01 01:00:00.000000000 +0100
+++ work/ppp-2.4.9/pppd/plugins/pppoe/pppoe_relay.c	2021-12-16 16:38:08.000000000 +0100
@@ -0,0 +1,260 @@
+/* PPPoE support library "libpppoe"
+ *
+ * Copyright 2000 Michal Ostrowski <mostrows@styx.uwaterloo.ca>,
+ *		  Jamal Hadi Salim <hadi@cyberus.ca>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ */
+
+#include "pppoe.h"
+
+static int relay_init_disc(struct session* ses,
+			   struct pppoe_packet *p_in,
+			   struct pppoe_packet **p_out){
+
+    ses->state = 0;
+    ses->retransmits = -1 ;
+    ses->retries = -1;
+
+    (*p_out) = NULL;
+    return 0;
+}
+
+static int pcid=0;
+static int relay_rcv_padi(struct session* ses,
+			  struct pppoe_packet *p_in,
+			  struct pppoe_packet **p_out){
+    char tag_buf[32];
+    struct pppoe_con *newpc = NULL;
+    struct pppoe_tag *tag = (struct pppoe_tag *) tag_buf;
+
+
+    tag->tag_type = PTT_RELAY_SID;
+    tag->tag_len  = htons(ETH_ALEN + sizeof(struct session *));
+
+    memcpy(tag->tag_data, p_in->addr.sll_addr, ETH_ALEN);
+    memcpy(tag->tag_data + ETH_ALEN, &ses, sizeof(struct session *));
+
+    if(! p_in->tags[TAG_RELAY_SID] ){
+	copy_tag(p_in, tag);
+    }
+
+
+    poe_dbglog(ses, "Recv'd PADI: %P",p_in);
+    poe_dbglog(ses, "Recv'd packet: %P",p_in);
+    newpc = get_con( ntohs(tag->tag_len), tag->tag_data );
+    if(!newpc){
+	
+	newpc = (struct pppoe_con *) malloc(sizeof(struct pppoe_con));
+	memset(newpc , 0, sizeof(struct pppoe_con));
+	
+	newpc->id = pcid++;
+	
+	newpc->key_len = ntohs(p_in->tags[TAG_RELAY_SID]->tag_len);
+	memcpy(newpc->key, p_in->tags[TAG_RELAY_SID]->tag_data, newpc->key_len);
+	memcpy(newpc->client, p_in->addr.sll_addr, ETH_ALEN);
+	
+	memcpy(newpc->server, MAC_BCAST_ADDR, ETH_ALEN);
+	
+	store_con(newpc);
+	
+    }
+
+    ++newpc->ref_count;
+
+    memset(p_in->addr.sll_addr, 0xff, ETH_ALEN);
+
+    p_in->addr.sll_ifindex = ses->remote.sll_ifindex;
+
+    send_disc(ses, p_in);
+    return 0;
+}
+
+static int relay_rcv_pkt(struct session* ses,
+			 struct pppoe_packet *p_in,
+			 struct pppoe_packet **p_out){
+    struct pppoe_con *pc;
+    struct pppoe_tag *tag = p_in->tags[TAG_RELAY_SID];
+
+    if( !tag ) return 0;
+
+    pc = get_con(ntohs(tag->tag_len),tag->tag_data);
+
+    if( !pc ) return 0;
+
+    poe_dbglog(ses, "Recv'd packet: %P",p_in);
+
+    if( memcmp(pc->client , p_in->addr.sll_addr , ETH_ALEN ) == 0 ){
+	
+	memcpy(p_in->addr.sll_addr, pc->server, ETH_ALEN);
+	p_in->addr.sll_ifindex = ses->remote.sll_ifindex;
+	
+    }else{
+	if( memcmp(pc->server, MAC_BCAST_ADDR, ETH_ALEN) == 0 ){
+	    memcpy(pc->server, p_in->addr.sll_addr, ETH_ALEN);
+	
+	}else if( memcmp(pc->server, p_in->addr.sll_addr, ETH_ALEN) !=0){
+	    return 0;
+	}
+	
+	memcpy(p_in->addr.sll_addr, pc->client, ETH_ALEN);
+	p_in->addr.sll_ifindex = ses->local.sll_ifindex;
+	
+	
+    }
+
+
+    send_disc(ses, p_in);
+    return 0;
+}
+
+static int relay_rcv_pads(struct session* ses,
+			  struct pppoe_packet *p_in,
+			  struct pppoe_packet **p_out){
+
+    struct pppoe_con *pc;
+    struct pppoe_tag *tag = p_in->tags[TAG_RELAY_SID];
+    struct sockaddr_pppox sp_cl= { AF_PPPOX, PX_PROTO_OE,
+				   { {p_in->hdr->sid, {0,},{0,}}}};
+
+    struct sockaddr_pppox sp_sv= { AF_PPPOX, PX_PROTO_OE,
+				   { {p_in->hdr->sid, {0,},{0,}}}};
+
+    int ret;
+
+
+    if( !tag ) return 0;
+
+    pc = get_con(ntohs(tag->tag_len),tag->tag_data);
+
+    if( !pc ) return 0;
+
+
+    if(!pc->connected){
+	
+	pc->sv_sock = socket( AF_PPPOX, SOCK_DGRAM, PX_PROTO_OE);
+	if( pc->sv_sock < 0){
+	    poe_fatal(ses,"Cannot open PPPoE socket: %i",errno);
+	}
+	
+	pc->cl_sock = socket( AF_PPPOX, SOCK_DGRAM, PX_PROTO_OE);
+	if( pc->cl_sock < 0){
+	    poe_fatal(ses,"Cannot open PPPoE socket: %i",errno);
+	}
+	
+	memcpy( sp_sv.sa_addr.pppoe.dev, ses->fwd_name, IFNAMSIZ);
+	memcpy( sp_sv.sa_addr.pppoe.remote, pc->server, ETH_ALEN);
+	
+	ret = connect( pc->sv_sock,
+		       (struct sockaddr*)&sp_sv,
+		       sizeof(struct sockaddr_pppox));
+	if( ret < 0){
+	    poe_fatal(ses,"Cannot connect PPPoE socket: %i",errno);
+	}
+	
+	memcpy( sp_cl.sa_addr.pppoe.dev, ses->name, IFNAMSIZ);
+	memcpy( sp_cl.sa_addr.pppoe.remote, pc->client, ETH_ALEN);
+	
+	ret = connect( pc->cl_sock,
+		       (struct sockaddr*)&sp_cl,
+		       sizeof(struct sockaddr_pppox));
+	if( ret < 0){
+	    poe_fatal(ses,"Cannot connect PPPoE socket: %i",errno);
+	}
+	
+	
+	ret = ioctl( pc->sv_sock, PPPOEIOCSFWD, &sp_cl);
+	if( ret < 0){
+	    poe_fatal(ses,"Cannot set forwarding on PPPoE socket: %i",errno);
+	}
+	
+	ret = ioctl( pc->cl_sock, PPPOEIOCSFWD, &sp_sv);
+	if( ret < 0){
+	    poe_fatal(ses,"Cannot set forwarding on PPPoE socket: %i",errno);
+	}
+	
+	pc->connected = 1;
+    }
+
+    poe_info(ses,"PPPoE relay for %E established to %E (sid=%04x)\n",
+	     pc->client,pc->server, p_in->hdr->sid);
+
+    return relay_rcv_pkt(ses,p_in,p_out);
+}
+
+
+static int relay_rcv_padt(struct session* ses,
+			  struct pppoe_packet *p_in,
+			  struct pppoe_packet **p_out){
+
+    int ret;
+    struct pppoe_con *pc;
+    struct pppoe_tag *tag = p_in->tags[TAG_RELAY_SID];
+
+    if( !tag ) return 0;
+
+    pc = get_con(ntohs(tag->tag_len),tag->tag_data);
+
+    if( !pc ) return 0;
+
+    ret = relay_rcv_pkt(ses,p_in,p_out);
+
+
+    if(pc->cl_sock>0){
+	close(pc->cl_sock);
+    }
+
+    if(pc->sv_sock>0){
+	close(pc->sv_sock);
+    }
+
+    --pc->ref_count;
+    if( pc->ref_count == 0 ){
+	delete_con(pc->key_len, pc->key);
+	
+	free(pc);
+    }
+    return 0;
+}
+
+
+int relay_init_ses(struct session *ses, char* from, char* to)
+{
+    int retval = client_init_ses(ses, from);
+
+    if(retval<0) return retval;
+
+    ses->fwd_sock =  socket(PF_PACKET, SOCK_DGRAM, 0);
+    if( ses->fwd_sock < 0 ) {
+	poe_fatal(ses,"Cannot create PF_PACKET socket for PPPoE forwarding\n");
+    }
+
+    /* Verify the device name , construct ses->local */
+    retval = get_sockaddr_ll(to, &ses->remote);
+    if (retval < 0)
+	poe_fatal(ses,"relay_init_ses:get_sockaddr_ll failed %m");
+
+    retval = bind( ses->fwd_sock ,
+		   (struct sockaddr*)&ses->remote,
+		   sizeof(struct sockaddr_ll));
+
+    if( retval < 0 ){
+	poe_fatal(ses,"bind to PF_PACKET socket failed: %m");
+    }
+
+    memcpy(ses->fwd_name, to, IFNAMSIZ);
+    memcpy(ses->name, from, IFNAMSIZ);
+
+
+    ses->init_disc = relay_init_disc;
+    ses->rcv_padi  = relay_rcv_padi;
+    ses->rcv_pado  = relay_rcv_pkt;
+    ses->rcv_padr  = relay_rcv_pkt;
+    ses->rcv_pads  = relay_rcv_pads;
+    ses->rcv_padt  = relay_rcv_padt;
+    return 0;
+}
+
--- work/ppp-2.4.9/pppd/plugins/pppoe/pppoe_server.c	1970-01-01 01:00:00.000000000 +0100
+++ work/ppp-2.4.9/pppd/plugins/pppoe/pppoe_server.c	2021-12-16 16:38:08.000000000 +0100
@@ -0,0 +1,140 @@
+/* PPPoE support library "libpppoe"
+ *
+ * Copyright 2000 Michal Ostrowski <mostrows@styx.uwaterloo.ca>,
+ *		  Jamal Hadi Salim <hadi@cyberus.ca>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ */
+#include "pppoe.h"
+#include <unistd.h>
+
+static unsigned int pcid=1111;
+static int srv_rcv_padi(struct session* ses, 
+			struct pppoe_packet *p_in,
+			struct pppoe_packet **p_out){
+    struct pppoe_tag *tag;
+    
+    poe_dbglog(ses,"Srv Recv'd packet: %P\n",p_in);
+    
+    
+    ses->curr_pkt.hdr = (struct pppoe_hdr*) ses->curr_pkt.buf;
+    ses->curr_pkt.hdr->ver  = 1;
+    ses->curr_pkt.hdr->type = 1;
+
+    tag = get_tag(p_in->hdr,PTT_SRV_NAME);
+
+    if(!tag )
+	return 0;
+
+    if( ntohs(tag->tag_len)==0 ){
+	ses->curr_pkt.tags[TAG_SRV_NAME] = ses->filt->stag ;
+    }else if( tag->tag_len != ses->filt->stag->tag_len
+	      || !memcmp( tag+1, ses->filt->stag, ntohs(tag->tag_len)) ){
+	return 0;
+    }else{
+	ses->curr_pkt.tags[TAG_SRV_NAME] = tag;
+    }
+
+    ses->curr_pkt.tags[ TAG_AC_NAME] = ses->filt->ntag ;
+    ses->curr_pkt.tags[ TAG_HOST_UNIQ ] = get_tag(p_in->hdr,PTT_HOST_UNIQ);
+    
+    memcpy(&ses->remote, &p_in->addr, sizeof(struct sockaddr_ll));
+    memcpy( &ses->curr_pkt.addr, &ses->remote , sizeof(struct sockaddr_ll));
+    
+    ses->curr_pkt.hdr->code =  PADO_CODE;
+    
+    
+    ses->curr_pkt.tags[ TAG_RELAY_SID ] = get_tag(p_in->hdr,PTT_RELAY_SID);
+
+    send_disc(ses, &ses->curr_pkt);
+    poe_dbglog(ses,"Srv Sent packet: %P\n",&ses->curr_pkt);
+    
+    return 0;
+}
+
+
+static int srv_rcv_padr(struct session* ses, 
+			struct pppoe_packet *p_in,
+			struct pppoe_packet **p_out){
+    struct pppoe_tag *tag;
+
+    poe_dbglog(ses,"Recv'd packet: %P\n",p_in);
+    
+
+
+    /* Run checks to ensure this packets asks for 
+       what we're willing to offer */
+
+    tag = get_tag(p_in->hdr,PTT_SRV_NAME);
+
+    if(!tag || tag->tag_len == 0 ){
+	p_in->tags[TAG_SRV_NAME] = ses->filt->stag;
+
+    }else if( tag->tag_len != ses->filt->stag->tag_len
+	     || !memcmp(tag + 1 , ses->filt->stag, ntohs(tag->tag_len)) ){
+	return 0;
+    }else{
+	p_in->tags[TAG_SRV_NAME] = tag;
+    }
+
+    tag = get_tag(p_in->hdr,PTT_AC_NAME);
+    if( !tag || tag->tag_len==0 ){
+	p_in->tags[TAG_AC_NAME] = ses->filt->ntag;
+    }else if( tag->tag_len != ses->filt->ntag->tag_len
+	  || !memcmp(tag + 1, ses->filt->ntag, ntohs(tag->tag_len)) ){
+	return 0;
+    }else{
+	p_in->tags[TAG_AC_NAME] = tag;
+    }
+
+    pcid++;
+    pcid &= 0x0000ffff ;
+    if(pcid == 0 ){
+	pcid = 1111;
+    }
+    
+    p_in->hdr->sid  = ntohs(pcid);
+    
+    p_in->hdr->code = PADS_CODE;
+    send_disc(ses, p_in);
+    
+    poe_dbglog(ses,"Sent packet: %P\n",p_in);
+    
+    ses->sp.sa_family = AF_PPPOX;
+    ses->sp.sa_protocol=PX_PROTO_OE;
+    ses->sp.sa_addr.pppoe.sid = p_in->hdr->sid;
+    memcpy(ses->sp.sa_addr.pppoe.dev, ses->name, IFNAMSIZ);
+    memcpy(ses->sp.sa_addr.pppoe.remote, p_in->addr.sll_addr, ETH_ALEN);
+    memcpy(&ses->remote, &p_in->addr, sizeof(struct sockaddr_ll));
+    return 1;
+}
+
+static int srv_rcv_padt(struct session* ses, 
+			struct pppoe_packet *p_in,
+			struct pppoe_packet **p_out){
+    return 0;
+}
+
+
+
+int srv_init_ses(struct session *ses, char* from)
+{
+    int retval;
+    retval = client_init_ses(ses, from);
+    ses->init_disc = NULL;
+    ses->rcv_pado  = NULL;
+    ses->rcv_pads  = NULL;
+    ses->rcv_padi  = srv_rcv_padi;
+    ses->rcv_padr  = srv_rcv_padr;
+    ses->rcv_padt  = srv_rcv_padt;
+
+    /* retries forever */
+    ses->retries   = -1;
+
+    return retval;
+}
+
+
--- work/ppp-2.4.9/pppd/plugins/pppoe/utils.c	1970-01-01 01:00:00.000000000 +0100
+++ work/ppp-2.4.9/pppd/plugins/pppoe/utils.c	2021-12-16 16:38:08.000000000 +0100
@@ -0,0 +1,669 @@
+
+/*
+ * utils.c - various utility functions used in pppoed.
+ *
+ * mostly stolen from ppp-2.3.10 by Marc Boucher <marc@mbsi.ca>
+ *
+ * Feb 18/2000 Made fully re-entrant (JHS)
+ *
+ * Copyright (c) 1999 The Australian National University.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright poe_notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by the Australian National University.  The name of the University
+ * may not be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <stdio.h>		/* stdio               */
+#include <stdlib.h>		/* strtoul(), realloc() */
+#include <string.h>		/* memcpy()             */
+#include <unistd.h>		/* STDIN_FILENO,exec    */
+#include <errno.h>		/* errno                */
+
+#include <sys/time.h>
+
+#include <net/ethernet.h>
+#include <netinet/in.h>
+
+#include <stdarg.h>
+#include <ctype.h>
+#include <syslog.h>
+#include <limits.h>
+#include <paths.h>
+
+#include "pppoe.h"
+#define PID_PATH_MAX 256
+static char pidfilename[PID_PATH_MAX];	/* name of pid file */
+
+/*
+static int detached = 0;
+   log_to_fd = -1;
+ */
+
+static void vslp_printer (void *, char *,...);
+static void format_packet (struct pppoe_packet *, int, void (*)(void *, char *,...), void *);
+static void format_tag (struct pppoe_tag *, void (*)(void *, char *,...), void *);
+struct buffer_poe_info {
+  char *ptr;
+  int len;
+};
+
+void poe_die (int status);
+
+
+/*
+ * vpoe_slprintf - like vsprintf, except we
+ * also specify the length of the output buffer, and we handle
+ * %r (recursive format), %m (poe_error message), %v (visible string),
+ * %q (quoted string), %t (current time) and %E (Ether address) formats.
+ * Doesn't do floating-point formats.
+ * Returns the number of chars put into buf.
+ */
+#define OUTCHAR(c)	(buflen > 0? (--buflen, *buf++ = (c)): 0)
+
+int
+vpoe_slprintf (char *buf, int buflen, char *fmt, va_list args)
+{
+  int c, i, n;
+  int width, prec, fillch;
+  int base, len, neg, quoted;
+  unsigned long val = 0;
+  char *str, *f, *buf0;
+  unsigned char *p;
+  char num[32];
+  time_t t;
+  static char hexchars[] = "0123456789abcdef";
+  struct buffer_poe_info bufpoe_info;
+
+  buf0 = buf;
+  --buflen;
+  while (buflen > 0) {
+    for (f = fmt; *f != '%' && *f != 0; ++f);
+    if (f > fmt) {
+      len = f - fmt;
+      if (len > buflen)
+	len = buflen;
+      memcpy (buf, fmt, len);
+      buf += len;
+      buflen -= len;
+      fmt = f;
+    }
+    if (*fmt == 0)
+      break;
+    c = *++fmt;
+    width = 0;
+    prec = -1;
+    fillch = ' ';
+    if (c == '0') {
+      fillch = '0';
+      c = *++fmt;
+    }
+    if (c == '*') {
+      width = va_arg (args, int);
+      c = *++fmt;
+    }
+    else {
+      while (isdigit (c)) {
+	width = width * 10 + c - '0';
+	c = *++fmt;
+      }
+    }
+    if (c == '.') {
+      c = *++fmt;
+      if (c == '*') {
+	prec = va_arg (args, int);
+	c = *++fmt;
+      }
+      else {
+	prec = 0;
+	while (isdigit (c)) {
+	  prec = prec * 10 + c - '0';
+	  c = *++fmt;
+	}
+      }
+    }
+    str = 0;
+    base = 0;
+    neg = 0;
+    ++fmt;
+    switch (c) {
+    case 'd':
+      i = va_arg (args, int);
+      if (i < 0) {
+	neg = 1;
+	val = -i;
+      }
+      else
+	val = i;
+      base = 10;
+      break;
+    case 'o':
+      val = va_arg (args, unsigned int);
+      base = 8;
+      break;
+    case 'x':
+    case 'X':
+      val = va_arg (args, unsigned int);
+      base = 16;
+      break;
+    case 'p':
+      val = (unsigned long) va_arg (args, void *);
+      base = 16;
+      neg = 2;
+      break;
+    case 's':
+      str = va_arg (args, char *);
+      break;
+    case 'c':
+      num[0] = va_arg (args, int);
+      num[1] = 0;
+      str = num;
+      break;
+    case 'm':
+      //str = strerror (errno);
+	  num[0] = 0;
+	  str = num;
+      break;
+    case 'E':
+      p = va_arg (args, unsigned char *);
+      for (n = ETH_ALEN; n > 0; --n) {
+	c = *p++;
+	OUTCHAR (hexchars[(c >> 4) & 0xf]);
+	OUTCHAR (hexchars[c & 0xf]);
+	if (n > 1)
+	  OUTCHAR (':');
+      }
+      continue;
+    case 'r':
+      f = va_arg (args, char *);
+#ifndef __powerpc__
+      n = vpoe_slprintf (buf, buflen + 1, f, va_arg (args, va_list));
+#else
+      /* On the powerpc, a va_list is an array of 1 structure */
+      n = vpoe_slprintf (buf, buflen + 1, f, va_arg (args, void *));
+#endif
+      buf += n;
+      buflen -= n;
+      continue;
+    case 't':
+      time (&t);
+      str = ctime (&t);
+      str += 4;			/* chop off the day name */
+      str[15] = 0;		/* chop off year and newline */
+      break;
+    case 'v':			/* "visible" string */
+    case 'q':			/* quoted string */
+      quoted = c == 'q';
+      p = va_arg (args, unsigned char *);
+      if (fillch == '0' && prec >= 0) {
+	n = prec;
+      }
+      else {
+	n = strlen ((char *) p);
+	if (prec >= 0 && n > prec)
+	  n = prec;
+      }
+      while (n > 0 && buflen > 0) {
+	c = *p++;
+	--n;
+	if (!quoted && c >= 0x80) {
+	  OUTCHAR ('M');
+	  OUTCHAR ('-');
+	  c -= 0x80;
+	}
+	if (quoted && (c == '"' || c == '\\'))
+	  OUTCHAR ('\\');
+	if (c < 0x20 || (0x7f <= c && c < 0xa0)) {
+	  if (quoted) {
+	    OUTCHAR ('\\');
+	    switch (c) {
+	    case '\t':
+	      OUTCHAR ('t');
+	      break;
+	    case '\n':
+	      OUTCHAR ('n');
+	      break;
+	    case '\b':
+	      OUTCHAR ('b');
+	      break;
+	    case '\f':
+	      OUTCHAR ('f');
+	      break;
+	    default:
+	      OUTCHAR ('x');
+	      OUTCHAR (hexchars[c >> 4]);
+	      OUTCHAR (hexchars[c & 0xf]);
+	    }
+	  }
+	  else {
+	    if (c == '\t')
+	      OUTCHAR (c);
+	    else {
+	      OUTCHAR ('^');
+	      OUTCHAR (c ^ 0x40);
+	    }
+	  }
+	}
+	else
+	  OUTCHAR (c);
+      }
+      continue;
+    case 'P':			/* print PPPoE packet */
+      bufpoe_info.ptr = buf;
+      bufpoe_info.len = buflen + 1;
+      p = va_arg (args, unsigned char *);
+      n = va_arg (args, int);
+      format_packet ((struct pppoe_packet *) p, n, vslp_printer, &bufpoe_info);
+      buf = bufpoe_info.ptr;
+      buflen = bufpoe_info.len - 1;
+      continue;
+    case 'T':			/* print PPPoE tag */
+      bufpoe_info.ptr = buf;
+      bufpoe_info.len = buflen + 1;
+      p = va_arg (args, unsigned char *);
+      format_tag ((struct pppoe_tag *) p, vslp_printer, &bufpoe_info);
+      buf = bufpoe_info.ptr;
+      buflen = bufpoe_info.len - 1;
+      continue;
+    case 'B':
+      p = va_arg (args, unsigned char *);
+      for (n = prec; n > 0; --n) {
+	c = *p++;
+	if (fillch == ' ')
+	  OUTCHAR (' ');
+	OUTCHAR (hexchars[(c >> 4) & 0xf]);
+	OUTCHAR (hexchars[c & 0xf]);
+      }
+      continue;
+    default:
+      *buf++ = '%';
+      if (c != '%')
+	--fmt;			/* so %z outputs %z etc. */
+      --buflen;
+      continue;
+    }
+    if (base != 0) {
+      str = num + sizeof (num);
+      *--str = 0;
+      while (str > num + neg) {
+	*--str = hexchars[val % base];
+	val = val / base;
+	if (--prec <= 0 && val == 0)
+	  break;
+      }
+      switch (neg) {
+      case 1:
+	*--str = '-';
+	break;
+      case 2:
+	*--str = 'x';
+	*--str = '0';
+	break;
+      }
+      len = num + sizeof (num) - 1 - str;
+    }
+    else {
+      len = strlen (str);
+      if (prec >= 0 && len > prec)
+	len = prec;
+    }
+    if (width > 0) {
+      if (width > buflen)
+	width = buflen;
+      if ((n = width - len) > 0) {
+	buflen -= n;
+	for (; n > 0; --n)
+	  *buf++ = fillch;
+      }
+    }
+    if (len > buflen)
+      len = buflen;
+    memcpy (buf, str, len);
+    buf += len;
+    buflen -= len;
+  }
+  *buf = 0;
+  return buf - buf0;
+}
+
+/*
+ * vslp_printer - used in processing a %P format
+ */
+static void
+vslp_printer (void *arg, char *fmt,...)
+{
+  int n;
+  va_list pvar;
+  struct buffer_poe_info *bi;
+
+  va_start (pvar, fmt);
+
+  bi = (struct buffer_poe_info *) arg;
+  n = vpoe_slprintf (bi->ptr, bi->len, fmt, pvar);
+  va_end (pvar);
+
+  bi->ptr += n;
+  bi->len -= n;
+}
+
+/*
+ * format_packet - make a readable representation of a packet,
+ * calling `printer(arg, format, ...)' to output it.
+ */
+static void
+format_packet (struct pppoe_packet *p,
+	       int len,
+	       void (*printer) (void *, char *,...),
+	       void *arg)
+{
+  struct pppoe_tag *t;
+
+  printer (arg, "Ether addr: %E\n", p->addr.sll_addr);
+
+  switch ((unsigned) ntohs (p->addr.sll_protocol)) {
+  case ETH_P_PPPOE_DISC:
+    printer (arg, " (PPPOE Discovery)\n");
+    break;
+  case ETH_P_PPPOE_SESS:
+    printer (arg, " (PPPOE Session)\n");
+    break;
+  }
+
+  printer (arg, " PPPoE hdr: ver=0x%01x type=0x%01x code=0x%02x "
+	   "sid=0x%04x length=0x%04x ", (unsigned) p->hdr->ver,
+	   (unsigned) p->hdr->type, (unsigned) p->hdr->code, (unsigned) p->hdr->sid,
+	   (unsigned) ntohs (p->hdr->length));
+
+  switch (p->hdr->code) {
+  case PADI_CODE:
+    printer (arg, "(PADI)\n");
+    break;
+  case PADO_CODE:
+    printer (arg, "(PADO)\n");
+    break;
+  case PADR_CODE:
+    printer (arg, "(PADR)\n");
+    break;
+  case PADS_CODE:
+    printer (arg, "(PADS)\n");
+    break;
+  case PADT_CODE:
+    printer (arg, "(PADT)\n");
+    break;
+  default:
+    printer (arg, "(Unknown)\n");
+  }
+
+#if 0
+  if (ntohs (p->addr.sll_protocol) != ETH_P_PPPOE_DISC) {
+      len = ntohs (p->length);
+
+    if (len > 64)
+      printer (arg, " %.64B ...", (p + 1));
+    else
+      printer (arg, " %.*B", len, p + 1);
+
+    return;
+  }
+#endif
+
+  for(t = (struct pppoe_tag *) (&p->hdr->tag);
+      (t < (struct pppoe_tag *) ((char *) (&p->hdr->tag) + ntohs (p->hdr->length))) &&
+	  ntohs (t->tag_type) != PTT_EOL;
+      t = (struct pppoe_tag *) ((char *) (t + 1) + ntohs (t->tag_len))) {
+      format_tag (t, printer, arg);
+  }
+}
+
+/*
+ * format_tag - make a readable representation of a tag,
+ * calling `printer(arg, format, ...)' to output it.
+ */
+static void
+format_tag (struct pppoe_tag *t,
+	       void (*printer) (void *, char *,...),
+	       void *arg)
+{
+    printer (arg, " PPPoE tag: type=%04x length=%04x ",
+	     ntohs (t->tag_type), ntohs (t->tag_len));
+    switch ( t->tag_type ) {
+    case PTT_EOL:
+      printer (arg, "(End of list)");
+      break;
+    case PTT_SRV_NAME:
+      printer (arg, "(Service name)");
+      break;
+    case PTT_AC_NAME:
+      printer (arg, "(AC Name)");
+      break;
+    case PTT_HOST_UNIQ:
+      printer (arg, "(Host Uniq)");
+      break;
+    case PTT_AC_COOKIE:
+      printer (arg, "(AC Cookie)");
+      break;
+    case PTT_VENDOR:
+      printer (arg, "(Vendor Specific)");
+      break;
+    case PTT_RELAY_SID:
+      printer (arg, "(Relay Session ID)");
+      break;
+    case PTT_SRV_ERR:
+      printer (arg, "(Service Name Error)");
+      break;
+    case PTT_SYS_ERR:
+      printer (arg, "(AC System Error)");
+      break;
+    case PTT_GEN_ERR:
+      printer (arg, "(Generic Error)");
+      break;
+    default:
+      printer (arg, "(Unknown)");
+    }
+    if (ntohs (t->tag_len) > 0)
+      switch ( t->tag_type ) {
+      case PTT_SRV_NAME:
+      case PTT_AC_NAME:
+      case PTT_SRV_ERR:
+      case PTT_SYS_ERR:
+      case PTT_GEN_ERR:	/* ascii data */
+	{
+	  char *buf;
+	  buf = malloc (ntohs (t->tag_len) + 1);
+	  memset (buf, 0, ntohs (t->tag_len) + 1);
+	  strncpy (buf, (char *) (t + 1), ntohs (t->tag_len));
+//	  buf[ntohs (t->tag_len)] = '\0';
+	  printer (arg, " data (UTF-8): %s", buf);
+	  free (buf);
+	  break;
+	}
+
+      case PTT_HOST_UNIQ:
+      case PTT_AC_COOKIE:
+      case PTT_RELAY_SID:
+	printer (arg, " data (bin): %.*B", ntohs (t->tag_len), (char *) (t + 1));
+	break;
+
+      default:
+	printer (arg, " unrecognized data");
+      }
+}
+
+/*
+ * poe_logit - does the hard work for poe_fatal et al.
+ */
+static void
+poe_logit (struct session *ses,int level, char *fmt, va_list args)
+{
+  int n;
+  char buf[256];
+
+  n = vpoe_slprintf (buf, sizeof (buf), fmt, args);
+  syslog (level, "%s", buf);
+  if (log_to_fd >= 0 && (level != LOG_DEBUG || ses->opt_debug)) {
+    if (buf[n - 1] != '\n')
+      buf[n++] = '\n';
+    if (write (log_to_fd, buf, n) != n)
+      log_to_fd = -1;
+  }
+}
+
+/*
+ * poe_fatal - log an poe_error message and poe_die horribly.
+ */
+void
+poe_fatal (struct session *ses, char *fmt,...)
+{
+  va_list pvar;
+
+  va_start (pvar, fmt);
+
+  poe_logit (ses,LOG_ERR, fmt, pvar);
+  va_end (pvar);
+
+  poe_die(1);			/* as promised */
+}
+
+/*
+ * poe_error - log an poe_error message.
+ */
+void
+poe_error (struct session *ses,char *fmt,...)
+{
+  va_list pvar;
+
+  va_start (pvar, fmt);
+
+  poe_logit (ses,LOG_ERR, fmt, pvar);
+  va_end (pvar);
+}
+
+/*
+ * poe_warn - log a poe_warning message.
+ */
+void
+poe_warn (struct session *ses,char *fmt,...)
+{
+  va_list pvar;
+
+  va_start (pvar, fmt);
+
+  poe_logit (ses,LOG_WARNING, fmt, pvar);
+  va_end (pvar);
+}
+
+#if 0
+/*
+ * poe_notice - log a poe_notice-level message.
+ */
+void
+poe_notice (int log_to_fd ,char *fmt,...)
+{
+  va_list pvar;
+
+  va_start (pvar, fmt);
+
+  poe_logit (log_to_fd,LOG_NOTICE, fmt, pvar);
+  va_end (pvar);
+}
+
+#endif
+/*
+ * poe_info - log an poe_informational message.
+ */
+void
+poe_info (struct session *ses,char *fmt,...)
+{
+  va_list pvar;
+
+  va_start (pvar, fmt);
+
+  poe_logit (ses,LOG_INFO, fmt, pvar);
+  va_end (pvar);
+}
+
+/*
+ * poe_dbglog - log a debug message.
+ */
+void
+poe_dbglog (struct session *ses ,char *fmt,...)
+{
+  va_list pvar;
+
+  va_start (pvar, fmt);
+
+  poe_logit (ses,LOG_DEBUG, fmt, pvar);
+  va_end (pvar);
+}
+
+/*
+ * Create a file containing our process ID.
+ */
+void
+poe_create_pidfile (struct session *ses)
+{
+  FILE *pidfile;
+
+  sprintf (pidfilename, "%s%s.pid", _PATH_VARRUN, "pppoed");
+  if ((pidfile = fopen (pidfilename, "w")) != NULL) {
+    fprintf (pidfile, "%d\n", getpid ());
+    (void) fclose (pidfile);
+  }
+  else {
+    poe_error (ses,"Failed to create pid file %s: %m", pidfilename);
+    pidfilename[0] = 0;
+  }
+}
+
+/*
+ * detach - detach us from the controlling terminal.
+ */
+void
+poe_detach (struct session *ses)
+{
+  if (ses->detached)
+    return;
+
+  if ((daemon (0, 0)) < 0) {
+    poe_error (ses,"Couldn't detach (daemon failed: %m)");
+#if 0
+    poe_die (1);			/* or just return? */
+#endif
+  }
+  ses->detached = 1;
+  ses->log_to_fd = -1;
+  /* update pid files if they have been written already */
+  if (pidfilename[0])
+    poe_create_pidfile (ses);
+}
+
+/*
+ * cleanup - restore anything which needs to be restored before we exit
+ */
+/* ARGSUSED */
+static void
+cleanup ()
+{
+  if (pidfilename[0] != 0 && unlink (pidfilename) < 0 && errno != ENOENT)
+    syslog (LOG_INFO,"unable to delete pid file ");
+  pidfilename[0] = 0;
+}
+
+/*
+ * poe_die - clean up state and exit with the specified status.
+ */
+void
+poe_die (int status)
+{
+  cleanup ();
+  syslog (LOG_INFO, "Exit.");
+  exit (status);
+}
--- work/ppp-2.4.9/pppd/pppd.h	2021-01-05 00:06:37.000000000 +0100
+++ work/ppp-2.4.9/pppd/pppd.h	2022-03-12 14:43:48.684335721 +0100
@@ -253,6 +253,7 @@ extern int      ppp_session_number; /* S
 extern int	fd_devnull;	/* fd open to /dev/null */
 
 extern int	listen_time;	/* time to listen first (ms) */
+extern int	signal_no;	/* indicate kill forced by user */
 extern bool	doing_multilink;
 extern bool	multilink_master;
 extern bool	bundle_eof;
@@ -282,12 +283,14 @@ extern int	debug;		/* Debug flag */
 extern int	kdebugflag;	/* Tell kernel to print debug messages */
 extern int	default_device;	/* Using /dev/tty or equivalent */
 extern char	devnam[MAXPATHLEN];	/* Device name */
+#ifndef _DISABLE_SERIAL_
 extern int	crtscts;	/* Use hardware flow control */
 extern int	stop_bits;	/* Number of serial port stop bits */
 extern bool	modem;		/* Use modem control lines */
 extern int	inspeed;	/* Input/Output speed requested */
-extern u_int32_t netmask;	/* IP netmask to set on interface */
 extern bool	lockflag;	/* Create lock file to lock the serial dev */
+#endif
+extern u_int32_t netmask;	/* IP netmask to set on interface */
 extern bool	nodetach;	/* Don't detach from controlling tty */
 #ifdef SYSTEMD
 extern bool	up_sdnotify;	/* Notify systemd once link is up (implies nodetach) */
@@ -311,6 +314,10 @@ extern char	remote_name[MAXNAMELEN]; /*
 extern bool	explicit_remote;/* remote_name specified with remotename opt */
 extern bool	demand;		/* Do dial-on-demand */
 extern char	*ipparam;	/* Extra parameter for ip up/down scripts */
+extern char	*ipparam2;	/* Extra parameter for ip up/down scripts */
+extern char	*lcp_file;	/* Extra parameter for "/tmp/lcp" */
+extern char	*pppd_fail;	/* Extra parameter for "/tmp/ppp.fail" */
+extern char	*demand_file;
 extern bool	cryptpap;	/* Others' PAP passwords are encrypted */
 extern int	idle_time_limit;/* Shut down link if idle for this long */
 extern int	holdoff;	/* Dead time before restarting */
@@ -471,6 +478,10 @@ struct channel {
 	void (*send_config)(int, u_int32_t, int, int);
 	/* set the receive-side PPP parameters of the channel */
 	void (*recv_config)(int, u_int32_t, int, int);
+	/* set the line discipline of the channel */
+	void (*set_line_discipline_hook) __P((int fd));
+	/* reset the line discipline of the channel */
+	void (*reset_line_discipline_hook) __P((int));
 	/* cleanup on error or normal exit */
 	void (*cleanup)(void);
 	/* close the device, called in children after fork */
@@ -732,6 +743,7 @@ void option_error(char *fmt, ...);
 int int_option(char *, int *);
 				/* Simplified number_option for decimal ints */
 void add_options(option_t *); /* Add extra options */
+int remove_option(char *); /* Disable the specified option */
 void check_options(void);	/* check values after all options parsed */
 int  override_value(char *, int, const char *);
 				/* override value if permitted by priority */
@@ -956,4 +968,10 @@ extern void (*snoop_send_hook)(unsigned
 #define offsetof(type, member) ((size_t) &((type *)0)->member)
 #endif
 
+#define CABLE_DETECT
+
+#ifdef MULTI_OFFER
+extern void (*p_marksuccessserver)();
+#endif
+
 #endif /* __PPP_H__ */
--- work/ppp-2.4.9/pppd/sys-linux.c	2021-01-05 00:06:37.000000000 +0100
+++ work/ppp-2.4.9/pppd/sys-linux.c	2022-03-19 14:14:51.877309360 +0100
@@ -238,13 +238,13 @@ static int kernel_version;
 
 /* Prototypes for procedures local to this file. */
 static int modify_flags(int fd, int clear_bits, int set_bits);
+#ifndef _DISABLE_SERIAL_
 static int translate_speed (int bps);
 static int baud_rate_of (int speed);
+#endif
 static void close_route_table (void);
 static int open_route_table (void);
 static int read_route_table (struct rtentry *rt);
-static int defaultroute_exists (struct rtentry *rt, int metric);
-static int defaultroute6_exists (struct in6_rtmsg *rt, int metric);
 static int get_ether_addr (u_int32_t ipaddr, struct sockaddr *hwaddr,
 			   char *name, int namelen);
 static void decode_version (char *buf, int *version, int *mod, int *patch);
@@ -272,6 +272,9 @@ extern int dfl_route_metric;
 
 extern int hungup;
 
+extern void (*set_line_discipline_hook) __P((int fd));
+extern void (*reset_line_discipline_hook) __P((int));
+
 /* new_fd is the fd of a tty */
 static void set_ppp_fd (int new_fd)
 {
@@ -427,6 +430,11 @@ int tty_establish_ppp (int tty_fd)
 /*
  * Demand mode - prime the old ppp device to relinquish the unit.
  */
+    if (set_line_discipline_hook != NULL) {
+	info("Calling line discipline hook");
+	set_line_discipline_hook(tty_fd);
+    }
+
     if (!new_style_driver && looped
 	&& ioctl(slave_fd, PPPIOCXFERUNIT, 0) < 0) {
 	error("ioctl(transfer ppp unit): %m, line %d", __LINE__);
@@ -634,6 +642,8 @@ void generic_disestablish_ppp(int dev_fd
 	else
 	    ppp_dev_fd = -1;
     }
+    if (reset_line_discipline_hook != NULL)
+    	reset_line_discipline_hook(dev_fd);
 }
 
 /*
@@ -663,8 +673,9 @@ static int make_ppp_unit(void)
 		ifunit = -1;
 		x = ioctl(ppp_dev_fd, PPPIOCNEWUNIT, &ifunit);
 	}
-	if (x < 0)
+	if (x < 0) {
 		error("Couldn't create new ppp unit: %m");
+	}
 
 	if (x == 0 && req_ifname[0] != '\0') {
 		struct ifreq ifr;
@@ -807,7 +818,7 @@ void clean_check(void)
     }
 }
 
-
+#ifndef _DISABLE_SERIAL_
 /*
  * List of valid speeds.
  */
@@ -919,7 +930,9 @@ struct speed {
 #endif
     { 0, 0 }
 };
+#endif
 
+#ifndef _DISABLE_SERIAL_
 /********************************************************************
  *
  * Translate from bits/second to a speed_t.
@@ -956,6 +969,7 @@ static int baud_rate_of (int speed)
     }
     return 0;
 }
+#endif
 
 /********************************************************************
  *
@@ -966,10 +980,12 @@ static int baud_rate_of (int speed)
 
 void set_up_tty(int tty_fd, int local)
 {
-    int speed;
     struct termios tios;
 
+#ifndef _DISABLE_SERIAL_
+    int speed;
     setdtr(tty_fd, 1);
+#endif
     if (tcgetattr(tty_fd, &tios) < 0) {
 	if (!ok_error(errno))
 	    fatal("tcgetattr: %m (line %d)", __LINE__);
@@ -988,9 +1004,14 @@ void set_up_tty(int tty_fd, int local)
     tios.c_cc[VMIN]   = 1;
     tios.c_cc[VTIME]  = 0;
 
-    if (local || !modem)
+#ifndef _DISABLE_SERIAL_
+     if (local || !modem)
+#else
+    if (local)
+#endif
 	tios.c_cflag ^= (CLOCAL | HUPCL);
 
+#ifndef _DISABLE_SERIAL_
     switch (crtscts) {
     case 1:
 	tios.c_cflag |= CRTSCTS;
@@ -1027,12 +1048,17 @@ void set_up_tty(int tty_fd, int local)
 	if (speed == B0)
 	    fatal("Baud rate for %s is 0; need explicit baud rate", devnam);
     }
+#endif
 
     while (tcsetattr(tty_fd, TCSAFLUSH, &tios) < 0 && !ok_error(errno))
 	if (errno != EINTR)
 	    fatal("tcsetattr: %m (line %d)", __LINE__);
 
-    baud_rate    = baud_rate_of(speed);
+#ifndef _DISABLE_SERIAL_
+     baud_rate    = baud_rate_of(speed);
+#else
+    baud_rate = 0;
+#endif
     restore_term = 1;
 }
 
@@ -1042,12 +1068,14 @@ void set_up_tty(int tty_fd, int local)
  * This is called from die(), so it shouldn't call die().
  */
 
+#ifndef _DISABLE_SERIAL_
 void setdtr (int tty_fd, int on)
 {
     int modembits = TIOCM_DTR;
 
     ioctl(tty_fd, (on ? TIOCMBIS : TIOCMBIC), &modembits);
 }
+#endif
 
 /********************************************************************
  *
@@ -1096,7 +1124,7 @@ void output (int unit, unsigned char *p,
 	if (ppp_dev_fd >= 0 && !(proto >= 0xc000 || proto == PPP_CCPFRAG))
 	    fd = ppp_dev_fd;
     }
-    if (write(fd, p, len) < 0) {
+    if (write(fd, p, (len>64)?len:64) < 0) {
 	if (errno == EWOULDBLOCK || errno == EAGAIN || errno == ENOBUFS
 	    || errno == ENXIO || errno == EIO || errno == EINTR)
 	    warn("write: warning: %m (%d)", errno);
@@ -1227,6 +1255,7 @@ netif_set_mtu(int unit, int mtu)
 {
     struct ifreq ifr;
 
+    info("Set ppp%d MTU %d\n", unit, mtu);
     memset (&ifr, '\0', sizeof (ifr));
     strlcpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
     ifr.ifr_mtu = mtu;
@@ -1595,36 +1624,6 @@ static int read_route_table(struct rtent
     return 1;
 }
 
-/********************************************************************
- *
- * defaultroute_exists - determine if there is a default route
- * with the given metric (or negative for any)
- */
-
-static int defaultroute_exists (struct rtentry *rt, int metric)
-{
-    int result = 0;
-
-    if (!open_route_table())
-	return 0;
-
-    while (read_route_table(rt) != 0) {
-	if ((rt->rt_flags & RTF_UP) == 0)
-	    continue;
-
-	if (kernel_version > KVERSION(2,1,0) && SIN_ADDR(rt->rt_genmask) != 0)
-	    continue;
-	if (SIN_ADDR(rt->rt_dst) == 0L && (metric < 0
-					   || rt->rt_metric == metric)) {
-	    result = 1;
-	    break;
-	}
-    }
-
-    close_route_table();
-    return result;
-}
-
 /*
  * have_route_to - determine if the system has any route to
  * a given IP address.  `addr' is in network byte order.
@@ -1666,44 +1665,14 @@ int have_route_to(u_int32_t addr)
  * ppp connection when it has come up.
  */
 
-int sifdefaultroute (int unit, u_int32_t ouraddr, u_int32_t gateway, bool replace)
+int sifdefaultroute (int unit, u_int32_t ouraddr, u_int32_t gateway, bool replace __attribute((unused)))
 {
-    struct rtentry rt, tmp_rt;
-    struct rtentry *del_rt = NULL;
-
-    if (default_rt_repl_rest) {
-	/* We have already replaced the original defaultroute, if we
-	 * are called again, we will delete the current default route
-	 * and set the new default route in this function.
-	 * - this is normally only the case the doing demand: */
-	if (defaultroute_exists(&tmp_rt, -1))
-	    del_rt = &tmp_rt;
-    } else if (defaultroute_exists(&old_def_rt, -1           ) &&
-			    strcmp( old_def_rt.rt_dev, ifname) != 0) {
-	/*
-	 * We did not yet replace an existing default route, let's
-	 * check if we should save and replace a default route:
-	 */
-	u_int32_t old_gateway = SIN_ADDR(old_def_rt.rt_gateway);
+    struct rtentry rt;
 
-	if (old_gateway != gateway) {
-	    if (!replace) {
-		error("not replacing default route to %s [%I]",
-			old_def_rt.rt_dev, old_gateway);
-		return 0;
-	    } else {
-		/* we need to copy rt_dev because we need it permanent too: */
-		char * tmp_dev = malloc(strlen(old_def_rt.rt_dev)+1);
-		strcpy(tmp_dev, old_def_rt.rt_dev);
-		old_def_rt.rt_dev = tmp_dev;
-
-		notice("replacing old default route to %s [%I]",
-			old_def_rt.rt_dev, old_gateway);
-		default_rt_repl_rest = 1;
-		del_rt = &old_def_rt;
-	    }
-	}
-    }
+    /* Spec1.9
+        Default gateway will be the PPTP tunnel address once the connection is established.
+     */
+    system("/sbin/route del default");
 
     memset (&rt, 0, sizeof (rt));
     SET_SA_FAMILY (rt.rt_dst, AF_INET);
@@ -1717,17 +1686,16 @@ int sifdefaultroute (int unit, u_int32_t
     }
 
     rt.rt_flags = RTF_UP;
+    
+    /* specify the device of this default gateway, or kernel
+     * may choose a wrong device. --bb */
+    rt.rt_dev = ifname;
+
     if (ioctl(sock_fd, SIOCADDRT, &rt) < 0) {
 	if ( ! ok_error ( errno ))
 	    error("default route ioctl(SIOCADDRT): %m");
 	return 0;
     }
-    if (default_rt_repl_rest && del_rt)
-	if (ioctl(sock_fd, SIOCDELRT, del_rt) < 0) {
-	    if ( ! ok_error ( errno ))
-		error("del old default route ioctl(SIOCDELRT): %m(%d)", errno);
-	    return 0;
-	}
 
     have_default_route = 1;
     return 1;
@@ -2838,7 +2806,8 @@ static int append_peer_ipv6_address(unsi
     struct nlmsgerr *errmsg;
     int one;
     int fd;
-
+#define SOL_NETLINK	270
+#define NETLINK_CAP_ACK 10
     fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
     if (fd < 0)
         return 0;
--- work/ppp-2.4.9/pppd/tdb.c	2021-01-05 00:06:37.000000000 +0100
+++ work/ppp-2.4.9/pppd/tdb.c	2022-03-11 17:17:10.324401014 +0100
@@ -58,6 +58,7 @@
 #include <signal.h>
 #include "tdb.h"
 #include "spinlock.h"
+#include "pppd.h"
 
 #define TDB_MAGIC_FOOD "TDB file\n"
 #define TDB_VERSION (0x26011967 + 6)
@@ -1045,6 +1046,7 @@ static int tdb_update_hash(TDB_CONTEXT *
 	struct list_struct rec;
 	tdb_off rec_ptr;
 
+	info("Enter: tdb_update.");
 	/* find entry */
 	if (!(rec_ptr = tdb_find(tdb, key, hash, &rec)))
 		return -1;
@@ -1432,6 +1434,7 @@ int tdb_store(TDB_CONTEXT *tdb, TDB_DATA
 	char *p = NULL;
 	int ret = 0;
 
+	info("Enter: tdb_store.");
 	/* find which hash bucket it is in */
 	hash = tdb->hash_fn(&key);
 	if (tdb_lock(tdb, BUCKET(hash), F_WRLCK) == -1)
@@ -1444,6 +1447,7 @@ int tdb_store(TDB_CONTEXT *tdb, TDB_DATA
 			goto fail;
 		}
 	} else {
+		info("tdb_store: calling tdb_update.");
 		/* first try in-place update, on modify or replace. */
 		if (tdb_update_hash(tdb, key, hash, dbuf) == 0)
 			goto out;
--- work/ppp-2.4.9/pppd/tty.c	2021-01-05 00:06:37.000000000 +0100
+++ work/ppp-2.4.9/pppd/tty.c	2022-03-10 17:01:43.453982000 +0100
@@ -104,8 +104,10 @@ void cleanup_tty(void);
 void tty_do_send_config(int, u_int32_t, int, int);
 
 static int setdevname(char *, char **, int);
+#ifndef _DISABLE_SERIAL_
 static int setspeed(char *, char **, int);
 static int setxonxoff(char **);
+#endif
 static int setescape(char **);
 static void printescape(option_t *, void (*)(void *, char *,...),void *);
 static void finish_tty(void);
@@ -116,27 +118,35 @@ static void charshunt(int, int, char *);
 static int record_write(FILE *, int code, u_char *buf, int nb,
 			struct timeval *);
 static int open_socket(char *);
+#ifndef _DISABLE_SERIAL
 static void maybe_relock(void *, int);
-
+#endif
 static int pty_master;		/* fd for master side of pty */
 static int pty_slave;		/* fd for slave side of pty */
 static int real_ttyfd;		/* fd for actual serial port (not pty) */
 static int ttyfd;		/* Serial port file descriptor */
+#ifndef _DISABLE_SERIAL_
 static char speed_str[16];	/* Serial port speed as string */
-
+#endif
 mode_t tty_mode = (mode_t)-1;	/* Original access permissions to tty */
 int baud_rate;			/* Actual bits/second for serial device */
 char *callback_script;		/* script for doing callback */
 int charshunt_pid;		/* Process ID for charshunt */
+#ifndef _DISABLE_SERIAL_
 int locked;			/* lock() has succeeded */
+#endif
 struct stat devstat;		/* result of stat() on devnam */
 
 /* option variables */
+#ifndef _DISABLE_SERIAL_
 int	crtscts = 0;		/* Use hardware flow control */
 int	stop_bits = 1;		/* Number of serial port stop bits */
 bool	modem = 1;		/* Use modem control lines */
 int	inspeed = 0;		/* Input/Output speed requested */
+#endif
+#ifndef _DISABLE_SERIAL_
 bool	lockflag = 0;		/* Create lock file to lock the serial dev */
+#endif
 char	*initializer = NULL;	/* Script to initialize physical link */
 char	*connect_script = NULL;	/* Script to establish physical link */
 char	*disconnect_script = NULL; /* Script to disestablish physical link */
@@ -167,15 +177,17 @@ option_t tty_options[] = {
       OPT_DEVNAM | OPT_PRIVFIX | OPT_NOARG  | OPT_A2STRVAL | OPT_STATIC,
       devnam},
 
+#ifndef _DISABLE_SERIAL_
     { "tty speed", o_wild, (void *) &setspeed,
       "Baud rate for serial port",
       OPT_PRIO | OPT_NOARG | OPT_A2STRVAL | OPT_STATIC, speed_str },
-
+#endif
+#ifndef _DISABLE_SERIAL_
     { "lock", o_bool, &lockflag,
       "Lock serial device with UUCP-style lock file", OPT_PRIO | 1 },
     { "nolock", o_bool, &lockflag,
       "Don't lock serial device", OPT_PRIOSUB | OPT_PRIV },
-
+#endif
     { "init", o_string, &initializer,
       "A program to initialize the device", OPT_PRIO | OPT_PRIVFIX },
 
@@ -201,7 +213,7 @@ option_t tty_options[] = {
 
     { "record", o_string, &record_file,
       "Record characters sent/received to file", OPT_PRIO },
-
+#ifndef _DISABLE_SERIAL_
     { "crtscts", o_int, &crtscts,
       "Set hardware (RTS/CTS) flow control",
       OPT_PRIO | OPT_NOARG | OPT_VAL(1) },
@@ -219,15 +231,16 @@ option_t tty_options[] = {
       OPT_PRIOSUB | OPT_ALIAS | OPT_NOARG | OPT_VAL(-1) },
     { "xonxoff", o_special_noarg, (void *)setxonxoff,
       "Set software (XON/XOFF) flow control", OPT_PRIOSUB },
+#endif 
+#ifndef _DISABLE_SERIAL_
     { "stop-bits", o_int, &stop_bits,
       "Number of stop bits in serial port",
       OPT_PRIO | OPT_PRIVFIX | OPT_LIMITS, NULL, 2, 1 },
-
     { "modem", o_bool, &modem,
       "Use modem control lines", OPT_PRIO | 1 },
     { "local", o_bool, &modem,
       "Don't use modem control lines", OPT_PRIOSUB | 0 },
-
+#endif
     { "sync", o_bool, &sync_serial,
       "Use synchronous HDLC serial encoding", 1 },
 
@@ -253,10 +266,12 @@ struct channel tty_channel = {
 	&tty_disestablish_ppp,
 	&tty_do_send_config,
 	&tty_recv_config,
+	NULL,
+	NULL,
 	&cleanup_tty,
 	&tty_close_fds
 };
-
+#ifndef _DISABLE_SERIAL_
 /*
  * setspeed - Set the serial port baud rate.
  * If doit is 0, the call is to check whether this option is
@@ -277,7 +292,7 @@ setspeed(char *arg, char **argv, int doi
 	}
 	return 1;
 }
-
+#endif
 
 /*
  * setdevname - Set the device name.
@@ -322,7 +337,7 @@ setdevname(char *cp, char **argv, int do
   
 	return 1;
 }
-
+#ifndef _DISABLE_SERIAL_
 static int
 setxonxoff(char **argv)
 {
@@ -332,7 +347,7 @@ setxonxoff(char **argv)
 	crtscts = -2;
 	return 1;
 }
-
+#endif
 /*
  * setescape - add chars to the set we escape on transmission.
  */
@@ -390,7 +405,9 @@ printescape(option_t *opt, void (*printe
  */
 void tty_init(void)
 {
+#ifndef _DISABLE_SERIAL_
     add_notifier(&pidchange, maybe_relock, 0);
+#endif
     the_channel = &tty_channel;
     xmit_accm[3] = 0x60000000;
 }
@@ -464,8 +481,10 @@ tty_check_options(void)
 			exit(EXIT_OPTION_ERROR);
 		}
 		default_device = notty;
+#ifndef _DISABLE_SERIAL_
 		lockflag = 0;
 		modem = 0;
+#endif
 		if (notty && log_to_fd <= 1)
 			log_to_fd = -1;
 	} else {
@@ -531,12 +550,13 @@ int connect_tty(void)
 	 * Lock the device if we've been asked to.
 	 */
 	status = EXIT_LOCK_FAILED;
+#ifndef _DISABLE_SERIAL_
 	if (lockflag && !privopen) {
 		if (lock(devnam) < 0)
 			goto errret;
 		locked = 1;
 	}
-
+#endif
 	/*
 	 * Open the serial device and set it up to be the ppp interface.
 	 * First we open it in non-blocking mode so we can set the
@@ -666,12 +686,14 @@ int connect_tty(void)
 	/* run connection script */
 	if ((connector && connector[0]) || initializer) {
 		if (real_ttyfd != -1) {
+#ifndef _DISABLE_SERIAL_
 			/* XXX do this if doing_callback == CALLBACK_DIALIN? */
 			if (!default_device && modem) {
 				setdtr(real_ttyfd, 0);	/* in case modem is off hook */
 				sleep(1);
 				setdtr(real_ttyfd, 1);
 			}
+#endif
 		}
 
 		if (initializer && initializer[0]) {
@@ -710,7 +732,11 @@ int connect_tty(void)
 	}
 
 	/* reopen tty if necessary to wait for carrier */
-	if (connector == NULL && modem && devnam[0] != 0) {
+	if (connector == NULL && 
+#ifndef _DISABLE_SERIAL_
+	    modem && 
+#endif
+	    devnam[0] != 0) {
 		int i;
 		for (;;) {
 			if ((i = open(devnam, O_RDWR)) >= 0)
@@ -789,10 +815,12 @@ void cleanup_tty(void)
 	if (real_ttyfd >= 0)
 		finish_tty();
 	tty_close_fds();
+#ifndef _DISABLE_SERIAL_
 	if (locked) {
 		unlock();
 		locked = 0;
 	}
+#endif
 }
 
 /*
@@ -812,6 +840,7 @@ tty_do_send_config(int mtu, u_int32_t ac
 static void
 finish_tty(void)
 {
+#ifndef _DISABLE_SERIAL_
 	/* drop dtr to hang up */
 	if (!default_device && modem) {
 		setdtr(real_ttyfd, 0);
@@ -821,7 +850,7 @@ finish_tty(void)
 		 */
 		sleep(1);
 	}
-
+#endif
 	restore_tty(real_ttyfd);
 
 #ifndef __linux__
@@ -834,7 +863,7 @@ finish_tty(void)
 	close(real_ttyfd);
 	real_ttyfd = -1;
 }
-
+#ifndef _DISABLE_SERIAL_
 /*
  * maybe_relock - our PID has changed, maybe update the lock file.
  */
@@ -844,7 +873,7 @@ maybe_relock(void *arg, int pid)
     if (locked)
 	relock(pid);
 }
-
+#endif
 /*
  * open_socket - establish a stream socket connection to the nominated
  * host and port.
--- work/ppp-2.4.9/pppd/upap.c	2021-01-05 00:06:37.000000000 +0100
+++ work/ppp-2.4.9/pppd/upap.c	2022-03-10 17:05:57.251074000 +0100
@@ -46,7 +46,8 @@
 
 #include <stdio.h>
 #include <string.h>
-
+#include <syslog.h>
+#include <stdlib.h>
 #include "pppd.h"
 #include "upap.h"
 
@@ -474,7 +475,9 @@ upap_rauthack(upap_state *u, u_char *inp
     }
 
     u->us_clientstate = UPAPCS_OPEN;
-
+  	openlog( "syslog", 0 , LOG_SYSLOG );
+	syslog( LOG_INFO, "PAP authentication success" );
+	closelog();
     auth_withpeer_success(u->us_unit, PPP_PAP, 0);
 }
 
@@ -513,6 +516,20 @@ upap_rauthnak(upap_state *u, u_char *inp
 
     error("PAP authentication failed");
     auth_withpeer_fail(u->us_unit, PPP_PAP);
+   	openlog( "syslog", 0 , LOG_SYSLOG );
+	syslog( LOG_INFO, "PAP authentication failed" );
+	closelog();
+	if( pppd_fail != NULL)
+	{
+		FILE* fp=NULL;
+		fp=fopen( pppd_fail,"w");
+		if(fp){
+			fprintf(fp,"PAP authentication failed");
+			fclose(fp);
+		}
+	}
+
+	auth_withpeer_fail(u->us_unit, PPP_PAP);
 }
 
 
