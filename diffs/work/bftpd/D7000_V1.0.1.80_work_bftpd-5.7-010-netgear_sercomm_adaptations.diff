--- work/bftpd/bftpd/bftpdutmp.c	2013-05-27 18:58:37.000000000 +0200
+++ work/bftpd/bftpd/bftpdutmp.c	2021-05-24 14:12:06.447917735 +0200
@@ -15,27 +15,6 @@
 FILE *bftpdutmp = NULL;
 long bftpdutmp_offset = 0xFFFFFFFF;
 
-void bftpdutmp_create_dir(char *path_to_file)
-{
-    char *dir_name, *index;
-
-    if (! path_to_file) return;
-
-    dir_name = strdup(path_to_file);
-    if (! dir_name)
-       return;
-
-    index = strrchr(dir_name, '/');
-    if (index)
-    {
-        index[0] = '\0';   /* wipe out everything after folder name */
-        mkdir(dir_name, 0755);
-    }
-    free(dir_name);
-}
-
-
-
 void bftpdutmp_init()
 {
 	char *filename = strdup(config_getoption("PATH_BFTPDUTMP"));
@@ -49,16 +28,13 @@ void bftpdutmp_init()
 		return;
         }
 
-    /* try to create the directory, if it does not exist yet */
-    bftpdutmp_create_dir(filename);
-
-    /*  we have to create the file if it doesn't exist */
+    /* First we have to create the file if it doesn't exist */
     bftpdutmp = fopen(filename, "a");
     if (bftpdutmp)
         fclose(bftpdutmp);
     /* Then we can open it for reading and writing */
     if (!(bftpdutmp = fopen(filename, "r+"))) {
-        bftpd_log("Could not open log file %s.\n", filename);
+        bftpd_log("Could not open log file %s.", filename);
         control_printf(SL_FAILURE, "421-Could not open file %s\r\n"
                  "421 Server disabled for security reasons.", filename);
         exit(1);
@@ -82,8 +58,6 @@ void bftpdutmp_log(char type)
 {
     struct bftpdutmp ut, tmp;
     long i;
-    int max_length;
-
     if (!bftpdutmp)
         return;
     memset((void *) &ut, 0, sizeof(ut));
@@ -91,9 +65,7 @@ void bftpdutmp_log(char type)
     if (type) {
         ut.bu_type = 1;
         strncpy(ut.bu_name, user, sizeof(ut.bu_name));
-        max_length = sizeof(ut.bu_host);
-        strncpy(ut.bu_host, remotehostname, max_length);
-        ut.bu_host[max_length - 1] = '\0';     /* avoid non-null terminated string */
+        strncpy(ut.bu_host, remotehostname, sizeof(ut.bu_host));
        /* Determine offset of first user marked dead */
         rewind(bftpdutmp);
         i = 0;
--- work/bftpd/bftpd/commands.c	2021-01-07 17:05:36.000000000 +0100
+++ work/bftpd/bftpd/commands.c	2021-05-24 21:41:10.283254780 +0200
@@ -54,6 +54,10 @@
 #include "bftpdutmp.h"
 #include "md5.h"
 
+#define SC_BUILD 1 
+#ifdef USB
+#include "ftp_usb_api.h"
+#endif
 
 #ifdef HAVE_ZLIB_H
 #include <zlib.h>
@@ -61,6 +65,10 @@
 #undef WANT_GZIP
 #endif
-
+#ifdef USB
+extern int adminpwd_lan_protect ;
+extern int adminpwd_wan_protect ;
+extern int is_remote ;
+#endif
 int state = STATE_CONNECTED;
 char user[USERLEN + 1];
 struct sockaddr_in sa;
@@ -75,7 +83,45 @@ int ratio_send = 1, ratio_recv = 1;
 double bytes_sent = 0.0, bytes_recvd = 0.0;
 int epsvall = 0;
 int xfer_bufsize;
+#ifdef USB
+int is_file_readable = 0;
+#endif
 
+#ifdef SC_BUILD
+#include <sys/file.h>
+int sc_lockf(int fd, int shared, int wait)
+{
+    int ret;
+    int op;
+
+    if (fd < 0) {
+        return 0;
+    }
+    if (shared)
+        op = LOCK_SH;
+    else
+        op = LOCK_EX;
+    if (!wait)
+        op |= LOCK_NB;
+
+    ret = flock(fd, op);
+    return ret;
+}
+int sc_check_writable(const char *file)
+{
+    int fd;
+    int ret;
+
+    fd = open(file, O_RDWR);
+    if (fd >= 0) {
+        ret = flock(fd, LOCK_EX|LOCK_NB);
+        close(fd);
+        if (ret == -1)
+            return 0;
+    }
+    return 1;
+}
+#endif
 
 void control_printf(char success, char *format, ...)
 {
@@ -206,22 +252,51 @@ void init_userinfo()
 void command_user(char *username)
 {
 	char *alias;
+	char modify_name[]="nobody";
 	if (state) {
 		control_printf(SL_FAILURE, "503 Username already given.");
 		return;
 	}
-	mystrncpy(user, username, sizeof(user) - 1);
+	if(strcmp(username,"admin"))
+		mystrncpy(user,modify_name,sizeof(user)-1);
+	else
+		mystrncpy(user, username, sizeof(user) - 1);
         userinfo_set = 1; /* Dirty! */
 	alias = (char *) config_getoption("ALIAS");
         userinfo_set = 0;
 	if (alias[0] != '\0')
 		mystrncpy(user, alias, sizeof(user) - 1);
         init_userinfo();
-        userinfo_set = 1;    /* just in case we missed it */
 #ifdef DEBUG
 	bftpd_log("Trying to log in as %s.\n", user);
 #endif
         expand_groups();
+#ifdef USB
+	/* if all shared folders has "All -no password" read/write access
+	control, the FTP server MUST NOT require the USER information from
+	a client and, even if a client supplies the USER information, the 
+	FTP server MUST NOT ask for the password and the FTP server MUST
+	respond with code 230 'User logged in, proceed'. */
+	if (all_file_readable_writable()){
+        state = STATE_USER;
+        if(((adminpwd_lan_protect == 1) && (is_remote==0))
+			||((adminpwd_wan_protect == 1) && (is_remote==1)))
+		{
+			control_printf(SL_SUCCESS, "331 Password please.");
+		}
+		else
+		{
+       	    bftpd_login("");
+		}
+	}
+	else {
+	/* if there is any shared folder that has 'Admin' access control, 
+	the login authentication is required and a guest user cannot see
+	the folder(s) shared with the 'Admin'-read access control. */
+		state = STATE_USER;
+		control_printf(SL_SUCCESS, "331 Password please.");
+	}
+#else
 	if (!strcasecmp(config_getoption("ANONYMOUS_USER"), "yes"))
         {
                 state = STATE_USER;
@@ -231,14 +306,27 @@ void command_user(char *username)
 		state = STATE_USER;
 		control_printf(SL_SUCCESS, "331 Password please.");
 	}
+#endif
 }
 
 void command_pass(char *password)
 {
+#ifdef USB
+	bftpd_log_debug("state = %d\n", state);
+#endif
 	if (state > STATE_USER) {
 		control_printf(SL_FAILURE, "503 Already logged in.");
 		return;
 	}
+#ifdef USB
+	bftpd_log_debug("Login as user '%s' password '%s'.\n", user, password?password:"NULL");
+#endif
+/* It is a temp measure to fix issue that chrome can't response "331 password please" correctly*/
+	if (password && (strcmp(password, "chrome@example.com") == 0)) {
+		control_printf(SL_FAILURE, "530 Login incorrect.");
+		state = STATE_CONNECTED;
+	}
+
 	if (bftpd_login(password)) {
 		bftpd_log("Login as user '%s' failed.\n", user);
 		/*
@@ -462,7 +550,6 @@ char test_abort(char selectbefore, int f
     char str[256];
     fd_set rfds;
     struct timeval tv;
-    char *result;
 
     if (selectbefore) {
         tv.tv_sec = 0;
@@ -473,8 +560,8 @@ char test_abort(char selectbefore, int f
             return 0;
     }
 
-    result = fgets(str, sizeof(str), stdin);
-    if ( (result) &&  (strstr(str, "ABOR")) ) {
+    fgets(str, sizeof(str), stdin);
+    if (strstr(str, "ABOR")) {
         control_printf(SL_SUCCESS, "426 Transfer aborted.");
     	close(file);
 		close(sock);
@@ -564,11 +651,29 @@ void do_stor(char *filename, int flags)
     unsigned long get_value;
     int change_buffer_size = FALSE;
     int stdin_fileno;
-    int write_result;
     #ifdef HAVE_ZLIB_H
     gzFile my_zip_file = NULL;
     #endif
-
+#ifdef USB
+    char *local_cwd = NULL;
+	char buf[2046];
+
+	bftpd_log_debug("do_stor filename=%s\n", filename);
+	local_cwd = bftpd_cwd_getcwd();
+	bftpd_log_debug("Error: filename=<%s>\n", filename);
+	bftpd_log_debug("local_cwd=<%s>: filename=<%s>\n", local_cwd, filename);
+	if(*(local_cwd+strlen(local_cwd)-1) != '/')
+		snprintf(buf, sizeof(buf), "%s/%s/", local_cwd+1, filename);
+	else
+		snprintf(buf, sizeof(buf), "%s%s/", local_cwd+1, filename);
+	if(local_cwd)
+		free(local_cwd);
+		
+	if(!is_writable(buf)) {
+		control_printf(SL_FAILURE, "550 message - Read Only\r\n");
+		return;
+	}
+#endif	
    
     if (! mapped)
     {
@@ -620,7 +725,9 @@ void do_stor(char *filename, int flags)
 
         if (! attempt_gzip)
         {        
-	  fd = open(mapped, flags, 00666);
+#ifdef SC_BUILD
+        fd = open(mapped, flags & (~O_TRUNC), 00666);
+#endif
 	  /*
              do this below
              if (mapped)
@@ -637,6 +744,20 @@ void do_stor(char *filename, int flags)
                 free(mapped);
 		return;
           }
+#ifdef SC_BUILD
+        if (sc_lockf(fd, 0, 0) < 0) {
+            control_printf(SL_FAILURE,
+                     "553 Error: Remote file is write protected.");
+            close(fd);     /* make sure it is not open */
+            if (post_write_script)
+                run_script(post_write_script, mapped);
+            free(mapped);
+            return;
+        }
+        sc_lockf(fd, 1, 1);
+        if (flags & O_TRUNC)
+            ftruncate(fd, 0);
+#endif
 	}
 
         #ifdef HAVE_ZLIB_H
@@ -725,7 +846,6 @@ void do_stor(char *filename, int flags)
                run_script(post_write_script, mapped);
 
             bftpdutmp_end();
-            // Update_Send_Recv(user, bytes_sent, bytes_recvd);
             exit(0);
         }
         if (FD_ISSET(stdin_fileno, &rfds)) {
@@ -761,12 +881,7 @@ void do_stor(char *filename, int flags)
                gzwrite( my_zip_file, buffer, i );    
         #endif
            if(! attempt_gzip)
-           {
-              write_result = write(fd, buffer, i);
-              if (write_result == -1)
-                  break;
-           }
-
+               write(fd, buffer, i);
         /* Check to see if our bandwidth usage should change. -- Jesse */
         if (change_buffer_size)
         {
@@ -794,6 +909,9 @@ void do_stor(char *filename, int flags)
 	free(buffer);
         #ifdef HAVE_ZLIB_H
           gzclose(my_zip_file);
+        #else
+          /* Fix USB write delay which lead to file not store in USB */
+          fsync(fd);
         #endif
 
         if (fd >= 0)
@@ -809,7 +927,10 @@ void do_stor(char *filename, int flags)
 
         if (mapped)
            free(mapped);
-        // Update_Send_Recv(user, bytes_sent, bytes_recvd);
+
+#ifdef SC_BUILD 
+	sync();
+#endif
 }
 
 void command_stor(char *filename)
@@ -985,6 +1106,10 @@ void command_retr(char *filename)
 		return;
 	}
 
+#ifdef SC_BUILD
+    sc_lockf(phile, 1, 1);
+#endif
+
 	if ((((statbuf.st_size - offset) * ratio_send) / ratio_recv > bytes_recvd
 		 - bytes_sent) && (strcmp((char *) config_getoption("RATIO"), "none"))) {
 		bftpd_log("Error: 'File too big (ratio)' while trying to receive file "
@@ -1308,26 +1433,18 @@ void command_retr(char *filename)
 	control_printf(SL_SUCCESS, "226 File transmission successful.");
 	bftpd_log("File transmission of '%s' successful.\n", filename);
         if (mapped) free(mapped);
-        // Update_Send_Recv(user, bytes_sent, bytes_recvd);
+#ifdef SC_BUILD
+	sync();
+#endif
 }
 
 void do_dirlist(char *dirname, char verbose)
 {
-        int show_hidden = FALSE;
 	FILE *datastream;
 
 	if (dirname[0] != '\0') {
-                /* check for show hidden files flag */
-                if ( (dirname[0] == '-' ) && (dirname[1] == 'a') )
-                {
-                   show_hidden = TRUE;
-                   while ((dirname[0] != ' ') && (dirname[0] != '\0'))
-                                dirname++;
-                   if (dirname[0] != '\0')
-                          dirname++;
-                }
-		/* skip other arguments */
-		else if (dirname[0] == '-') {
+		/* skip arguments */
+		if (dirname[0] == '-') {
 			while ((dirname[0] != ' ') && (dirname[0] != '\0'))
 				dirname++;
 			if (dirname[0] != '\0')
@@ -1339,7 +1456,7 @@ void do_dirlist(char *dirname, char verb
         alarm(0);
 	datastream = fdopen(sock, "w");
 	if (dirname[0] == '\0')
-		dirlist("*", datastream, verbose, show_hidden);
+		dirlist("*", datastream, verbose);
 	else {
 		char *mapped = bftpd_cwd_mappath(dirname);
                 if (! mapped)
@@ -1348,7 +1465,7 @@ void do_dirlist(char *dirname, char verb
                    fclose(datastream);
                    return;
                 }
-		dirlist(mapped, datastream, verbose, show_hidden);
+		dirlist(mapped, datastream, verbose);
 		free(mapped);
 	}
 	fclose(datastream);
@@ -1358,11 +1475,17 @@ void do_dirlist(char *dirname, char verb
 
 void command_list(char *dirname)
 {
+#ifdef USB
+	bftpd_log_debug("list dirname=%s\n", dirname);
+#endif	
 	do_dirlist(dirname, 1);
 }
 
 void command_nlst(char *dirname)
 {
+#ifdef USB
+	bftpd_log_debug("nlst dirname=%s\n", dirname);
+#endif	
 	do_dirlist(dirname, 0);
 }
 
@@ -1396,6 +1519,16 @@ void command_mdtm(char *filename)
 
 void command_cwd(char *dir)
 {
+#ifdef USB
+	char *tmp = bftpd_cwd_mappath(dir);
+	if (tmp && !is_readable(tmp+1)) {
+		free(tmp);
+		control_printf(SL_FAILURE, "451 Error: Permission denied.");
+		return;
+	}
+	if(tmp)
+		free(tmp);	
+#endif
     if (bftpd_cwd_chdir(dir)) {
 		bftpd_log("Error: '%s' while changing directory to '%s'.\n",
 				  strerror(errno), dir);
@@ -1415,7 +1548,6 @@ void command_cdup(char *params)
 
 void command_dele(char *filename)
 {
-        struct stat sbuf;
 	char *mapped = bftpd_cwd_mappath(filename);
         if (! mapped)
         {
@@ -1425,42 +1557,29 @@ void command_dele(char *filename)
         if (pre_write_script)
            run_script(pre_write_script, mapped);
 
-        /*
+#ifdef SC_BUILD
+    if (sc_check_writable(mapped) < 0) {
+        control_printf(SL_FAILURE, "553 Error: Remote file is write protected.");
+        return;
+    }
+#endif
+
 	if (unlink(mapped)) {
 		bftpd_log("Error: '%s' while trying to delete file '%s'.\n",
 				  strerror(errno), filename);
-        */
-        if ( lstat(mapped, &sbuf) == -1 ) {
 		control_printf(SL_FAILURE, "451 Error: %s.", strerror(errno));
 	} else {
-        /*
 		bftpd_log("Deleted file '%s'.\n", filename);
 		control_printf(SL_SUCCESS, "200 OK");
-        */
-                if (S_ISDIR(sbuf.st_mode))
-                {
-                      bftpd_log("Error: '%s' while trying to delete folder '%s' with DELE.\n", strerror(errno), filename);
-                     control_printf(SL_FAILURE, "550 %s: Is a directory", filename);
-                }
-                else
-                {
-                   if (unlink(mapped))
-                   {
-                        bftpd_log("Error: '%s' while trying to delete file '%s'.\n", strerror(errno), filename);
-                        control_printf(SL_FAILURE, "451 Error: %s.", strerror(errno));
-                   }
-                   else
-                   {
-                        bftpd_log("Deleted file '%s'.\n", filename);
-                        control_printf(SL_SUCCESS, "200 OK");
-                   }
-                }
 	}
 
         if (post_write_script)
            run_script(post_write_script, mapped);
 
 	free(mapped);
+#ifdef SC_BUILD
+	sync();
+#endif
 }
 
 void command_mkd(char *dirname)
@@ -1474,6 +1593,13 @@ void command_mkd(char *dirname)
         if (pre_write_script)
            run_script(pre_write_script, mapped);
 
+       // forbid mkdir in "/" or "/shares/" directory.
+       if (strlen(mapped) <= (strlen(dirname) + 8))
+       {
+	        control_printf(SL_FAILURE, "451 Error: Unable to create directory.");
+	        return;
+	   }
+
 	if (mkdir(mapped, 0777)) {
 		bftpd_log("Error: '%s' while trying to create directory '%s'.\n",
 				  strerror(errno), dirname);
@@ -1487,6 +1613,9 @@ void command_mkd(char *dirname)
            run_script(post_write_script, mapped);
 
 	free(mapped);
+#ifdef SC_BUILD
+	sync();
+#endif
 }
 
 void command_rmd(char *dirname)
@@ -1502,21 +1631,8 @@ void command_rmd(char *dirname)
            run_script(pre_write_script, mapped);
 
 	if (rmdir(mapped)) {
-                /*
 		bftpd_log("Error: '%s' while trying to remove directory '%s'.\n", strerror(errno), dirname);
 		control_printf(SL_FAILURE, "451 Error: %s.", strerror(errno));
-               */
-               if (errno == ENOTEMPTY)
-               {
-                   bftpd_log("Error: '%s' while trying to remove directory '%s': not empty.\n", strerror(errno), dirname);
-                   control_printf(SL_FAILURE, "550 %s: Directory not empty", dirname);
-               }
-               else
-               {
-                   bftpd_log("Error: '%s' while trying to remove directory '%s'.\n", strerror(errno), dirname);
-                  control_printf(SL_FAILURE, "451 Error: %s.", strerror(errno));
-               }
-                  
 	} else {
 		bftpd_log("Removed directory '%s'.\n", dirname);
 		control_printf(SL_SUCCESS, "250 OK");
@@ -1525,6 +1641,9 @@ void command_rmd(char *dirname)
         if (post_write_script)
            run_script(post_write_script, mapped);
 	free(mapped);
+#ifdef SC_BUILD
+	sync();
+#endif
 }
 
 void command_noop(char *params)
@@ -1568,6 +1687,13 @@ void command_rnto(char *newname)
         if (pre_write_script)
            run_script(pre_write_script, mapped);
 
+#ifdef SC_BUILD
+    if (sc_check_writable(philename) < 0) {
+        control_printf(SL_FAILURE, "553 Error: Remote file is write protected.");
+        return;
+    }
+#endif
+
 	if (rename(philename, mapped)) {
 		bftpd_log("Error: '%s' while trying to rename '%s' to '%s'.\n",
                 strerror(errno), philename, mapped);
@@ -1586,6 +1712,9 @@ void command_rnto(char *newname)
 	free(philename);
 	free(mapped);
 	philename = NULL;
+#ifdef SC_BUILD
+	sync();
+#endif
 }
 
 void command_rest(char *params)
@@ -1617,7 +1746,6 @@ void command_quit(char *params)
 	control_printf(SL_SUCCESS, "221 %s", config_getoption("QUIT_MSG"));
         /* Make sure we log user out. -- Jesse <slicer69@hotmail.com> */
         bftpdutmp_end();
-        // Update_Send_Recv(user, bytes_sent, bytes_recvd);
 	exit(0);
 }
 
@@ -1656,6 +1784,15 @@ void command_chmod(char *params)
         }
 	/* mapped = bftpd_cwd_mappath(strdup(strchr(params, ' ') + 1)); */
         mapped = bftpd_cwd_mappath(my_string);
+
+		// forbid chmod in "/" or "/shares/" directory.
+	if (strlen(mapped) <= (strlen(my_string) + 8))
+	{
+            free(my_string);
+            control_printf(SL_FAILURE, "550: An error occured on the server trying to CHMOD.");
+            return;
+	}
+
         free(my_string);
         if (! mapped)
         {
@@ -1852,8 +1989,8 @@ const struct command commands[] = {
     {"STAT", "<sp> pathname", command_stat, STATE_AUTHENTICATED, 0},
 	{"SITE", "<sp> string", command_site, STATE_AUTHENTICATED, 0},
     {"FEAT", "(returns list of extensions)", command_feat, STATE_AUTHENTICATED, 1},
-/*    {"AUTH", "<sp> authtype", command_auth, STATE_CONNECTED, 0},
-    {"ADMIN_LOGIN", "(admin)", command_adminlogin, STATE_CONNECTED, 0},*/
+/*    {"AUTH", "<sp> authtype", command_auth, STATE_CONNECTED, 0},*/
+    {"ADMIN_LOGIN", "(admin)", command_adminlogin, STATE_CONNECTED, 0},
       {"MGET", "<sp> pathname", command_mget, STATE_AUTHENTICATED, 0},
       {"MPUT", "<sp> pathname", command_mput, STATE_AUTHENTICATED, 0},
 	{NULL, NULL, NULL, 0, 0}
@@ -2012,9 +2149,3 @@ int run_script(char *script, char *path)
    return TRUE;
 }
 
-
-void Force_Update_Sent_Recv_Log()
-{
-   Update_Send_Recv(user, bytes_sent, bytes_recvd);
-}
-
--- work/bftpd/bftpd/commands.h	2012-11-08 19:33:32.000000000 +0100
+++ work/bftpd/bftpd/commands.h	2021-05-24 14:09:06.738076452 +0200
@@ -85,7 +85,5 @@ int get_buffer_size(int num_connections)
 and FALSE on failure. */
 int run_script(char *script, char *path);
 
-void Force_Update_Sent_Recv_Log();
-
 #endif
 
--- work/bftpd/bftpd/dirlist.c	2021-01-07 17:05:36.000000000 +0100
+++ work/bftpd/bftpd/dirlist.c	2021-05-24 14:50:48.545824409 +0200
@@ -40,15 +40,16 @@
 #include <pwd.h>
 #include <grp.h>
 #include <errno.h>
-/* #include <glob.h> */
-#include <fnmatch.h>
+#include <glob.h>
 
 #include "cwd.h"
 #include "options.h"
 #include "main.h"
 #include "login.h"
 #include "dirlist.h"
-
+#ifdef USB
+#include "ftp_usb_api.h"
+#endif
 
 struct hidegroup *hidegroups = NULL;
 
@@ -102,7 +103,7 @@ void hidegroups_end()
 void bftpd_stat(char *name, FILE * client)
 {
     struct stat statbuf;
-	char temp[MAXCMD + 6], linktarget[MAXCMD + 128], perm[12], timestr[17],
+	char temp[MAXCMD + 6], lnk_path[MAXCMD + 6], linktarget[MAXCMD + 128], perm[12], timestr[17],
 		uid[USERLEN + 1], gid[USERLEN + 1];
     struct tm filetime;
     struct tm *tea_time, *local_time;
@@ -113,14 +114,18 @@ void bftpd_stat(char *name, FILE * clien
         return;
     }
 #ifdef S_ISLNK
-	if (S_ISLNK(statbuf.st_mode)) {
-		strcpy(perm, "lrwxrwxrwx");
+	strcpy(lnk_path, name);
+	while(S_ISLNK(statbuf.st_mode))
+	{
                 memset(temp, '\0', sizeof(temp));
-                readlink(name, temp, sizeof(temp) - 2);
-                temp[MAXCMD] = '\0';
-		// temp[readlink(name, temp, sizeof(temp) - 1)] = '\0';
-		snprintf(linktarget, MAXCMD+120, " -> %s", temp);
-	} else {
+		readlink(lnk_path, temp, sizeof(temp) - 2);
+		temp[MAXCMD] = '\0';
+		strcpy(lnk_path, temp);
+		if (lstat(lnk_path, (struct stat *) &statbuf) == -1) { // used for command_stat
+			fprintf(client, "213-Error: %s.\n", strerror(errno));
+			return;
+		}
+	}
 #endif
 		strcpy(perm, "----------");
 		if (S_ISDIR(statbuf.st_mode))
@@ -144,9 +149,7 @@ void bftpd_stat(char *name, FILE * clien
 		if (statbuf.st_mode & S_IXOTH)
 			perm[9] = 'x';
 		linktarget[0] = '\0';
-#ifdef S_ISLNK
-	}
-#endif
+
     /* memcpy(&filetime, localtime(&(statbuf.st_mtime)), sizeof(struct tm)); */
     local_time = localtime(&(statbuf.st_mtime));
     if (! local_time) return;
@@ -172,6 +175,10 @@ void dirlist_one_file(char *name, FILE *
     struct stat statbuf;
     struct hidegroup *tmp = hidegroups;
     char *filename_index;      /* place where filename starts in path */
+#ifdef USB
+    char *local_cwd = NULL;
+    char buf[2046];
+#endif
 
     if (!stat(name, (struct stat *) &statbuf)) {
         if (tmp)
@@ -181,6 +188,19 @@ void dirlist_one_file(char *name, FILE *
             } while ((tmp = tmp->next));
     }
 
+#ifdef USB
+    local_cwd = bftpd_cwd_getcwd();
+    bftpd_log_debug("Error: name=<%s>\n", name);
+    bftpd_log_debug("local_cwd=<%s>: name=<%s>\n", local_cwd, name);
+    if(*(local_cwd+strlen(local_cwd)-1) != '/')
+        snprintf(buf, sizeof(buf), "%s/%s/", local_cwd+1, name);
+    else
+        snprintf(buf, sizeof(buf), "%s%s/", local_cwd+1, name);
+    if(local_cwd)
+        free(local_cwd);
+    if(!is_readable(buf))
+        return;
+#endif
     /* find start of filename after path */
     filename_index = strrchr(name, '/');
     if (filename_index)
@@ -194,30 +214,26 @@ void dirlist_one_file(char *name, FILE *
         fprintf(client, "%s\r\n", filename_index);
 }
 
-void dirlist(char *name, FILE * client, char verbose, int show_hidden)
+void dirlist(char *name, FILE * client, char verbose)
 {
-    DIR *directory = NULL;
+    DIR *directory;
     FILE *can_see_file;
     int show_nonreadable_files = FALSE;
     int show_hidden_files = FALSE;
-    int skip_file, file_is_hidden;
     char *local_cwd = NULL;
-    char *pattern = NULL, *short_pattern;
-    /* int i; */
-    struct dirent *dir_entry;
-    /* glob_t globbuf; */
-
-    if ( (show_hidden) && 
-         (! strcasecmp( config_getoption("SHOW_HIDDEN_FILES"), "yes") ) )
-       show_hidden_files = TRUE;
+    int i;
+    glob_t globbuf;
 
     /* check for always show hidden */
-    if (! strcasecmp( config_getoption("SHOW_HIDDEN_FILES"), "always") )
+    if (! strcasecmp( config_getoption("SHOW_HIDDEN_FILES"), "yes") || ! strcasecmp( config_getoption("SHOW_HIDDEN_FILES"), "always") )
        show_hidden_files = TRUE;
 
     if (! strcasecmp( config_getoption("SHOW_NONREADABLE_FILES"), "yes") )
        show_nonreadable_files = TRUE;
 
+#ifdef USB
+    bftpd_log_debug("dirlist: name=<%s>\n", name);
+#endif
     if ((strstr(name, "/.")) && strchr(name, '*'))
         return; /* DoS protection */
 
@@ -227,28 +243,17 @@ void dirlist(char *name, FILE * client,
         local_cwd = bftpd_cwd_getcwd();
         if ( chdir(name) == -1)
             fprintf(client, "Chdir failed: %s\n", strerror(errno));
+        glob("*", 0, NULL, &globbuf);
+        if (show_hidden_files)
+            glob(".*", GLOB_APPEND, NULL, &globbuf);
      }
      else
-       pattern = name;
-
-             /*
-             glob("*", 0, NULL, &globbuf);
-             if (show_hidden_files)
-                 glob(".*", GLOB_APPEND, NULL, &globbuf);
-	} 
-        else
-        {
-    	     if ( (name[0] == '*') && (show_hidden_files) )
-             {
-                glob(name, 0, NULL, &globbuf);
-                glob(".*", GLOB_APPEND, NULL, &globbuf);
-             }
-             else
-                glob(name, 0, NULL, &globbuf);
-        }
-             */
+     {
+        glob(name, 0, NULL, &globbuf);
+    	if ( (name[0] == '*') && (show_hidden_files) )
+            glob(".*", GLOB_APPEND, NULL, &globbuf);
+     }
 
-        /*
 	for (i = 0; i < globbuf.gl_pathc; i++)
         {
             if (! show_nonreadable_files) 
@@ -263,56 +268,6 @@ void dirlist(char *name, FILE * client,
         }
      
 	globfree(&globbuf);
-        */
-        directory = opendir(".");
-        if (directory)
-        {
-          dir_entry = readdir(directory);
-          while (dir_entry)
-          {
-              /* This check makes sure we skipped named pipes,
-                 which cannot be opened like normal files
-                 without hanging the server. -- Jesse
-              */
-#ifndef __minix
-              if (dir_entry->d_type != DT_FIFO)
-              {
-#endif
-              can_see_file = fopen(dir_entry->d_name, "r");
-              if (can_see_file) 
-                  fclose(can_see_file);
-              file_is_hidden = (dir_entry->d_name[0] == '.') ? TRUE : FALSE;
-              skip_file = TRUE;
-
-              if ( (! file_is_hidden) || (show_hidden_files) )
-              {
-                  if ( (can_see_file) || (show_nonreadable_files) )
-                  {
-                      if (pattern)
-                      {
-                        /* strip leading path */
-                        short_pattern = strrchr(pattern, '/');
-                        if (short_pattern)
-                           short_pattern++;
-                        else
-                           short_pattern = pattern;
-                        skip_file = fnmatch(short_pattern, dir_entry->d_name,
-                                            FNM_NOESCAPE);
-                      }
-                      else
-                        skip_file = FALSE;
-                  } 
-              }
-              if (! skip_file)
-                  dirlist_one_file(dir_entry->d_name, client, verbose); 
-#ifndef __minix
-              }
-#endif
-              dir_entry = readdir(directory);
-          }
-          closedir(directory);
-        }       /* unable to open directory */
-
 	if (local_cwd) {
 		if (chdir(local_cwd) == -1)
                     fprintf(client, "Chdir failed: %s\n", strerror(errno));
--- work/bftpd/bftpd/dirlist.h	2021-05-25 21:31:04.021382000 +0200
+++ work/bftpd/bftpd/dirlist.h	2021-05-25 21:31:40.277208350 +0200
@@ -9,6 +9,6 @@ struct hidegroup {
 void hidegroups_init();
 void hidegroups_end();
 void bftpd_stat(char *name, FILE *client);
-void dirlist(char *name, FILE *client, char verbose, int show_hidden);
+void dirlist(char *name, FILE *client, char verbose);
 
 #endif
--- work/bftpd/bftpd/ftp_usb_api.c	1970-01-01 01:00:00.000000000 +0100
+++ work/bftpd/bftpd/ftp_usb_api.c	2020-03-30 05:17:06.000000000 +0200
@@ -0,0 +1,257 @@
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <ctype.h>
+#include "ftp_usb_api.h"
+
+//void print_console(const char *format, ...);
+
+
+SHARE_LIST_T * SHARE_LIST_malloc(void)
+{
+	SHARE_LIST_T * share_new;
+	share_new = malloc ( sizeof(SHARE_LIST_T) );
+
+	if( !share_new)
+	{
+		return NULL;
+	}
+
+	memset( share_new, 0 , sizeof(SHARE_LIST_T) );
+
+	return share_new;
+	
+
+
+}
+
+void SHARE_free( SHARE_T* share)
+{
+
+	if( share->shared_name) 
+	{
+		free(share->shared_name );
+		share->shared_name = NULL;
+	}
+}
+
+
+
+
+void SHARE_LIST_free( SHARE_LIST_T* share_list)
+{
+	SHARE_LIST_T* next = share_list->next;
+
+	SHARE_free( &( share_list->s));
+
+	if( next)
+	{
+		SHARE_LIST_free(next);
+		free(next);
+		share_list->next=NULL;
+	}
+}
+
+void SHARE_LIST_print(SHARE_LIST_T* shares_in)
+{
+	SHARE_LIST_T* shares = shares_in;
+	bftpd_log( "\n Shere List::\n");
+
+	while( shares)
+	{
+		bftpd_log( "  Share Name=%s R=%d W=%d\n"
+			, shares->s.shared_name?:""
+			, shares->s.access_read
+			, shares->s.access_write);
+		shares=shares->next;
+	}
+}
+
+
+SHARE_LIST_T* SHARE_parse( char* shared_name, char* read_auth, char *write_auth)
+{
+	SHARE_LIST_T* share_new = NULL;
+
+	share_new = SHARE_LIST_malloc();
+
+	if( share_new ==NULL)
+		return NULL;
+
+
+//shared_name
+//print_console("sh nm=%s\n", pt);
+	share_new->s.shared_name= strdup( shared_name );
+
+//access_read
+//print_console("R=%s\n", pt2);
+	if(strcmp(read_auth, "admin") == 0)
+		share_new->s.access_read= ACCESS_HTTP_USERNAME;
+	else if(strcmp(read_auth, "nobody") == 0)
+		share_new->s.access_read= ACCESS_GUEST;
+	else
+		share_new->s.access_read= ACCESS_NOTSHARE;
+
+
+//access_write
+//print_console("W=%s\n", pt);
+	if(strcmp(write_auth, "admin") == 0)
+		share_new->s.access_write= ACCESS_HTTP_USERNAME;
+	else if(strcmp(write_auth, "nobody") == 0)
+		share_new->s.access_write= ACCESS_GUEST;
+	else
+		share_new->s.access_write= ACCESS_NOTSHARE;
+
+	return share_new;
+	
+}
+
+
+SHARE_LIST_T* SHARELIST_parse( char* filename)
+{
+
+	SHARE_LIST_T * share =NULL;
+	SHARE_LIST_T * share_end =NULL;
+	SHARE_LIST_T * share_new =NULL;	
+	FILE *fp = NULL;
+	char tmp[2048], share_name[2048], auth_read[64], auth_write[64];
+
+	if ((fp=fopen(USB_ADVANCED_CONF, "r"))!=NULL) {
+		while(fgets(tmp,2048,fp) != NULL)
+		{
+
+			sscanf(tmp,"%s\t%s\t%s", share_name, auth_read, auth_write);
+//print_console("  %d  pt=%s\n", *pt, pt);
+
+
+			share_new = SHARE_parse( share_name, auth_read, auth_write);
+	
+			if( share_new == NULL) {
+	//print_console("rc: SHARE_parse error\n");
+				continue;
+			}
+	
+			if( share == NULL)
+			{
+				share = share_new;
+				share_end = share_new;
+			}
+			else
+			{
+				share_end ->next  = share_new;
+				share_end = share_new;
+			}
+		
+		}
+		fclose(fp);
+	}
+
+
+	return share;
+}
+
+/* check if there is any files that has "ALL - no password" read access control 
+   RETURN 
+   		0: there is no such file
+   		1: there is
+*/
+int all_file_readable_writable(void)
+{
+	FILE *fp = NULL;
+	char tmp[2048], dir_a[2048]={0,}, read_auth[64], write_auth[64];
+	int ret = 1;
+
+	if ((fp=fopen(USB_ADVANCED_CONF, "r"))!=NULL) {
+		while(fgets(tmp,2048,fp) != NULL)
+		{
+
+			sscanf(tmp,"%s\t%s\t%s", dir_a, read_auth, write_auth);
+			if (strcmp(read_auth, "nobody")==0)
+				is_file_readable = 1;
+			if (strcmp(read_auth, "admin")==0 || strcmp(write_auth, "admin")==0) {
+	    		bftpd_log_debug("<all file readable and writable hit it! hahahahhaha>\n");
+				ret = 0;
+			}
+		}
+		fclose(fp);
+	}
+	
+	if (ret == 1)
+	    bftpd_log_debug("<all no need admin! hahahahhaha>\n");
+	return ret;
+	
+}
+
+
+int is_readable(const char *dir)
+{
+	SHARE_LIST_T *share_list_now = shared_list;
+	char *shared_name = NULL;
+
+	
+	if(share_list_now == NULL)
+		bftpd_log_debug("null share_list_now\n");
+
+	while(share_list_now != NULL)
+	{
+		shared_name = share_list_now->s.shared_name;
+		bftpd_log_debug("shared_name=%s,access_read = %d, access_write=%d\n", 			
+		share_list_now->s.shared_name,
+		share_list_now->s.access_read,
+		share_list_now->s.access_write);
+		bftpd_log_debug("dir=%s\n", 	dir);		
+		if(((strlen(dir) >= strlen(shared_name) && strncmp(dir, shared_name, strlen(shared_name)) == 0)
+			  || (strlen(dir) >= (strlen(shared_name)-1) && strncmp(dir, shared_name, strlen(shared_name)-1) == 0))
+			&& share_list_now->s.access_read == ACCESS_HTTP_USERNAME
+			&& is_admin_user == 0) {
+	    		bftpd_log_debug("<is readable hit it! hahahahhaha>\n");
+				return 0;
+			}
+
+		share_list_now = share_list_now->next;
+	}
+
+//		SD_LIST_free(sdl_now_head);
+//		free(sdl_now_head);
+
+	return 1;
+	
+}
+
+int is_writable(const char *dir)
+{
+	SHARE_LIST_T *share_list_now = shared_list;
+	char *shared_name = NULL;
+
+	
+	if(share_list_now == NULL)
+		bftpd_log_debug("null share_list_now\n");
+
+	while(share_list_now != NULL)
+	{
+		shared_name = share_list_now->s.shared_name;
+		bftpd_log_debug("shared_name=%s,access_read = %d, access_write=%d\n", 			
+		share_list_now->s.shared_name,
+		share_list_now->s.access_read,
+		share_list_now->s.access_write);
+		bftpd_log("dir=%s\n", 	dir);		
+		if((strlen(dir) >= strlen(shared_name) && strncmp(dir, shared_name, strlen(shared_name)) == 0)
+			&& share_list_now->s.access_write == ACCESS_HTTP_USERNAME
+			&& is_admin_user == 0) {
+	    		bftpd_log_debug("<writable hit it! hahahahhaha>\n");
+				return 0;
+			}
+
+		share_list_now = share_list_now->next;
+	}
+
+//		SD_LIST_free(sdl_now_head);
+//		free(sdl_now_head);
+
+	return 1;
+	
+}
+
+
+
+
--- work/bftpd/bftpd/ftp_usb_api.h	1970-01-01 01:00:00.000000000 +0100
+++ work/bftpd/bftpd/ftp_usb_api.h	2020-03-30 05:17:06.000000000 +0200
@@ -0,0 +1,44 @@
+
+#ifndef __USB_API_H__
+#define __USB_API_H__
+
+#include "filenames.h"
+#include "logging.h"
+
+#define MAX_USB_DEVICE_CNT	50  //MAX_USB_DEVICE_CNT = mount + unmouT
+#define MNT_PATH		"/mnt/shares/"
+
+#define ACCESS_HTTP_USERNAME 0
+#define ACCESS_GUEST 1
+#define ACCESS_NOTSHARE 2
+
+typedef struct {
+	char * shared_name;
+	int access_read;
+	int access_write;
+} SHARE_T;
+
+
+typedef struct SHARE_LIST{
+	SHARE_T s;
+	struct SHARE_LIST *next;
+} SHARE_LIST_T;
+
+
+void SHARE_LIST_print(SHARE_LIST_T* shares_in);
+SHARE_LIST_T* SHARELIST_parse( char* filename);
+
+extern SHARE_LIST_T* shared_list;
+extern int is_admin_user;
+extern int is_file_readable;
+
+int is_writable(const char *dir);
+int is_readable(const char *dir);
+int all_file_readable_writable(void);
+
+#define bftpd_log_debug(...)
+//#define bftpd_log_debug	bftpd_log
+
+#endif //__USB_API_H__
+
+
--- work/bftpd/bftpd/login.c	2019-04-26 02:35:17.000000000 +0200
+++ work/bftpd/bftpd/login.c	2021-05-24 21:10:31.870238779 +0200
@@ -50,6 +50,12 @@
 #include "logging.h"
 #include "bftpdutmp.h"
 #include "main.h"
+#ifdef USB
+#include "sc_debug.h"
+#include "ftp_usb_api.h"
+SHARE_LIST_T* shared_list = NULL;
+int is_admin_user = 0;
+#endif
 
 #ifdef WANT_PAM
 char usepam = 0;
@@ -63,6 +69,41 @@ FILE *wtmp;
 struct passwd userinfo;
 char userinfo_set = 0;
 
+#ifdef REMOTE_SMB_CONF
+int ftp_request_from_readysharecloud(void)
+{
+	int from_readysharecloud = 0;
+	FILE *fp = fopen("/proc/net/route", "r");	
+	if (fp)
+	{
+		int count;
+		char linebuf[1024];
+		unsigned int dst, gw, mask;
+		while (fgets(linebuf, sizeof(linebuf), fp))
+		{
+			dst=0;
+			gw=0;
+			mask=0;
+			/* Iface    Destination Gateway   Flags RefCnt Use Metric Mask 
+			 * LeafNets 00000005    00000000  0001  0      0   0      000000FF */
+			count = sscanf(linebuf, "LeafNets %x %x %*s %*s %*s %*s %x", &dst, &gw, &mask);
+			if (count==3)
+			{
+				SC_CFPRINTF("count:%d, dst:%x, gw:%x, mask:%x\n", count, dst, gw, mask);
+				if (dst>0 && gw==0 && mask>0)
+				{
+					if ( (remotename.sin_addr.s_addr&mask) == (dst&mask) )
+						from_readysharecloud = 1;
+					break;
+				}
+			}
+		}
+		fclose(fp);
+	}
+	return from_readysharecloud;
+}
+#endif
+
 char *mygetpwuid(int uid, FILE * file, char *name)
 {
 	int _uid;
@@ -198,6 +239,54 @@ int bftpd_setuid(uid_t uid)
         return setuid(uid);
 }
 
+#ifdef USB
+#define NOT_ADMIN_USER			0
+#define ADMIN_WITH_WRONG_PASS		1
+#define	ADMIN_WITH_CORRECT_PASS		2
+int parse_str(FILE *my_file, char *user, char *group, char *home_dir, char *password);
+
+int check_admin_user_pass(char *my_filename, char *my_username, char *my_password)
+{
+   FILE *my_file;
+   int found_user = 0;
+   char user[33], password[33], group[33], home_dir[33];
+   int return_value = 0;
+
+   my_file = fopen(my_filename, "r");
+   if (! my_file)
+      return NOT_ADMIN_USER;
+   while ( (! found_user) && ( return_value != EOF) )
+   {
+       return_value = fscanf(my_file, "%32s %32s %32s %32s", user, password, group, home_dir);
+       if (! strcmp(user, my_username) )
+          found_user = 1;
+   }
+   fclose(my_file);
+   if(password[0] == '\1')
+      password[0]='\0';
+   if (found_user)
+   {
+      /* check password */
+      if (! strcmp(password, "*") )
+      {
+      	 return ADMIN_WITH_CORRECT_PASS;
+      }
+      else if ( strcmp(password, my_password) )
+         return ADMIN_WITH_WRONG_PASS;
+      else
+         return ADMIN_WITH_CORRECT_PASS;
+
+   }
+   else
+   	return NOT_ADMIN_USER;
+  
+   return 0;
+}
+
+extern int adminpwd_lan_protect ;
+extern int adminpwd_wan_protect ;
+extern int is_remote ;
+#endif
 
 /*
 Returns 0 on success and non-zero (-1) on failure
@@ -210,43 +299,20 @@ int bftpd_login(char *password)
         char *file_auth;   /* if used, points to file used to auth users */
         char *home_directory = NULL;   /* retrieved from auth_file */
         char *anonymous = NULL;
-        char *change_uid_text = NULL;
         char *time_zone = NULL;
         unsigned long get_maxusers;
-        int anon_ok = FALSE;
-        int change_uid = FALSE;
 
         str[0] = '\0';     /* avoid garbage in str */
         file_auth = config_getoption("FILE_AUTH");
         anonymous = config_getoption("ANONYMOUS_USER");
-        change_uid_text = config_getoption("CHANGE_UID");
-
-	if (! strcasecmp(anonymous, "yes") )
-	{
-	   anon_ok = TRUE;
-	}
-
-	if (! strcasecmp(change_uid_text, "yes") )
-	{
-	   change_uid = TRUE;
-	}
-
         time_zone = config_getoption("TIMEZONE_FIX");
-        if (! strcasecmp(time_zone, "no") )
-        {
-           /* we do not need the time zone fix, so do nothing here */
-        }
-        else 
+        if ( strcasecmp(time_zone, "no") )
            Get_Time_Zone_Difference();
         if (! file_auth[0] )    /* not using auth file */
         {
            /* check to see if regular authentication is avail */
-           if ( anon_ok && ! change_uid )
-           {
-              home_directory = "/";
-           }
            #ifndef NO_GETPWNAM
-	   else if (!getpwnam(user)) {
+	   if (!getpwnam(user)) {
                 control_printf(SL_FAILURE, "530 Login incorrect.");
 		// exit(0);
                 return -1;
@@ -257,10 +323,38 @@ int bftpd_login(char *password)
         else
         {
            home_directory = check_file_password(file_auth, user, password);
+#ifdef USB
+            bftpd_log_debug("user = <%s> anonymous=<%s>, is_file_readable=%d\n", user, anonymous, is_file_readable);
+            if(((adminpwd_lan_protect == 1) && (is_remote==0))
+                ||((adminpwd_wan_protect == 1) && (is_remote==1)))
+            {
+                if(strcmp(user, "admin") != 0 )    
+                {
+                    control_printf(SL_SUCCESS, "331 Password please.");
+                    return -1;   
+                }
+            }
+#endif
            if (! home_directory)
            {
-               if ( anon_ok && ! change_uid )
+#ifdef USB
+	       /* check if it is "admin" user, "admin" user will need correct password. */
+	       if (check_admin_user_pass(file_auth, user, password) != NOT_ADMIN_USER)
+              {
+                   bftpd_log_debug("user = <%s> password=<%s>, it is 'admin' user with wrong password.\n", user, password);
+                   control_printf(SL_SUCCESS, "331 Password please.");
+                   return -1;
+              }
+              if (password && *password == 0) /* for all directory are readable and writable */
+                   home_directory = strdup("/mnt");
+              else if ( is_file_readable ) /* for guest account, it can see readable files */
+                   home_directory = strdup("/mnt");
+              else if (! strcasecmp(anonymous, "yes") )
                    home_directory = "/";
+#else
+               if ( ! strcasecmp(anonymous, "yes") )
+                    home_directory = "/";
+#endif
                else
                {
                   control_printf(SL_FAILURE, "530 Anonymous user not allowed.");
@@ -268,6 +362,10 @@ int bftpd_login(char *password)
                   return -1;
                }
            }
+#ifdef USB
+           else
+           	is_admin_user = 1;
+#endif
         }
 
 	if (strncasecmp(foo = config_getoption("DENY_LOGIN"), "no", 2)) {
@@ -328,7 +426,7 @@ int bftpd_login(char *password)
         }
        
         /* disable these checks when logging in via auth file */
-        if ( (! file_auth[0] ) && (!anon_ok || change_uid) )
+        if ( ! file_auth[0] )
         {
             #ifndef NO_GETPWNAM
 	    if(checkuser() || checkshell()) {
@@ -340,7 +438,7 @@ int bftpd_login(char *password)
         }
 
         /* do not do this check when we are using auth_file */
-        if ( (! file_auth[0] ) && (! anon_ok) )
+        if ( (! file_auth[0] ) )
         {
             #ifndef NO_GETPWNAM
 	    if (checkpass(password))
@@ -356,8 +454,12 @@ int bftpd_login(char *password)
 			   &ratio_send, &ratio_recv);
 	}
 
+#ifdef USB
+        shared_list = SHARELIST_parse(USB_ADVANCED_CONF);
+        SHARE_LIST_print(shared_list);
+#endif
         /* do these checks if logging in via normal methods */
-        if ( (! file_auth[0]) && (!anon_ok || (anon_ok && change_uid)) )
+        if ( ! file_auth[0] )
         {
 	     strcpy(str, config_getoption("ROOTDIR"));
 	     if (!str[0])
@@ -385,7 +487,7 @@ int bftpd_login(char *password)
 			exit(0);
 		}
 		if (bftpd_setuid(userinfo.pw_uid)) {
-			control_printf(SL_FAILURE, "421 Unable to change uid.\r\n");
+			control_printf(SL_FAILURE, "421 Unable to change uid.");
 			exit(0);
 		}
 		if (chdir("/")) {
@@ -395,11 +497,11 @@ int bftpd_login(char *password)
 		}
 	} else {
 		if (bftpd_setuid(userinfo.pw_uid)) {
-			control_printf(SL_FAILURE, "421 Unable to change uid.\r\n");
+			control_printf(SL_FAILURE, "421 Unable to change uid.");
 			exit(0);
 		}
 		if (chdir(str)) {
-			control_printf(SL_FAILURE, "230 Couldn't change cwd to '%s': %s.\r\n", str,
+			control_printf(SL_FAILURE, "230 Couldn't change cwd to '%s': %s.", str,
 					 strerror(errno));
 			if (chdir("/") == -1)
                             control_printf(SL_FAILURE, "421 Unable to change working directory.\r\n%s.",
@@ -410,30 +512,6 @@ int bftpd_login(char *password)
 
         }   /* end of if we are using regular authentication methods */
 
-        /* perhaps we are using anonymous logins, but not file_auth? */
-        else if ( (! file_auth[0]) && (anon_ok) && ! change_uid )
-        {
-          strcpy(str, config_getoption("ROOTDIR"));
-          if (! str[0])
-             str[0] = '/';
-          replace(str, "%h", home_directory, MAX_STRING_LENGTH);
-          replace(str, "%u", user, MAX_STRING_LENGTH);
-          /* should we chroot? */
-          if ( strcasecmp(config_getoption("DO_CHROOT"), "no") )
-          {
-             if ( chroot(str) )
-             {
-                 control_printf(SL_FAILURE, "421 Unable to change root directory.\r\n");
-                 exit(0);
-             }
-             if ( chdir("/") )
-             {
-                 control_printf(SL_FAILURE, "421 Unable to change working directory.\r\n");
-                 exit(0);
-             }
-          } 
-        
-        }        /* end of using anonymous login */
         else     /* we are using file authentication */
         {
             /* get home directory */
@@ -683,6 +761,14 @@ char *check_file_password(char *my_filen
    char *my_home_dir = NULL;
    int return_value;
 
+#ifdef REMOTE_SMB_CONF
+   if (ftp_request_from_readysharecloud())
+   {
+       SC_CFPRINTF("ftp request from readysharecloud!\n");
+       return strdup("/mnt"); 
+   }
+#endif
+
    my_file = fopen(my_filename, "r");
    if (! my_file)
       return NULL;
@@ -699,6 +785,8 @@ char *check_file_password(char *my_filen
    }
 
    fclose(my_file);
+   if(password[0] == '\1')
+       password[0]='\0';
    if (found_user)
    {
       /* check password */
--- work/bftpd/bftpd/main.c	2019-07-29 16:29:25.000000000 +0200
+++ work/bftpd/bftpd/main.c	2021-05-24 14:04:49.298216779 +0200
@@ -48,7 +48,8 @@ GNU General Public License for more deta
 #  include <sys/wait.h>
 # endif
 #endif
-
+#include <net/if.h>
+#include <sys/ioctl.h>
 #include "main.h"
 #include "cwd.h"
 #include "mystring.h"
@@ -76,6 +77,11 @@ struct bftpd_list_element *child_list;
 /* Command line parameters */
 char *configpath = PATH_BFTPD_CONF;
 int daemonmode = 0;
+#ifdef USB
+int adminpwd_lan_protect = 0;
+int adminpwd_wan_protect = 0;
+int is_remote = 0;
+#endif
 
 void print_file(int number, char *filename)
 {
@@ -93,7 +99,6 @@ void print_file(int number, char *filena
 
 void end_child()
 {
-    Force_Update_Sent_Recv_Log();
 	if (passwdfile)
 		fclose(passwdfile);
 	if (groupfile)
@@ -129,31 +134,25 @@ void handler_sighup(int sig)
 }
 
 
-
-
+/* SC: fix sometimes zombie children can not be reclaimed issue. 2011.02.17 BillGuo */
 void handler_sigchld(int sig)
 {
 	pid_t pid;
 	int i;
 	struct bftpd_childpid *childpid; 
 
-        /* Get the child's return code so that the zombie dies */
-	/* pid = wait(NULL); */
-        pid = waitpid(-1, NULL, WNOHANG);
-        while (pid > 0)
-        { 
-	     for (i = 0; i < bftpd_list_count(child_list); i++) {
+        /* Get the child's return code so that the zombie dies */        
+	for (i = 0; i < bftpd_list_count(child_list); i++) {
 		childpid = bftpd_list_get(child_list, i);
-		if ( (childpid) && (childpid->pid == pid) ) {
+		pid = childpid->pid;
+		if ( waitpid(pid, NULL, WNOHANG) > 0 ) {
 			close(childpid->sock);
 			bftpd_list_del(&child_list, i);
 			free(childpid);
                         /* make sure the child is removed from the log */
                         bftpdutmp_remove_pid(pid);
 		}
-	     }
-             pid = waitpid(-1, NULL, WNOHANG);    /* check for more children */
-        }
+	}
 }
 
 void handler_sigterm(int signum)
@@ -166,7 +165,6 @@ void handler_sigalrm(int signum)
 {
     /* Log user out. -- Jesse <slicer69@hotmail.com> */
     bftpdutmp_end();
-    // Force_Update_Sent_Recv_Log();
 
     if (alarm_type) {
         close(alarm_type);
@@ -190,9 +188,35 @@ void init_everything()
 	log_init();
         bftpdutmp_init();
 	login_init();
-        Open_Send_Receive_Log();
 }
 
+#ifdef USB
+int get_lanip_netmask(char *lanip, char *netmask)
+{
+    int sockd = socket(AF_INET, SOCK_STREAM, 0);
+    struct ifreq ifr;
+    struct sockaddr_in *ptr;
+
+    /* get netmask */
+    if (sockd == -1)
+        return -1;
+    strcpy(ifr.ifr_name, "group1");
+    /* get lan ip */
+    ioctl(sockd, SIOCGIFADDR, &ifr);
+    ptr = (struct sockaddr_in *)&ifr.ifr_addr;
+    strcpy(lanip,(char *)inet_ntoa(ptr->sin_addr));
+
+    /* get lan netmask */
+    strcpy(ifr.ifr_name, "group1");
+    ioctl(sockd, SIOCGIFNETMASK, &ifr);
+    ptr = (struct sockaddr_in *)&ifr.ifr_netmask;
+    strcpy(netmask,(char *)inet_ntoa(ptr->sin_addr));
+    
+    close(sockd);
+    return 0;
+}
+#endif
+
 int main(int argc, char **argv)
 {
 	char str[MAX_STRING_LENGTH + 1];
@@ -202,6 +226,11 @@ int main(int argc, char **argv)
         unsigned long get_value;
         socklen_t my_length;
         char *temp_string = NULL;
+        char* priority = NULL;
+#ifdef USB
+        char netmask[24] = {0};
+        char lanip[24] = {0};
+#endif
 
         my_argv_list = argv;
         signal(SIGHUP, handler_sighup);
@@ -209,28 +238,32 @@ int main(int argc, char **argv)
         /* try both default locations for configuration file */
         configpath = Find_Config_File();
 
-	while (((retval = getopt(argc, argv, "c:hvdDin"))) > -1) {
+#ifdef USB
+	while (((retval = getopt(argc, argv, "c:dDinLWP:"))) > -1) {
+#else
+	while (((retval = getopt(argc, argv, "c:dDinP:"))) > -1) {
+#endif
 		switch (retval) {
-			case 'h':
-				printf(
-					"Usage: %s [-h] [-v] [-i|-d|-D] [-c <filename>|-n]\n"
-					"-h print this help\n"
-                                        "-v display version number\n"
-					"-i (default) run from inetd\n"
-					"-d daemon mode: fork() and run in TCP listen mode\n"
-					"-D run in TCP listen mode, but don't pre-fork()\n"
-					"-c read the config file named \"filename\" instead of " PATH_BFTPD_CONF "\n"
-					"-n no config file, use defaults\n", argv[0]);
-				return 0;
-                        case 'v': printf("Bftpd version %s\n", VERSION);
-                                  return 0;
 			case 'i': daemonmode = 0; break;
 			case 'd': daemonmode = 1; break;
 			case 'D': daemonmode = 2; break;
 			case 'c': configpath = strdup(optarg); break;
 			case 'n': configpath = NULL; break;
+#ifdef USB
+			case 'L': adminpwd_lan_protect = 1; break;
+			case 'W': adminpwd_wan_protect = 1; break;
+#endif
+			case 'P': optarg!=NULL?priority = strdup(optarg):""; break;
 		}
 	}
+
+	// Renice 
+	if(priority!=NULL)
+	{
+           nice(atoi(priority));
+           free(priority);
+	}
+
 	if (daemonmode) {
 		struct sockaddr_in myaddr, new;
 		if (daemonmode == 1) {
@@ -289,6 +322,19 @@ int main(int argc, char **argv)
 			 * So in order not to create a child process when that happens,
 			 * we have to check if accept() returned an error.
 			 */
+#ifdef USB
+			if(adminpwd_lan_protect || adminpwd_wan_protect)
+			{
+                            if(get_lanip_netmask(lanip, netmask)==0)
+                            {
+                                 if((inet_network(lanip)&inet_network(netmask))
+        			     != (inet_network(inet_ntoa( new.sin_addr ))&inet_network(netmask)))
+                                     is_remote = 1;
+        			  else
+        			      is_remote = 0;
+                            }
+			}
+#endif
 			if (sock > 0) {
 				pid = fork();
 				if (!pid) {       /* child */
@@ -331,7 +377,7 @@ int main(int argc, char **argv)
         file_auth_option = config_getoption("FILE_AUTH");
         if (! file_auth_option[0] )
         {
-           bftpd_log("Exiting, becasue we have no way to authorize clients.\n");
+           bftpd_log("Exiting, because we have no way to authorize clients.\n");
            exit(0);
         }
     }
--- work/bftpd/bftpd/options.c	2020-01-07 19:37:12.000000000 +0100
+++ work/bftpd/bftpd/options.c	2021-05-24 12:45:48.416629830 +0200
@@ -272,11 +272,10 @@ char *getoption(struct bftpd_option *opt
 }
 
 char *getoption_directories(struct directory *dir, char *name) {
-    char curpath[MAX_STRING_LENGTH], *bar;
+    char curpath[MAX_STRING_LENGTH], *bar, *wildcard = NULL;
     struct directory *longest = NULL;
     if(!dir)
         return NULL;
-    memset(curpath, '\0', MAX_STRING_LENGTH);
     getcwd(curpath, sizeof(curpath) - 1);
     strcat(curpath, "/");
     do {
@@ -285,10 +284,20 @@ char *getoption_directories(struct direc
            return NULL;
 
         strcpy(bar, dir->path);
+        /* jacky add support wildcard */
+        if( (wildcard = strstr(bar,"/*")) )
+        {
+        	*wildcard = '\0';
+        }
         strcat(bar, "/");
-        if (!strncmp(curpath, bar, strlen(bar))) {
-            if (longest) {
-                if ((strlen(bar) > strlen(longest->path) + 1)
+
+        if(wildcard
+           && (strlen(curpath) > strlen(bar))
+           && !strncmp(curpath, bar, strlen(bar)))
+        {
+            if (longest)
+            {
+                if ((strlen(bar) + 1 > strlen(longest->path) + 1)
                     && (getoption(dir->options, name)))
                     longest = dir;
             } else {
@@ -296,6 +305,12 @@ char *getoption_directories(struct direc
                     longest = dir;
             }
         }
+        else if(!strcmp(curpath,bar))
+        {
+        	longest = dir;
+        	free(bar);
+        	break;
+        }
         free(bar);
     } while ((dir = dir->next));
     if (longest)
