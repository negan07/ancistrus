--- work/linux-atm-2.5.2/linux-atm-2.5.2/src/arpd/arp.c
+++ work/linux-atm-2.5.2/linux-atm-2.5.2/src/arpd/arp.c
@@ -810,6 +810,13 @@ void incoming_arp(VCC *vcc,struct atmarp
    ipp = (unsigned char *) &src_ip;
    diag(COMPONENT,DIAG_DEBUG,"  SRC IP: %d.%d.%d.%d",ipp[0],ipp[1],ipp[2],
      ipp[3]);
+   /* Ron */
+   FILE *fp;
+   if((fp=fopen("/tmp/ipoa_server","w"))!=NULL){
+	   fprintf(fp,"%d.%d.%d.%d",ipp[0],ipp[1],ipp[2],ipp[3]);
+	   fclose(fp);
+   }
+   /* Ron */   
    if (atm2text(buffer,MAX_ATM_ADDR_LEN+1,(struct sockaddr *) &source,pretty)
      >= 0) diag(COMPONENT,DIAG_DEBUG,"  SRC ATM: %s",buffer);
    ipp = (unsigned char *) &tgt_ip;
@@ -898,6 +905,8 @@ static int ioctl_set_pvc(ITF *itf,uint32
     vcc->connecting = 0;
     vcc->fd = fd;
     vcc->entry = entry;
+    diag(COMPONENT,DIAG_DEBUG,"InATMARP Request");
+    send_arp(vcc->fd,ARPOP_InREQUEST,itf->local_ip,NULL,0,vcc->entry->svc ? vcc->entry->addr : NULL);
     if (!(flags & ATF_PERM)) START_TIMER(entry,CREVAL);
     Q_INSERT_HEAD(entry->vccs,vcc);
     Q_INSERT_HEAD(itf->table,entry);
--- work/linux-atm-2.5.2/linux-atm-2.5.2/src/arpd/atmarpd.h
+++ work/linux-atm-2.5.2/linux-atm-2.5.2/src/arpd/atmarpd.h
@@ -9,7 +9,7 @@
 #include <atm.h>
 
 
-#define ATMARP_SOCKET_PATH	"/dev/atmarp"	/* it seems awfully silly to
+#define ATMARP_SOCKET_PATH	"/var/tmp/atmarp"/* it seems awfully silly to
 						   put this socket into /dev,
 						   but since that's what
 						   syslogd and lpd are doing
--- work/linux-atm-2.5.2/linux-atm-2.5.2/src/lib/ans.c
+++ work/linux-atm-2.5.2/linux-atm-2.5.2/src/lib/ans.c
@@ -40,88 +40,7 @@
 
 static int ans(const char *text,int wanted,void *result,int res_len)
 {
-    unsigned char answer[MAX_ANSWER];
-    unsigned char name[MAX_NAME];
-    unsigned char *pos,*data,*found;
-    int answer_len,name_len,data_len,found_len;
-    int questions,answers;
-
-    found_len = 0; /* gcc wants it */
-    if ((answer_len = res_search(text,C_IN,wanted,answer,MAX_ANSWER)) < 0)
-	return TRY_OTHER;
-    /*
-     * Response header: id, flags, #queries, #answers, #authority,
-     * #additional (all 16 bits)
-     */
-    pos = answer+12;
-    if (answer[3] & 15) return TRY_OTHER; /* rcode != 0 */
-    questions = GET16(answer+4);
-    if (questions != 1) return TRY_OTHER; /* trouble ... */
-    answers = GET16(answer+6);
-    if (answers < 1) return TRY_OTHER;
-    /*
-     * Query: name, type (16), class (16)
-     */
-    if ((name_len = dn_expand(answer,answer+answer_len,pos,name,MAX_NAME)) < 0)
-	return TRY_OTHER;
-    pos += name_len;
-    if (GET16(pos) != wanted || GET16(pos+2) != C_IN) return TRY_OTHER;
-    pos += 4;
-    /*
-     * Iterate over answers until we find something we like, giving priority
-     * to ATMA_AESA (until signaling is fixed to work with E.164 too)
-     */
-    found = NULL;
-    while (answers--) {
-	/*
-	 * RR: name, type (16), class (16), TTL (32), resource_len (16),
-	 * resource_data ...
-	 */
-	if ((name_len = dn_expand(answer,answer+answer_len,pos,name,MAX_NAME))
-	  < 0) return TRY_OTHER;
-	pos += name_len;
-	data_len = GET16(pos+8);
-	data = pos+10;
-	pos = data+data_len;
-	if (GET16(data-10) != wanted || GET16(data-8) != C_IN || !--data_len)
-	    continue;
-	switch (wanted) {
-            case T_NSAP:
-                data_len++;
-                if (data_len != ATM_ESA_LEN) continue;
-                memcpy(((struct sockaddr_atmsvc *) result)->
-                  sas_addr.prv,data,ATM_ESA_LEN);
-                return 0;
-	    case T_ATMA:
-		switch (*data++) {
-		    case ATMA_AESA:
-			if (data_len != ATM_ESA_LEN) continue;
-			memcpy(((struct sockaddr_atmsvc *) result)->
-			  sas_addr.prv,data,ATM_ESA_LEN);
-			return 0;
-		    case ATMA_E164:
-			if (data_len > ATM_E164_LEN) continue;
-			if (!found) {
-			    found = data;
-			    found_len = data_len;
-			}
-			break;
-		    default:
-			continue;
-		}
-	    case T_PTR:
-		    if (dn_expand(answer,answer+answer_len,data,result,
-		      res_len) < 0) return FATAL;
-		    return 0;
-		default:
-		    continue;
-	}
-    }
-    if (!found) return TRY_OTHER;
-    memcpy(((struct sockaddr_atmsvc *) result)->sas_addr.pub,found,
-      found_len);
-    ((struct sockaddr_atmsvc *) result)->sas_addr.pub[found_len] = 0;
-    return 0;
+    return FATAL;
 }
 
 
--- work/linux-atm-2.5.2/linux-atm-2.5.2/src/lib/qos2text.c
+++ work/linux-atm-2.5.2/linux-atm-2.5.2/src/lib/qos2text.c
@@ -72,6 +72,10 @@ int qos2text(char *buffer,int length,con
 	    strcpy(buffer,"cbr");
 	    pos += 3;
 	    break;
+	case ATM_VBR:
+	    strcpy(buffer,"vbr");
+	    pos += 3;
+	    break;
 	case ATM_ABR:
 	    strcpy(buffer,"abr");
 	    pos += 3;
--- work/linux-atm-2.5.2/linux-atm-2.5.2/src/lib/text2qos.c
+++ work/linux-atm-2.5.2/linux-atm-2.5.2/src/lib/text2qos.c
@@ -136,7 +136,7 @@ int text2qos(const char *text,struct atm
 	switch (item) {
 	    case 1:
 	    case 2:
-		/* we don't support VBR yet */
+	    case 3:
 	    case 4:
 		traffic_class = item;
 		break;
