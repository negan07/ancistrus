--- work/smartmontools-7.3/smartmontools-7.3/json.h	2021-03-02 21:51:15.577073135 +0100
+++ work/smartmontools-7.3/smartmontools-7.3/json.h	2020-11-07 16:38:57.000000000 +0100
@@ -13,11 +13,9 @@
 
 #include <stdint.h>
 #include <stdio.h>
-#include <initializer_list>
-#include <map>
-#include <memory>
 #include <string>
 #include <vector>
+#include <map>
 
 /// Create and print JSON output.
 class json
@@ -36,55 +37,7 @@ public:
   static std::string str2key(const std::string & str)
     { return str2key(str.c_str()); }
 
-  enum node_type {
-    nt_unset, nt_object, nt_array,
-    nt_bool, nt_int, nt_uint, nt_uint128, nt_string
-  };
-
-  // initializer_list<> elements.
-  struct initlist_value {
-    // cppcheck-suppress noExplicitConstructor
-    initlist_value(node_type t) : type(t) {}
-    // cppcheck-suppress noExplicitConstructor
-    initlist_value(bool v) : type(nt_bool), intval(v ? 1 : 0) {}
-    // cppcheck-suppress noExplicitConstructor
-    initlist_value(int v) : initlist_value((long long)v) {}
-    // cppcheck-suppress noExplicitConstructor
-    initlist_value(unsigned v) : initlist_value((unsigned long long)v) {}
-    // cppcheck-suppress noExplicitConstructor
-    initlist_value(long v) : initlist_value((long long)v) {}
-    // cppcheck-suppress noExplicitConstructor
-    initlist_value(unsigned long v) : initlist_value((unsigned long long)v) {}
-    // cppcheck-suppress noExplicitConstructor
-    initlist_value(long long v) : type(nt_int), intval((uint64_t)(int64_t)v) {}
-    // cppcheck-suppress noExplicitConstructor
-    initlist_value(unsigned long long v) : type(nt_uint), intval((uint64_t)v) {}
-    // cppcheck-suppress noExplicitConstructor
-    initlist_value(const char * v) : type(nt_string), strval(v) {}
-    // cppcheck-suppress noExplicitConstructor
-    initlist_value(const std::string & v) : type(nt_string), strval(v.c_str()) {}
-    node_type type;
-    uint64_t intval = 0;
-    const char * strval = nullptr;
-  };
-
-  struct initlist_key_value_pair {
-    initlist_key_value_pair(const char * k, const initlist_value & v) : keystr(k), value(v) {}
-    initlist_key_value_pair(const std::string & k, const initlist_value & v)
-      : keystr(k.c_str()), value(v) {}
-    initlist_key_value_pair(const char * k, const std::initializer_list<initlist_key_value_pair> & ilist)
-      : keystr(k), value(nt_object), object(ilist) {}
-    initlist_key_value_pair(const std::string & k, const std::initializer_list<initlist_key_value_pair> & ilist)
-      : keystr(k.c_str()), value(nt_object), object(ilist) {}
-    initlist_key_value_pair(const char * k, const std::initializer_list<initlist_value> & ilist)
-      : keystr(k), value(nt_array), array(ilist) {}
-    initlist_key_value_pair(const std::string & k, const std::initializer_list<initlist_value> & ilist)
-      : keystr(k.c_str()), value(nt_array), array(ilist) {}
-    const char * keystr;
-    initlist_value value;
-    std::initializer_list<initlist_key_value_pair> object;
-    std::initializer_list<initlist_value> array;
-  };
+  json();
 
 private:
   struct node_info
@@ -90,11 +88,14 @@ private:
   struct node_info
   {
     std::string key;
-    int index = 0;
+    int index;
 
-    node_info() = default;
-    explicit node_info(const char * keystr) : key(str2key(keystr)) { }
-    explicit node_info(int index_) : index(index_) { }
+    node_info()
+      : index(0) { }
+    explicit node_info(const char * keystr)
+      : key(str2key(keystr)), index(0) { }
+    explicit node_info(int index_)
+      : index(index_) { }
   };
 
   typedef std::vector<node_info> node_path;
@@ -147,22 +106,13 @@ public:
     void set_unsafe_uint128(uint64_t value_hi, uint64_t value_lo);
     void set_unsafe_le128(const void * pvalue);
 
-    /// Braced-init-list support for nested objects.
-    void operator+=(std::initializer_list<initlist_key_value_pair> ilist);
-    /// Braced-init-list support for simple arrays.
-    void operator+=(std::initializer_list<initlist_value> ilist);
-
   private:
     friend class json;
-    explicit ref(json & js);
     ref(json & js, const char * keystr);
     ref(const ref & base, const char * keystr);
     ref(const ref & base, int index);
     ref(const ref & base, const char * /*dummy*/, const char * key_suffix);
 
-    void operator=(const initlist_value & value)
-      { m_js.set_initlist_value(m_path, value); }
-
     json & m_js;
     node_path m_path;
   };
@@ -175,10 +125,6 @@ public:
   ref operator[](const std::string & keystr)
     { return ref(*this, keystr.c_str()); }
 
-  /// Braced-init-list support for top level object.
-  void operator+=(std::initializer_list<initlist_key_value_pair> ilist)
-    { ref(*this) += ilist; }
-
   /// Enable/disable JSON output.
   void enable(bool yes = true)
     { m_enabled = yes; }
@@ -197,30 +143,35 @@ public:
 
   /// Options for print().
   struct print_options {
-    bool pretty = false; //< Pretty-print output.
-    bool sorted = false; //< Sort object keys.
-    char format = 0; //< 'y': YAML, 'g': flat(grep, gron), other: JSON
+    bool pretty; //< Pretty-print output.
+    bool sorted; //< Sort object keys.
+    char format; //< 'y': YAML, 'g': flat(grep, gron), other: JSON
+    print_options()
+      : pretty(false), sorted(false), format(0) { }
   };
 
   /// Print JSON tree to a file.
   void print(FILE * f, const print_options & options) const;
 
 private:
+  enum node_type {
+    nt_unset, nt_object, nt_array,
+    nt_bool, nt_int, nt_uint, nt_uint128, nt_string
+  };
+
   struct node
   {
     node();
-    node(const node &) = delete;
     explicit node(const std::string & key_);
     ~node();
-    void operator=(const node &) = delete;
 
-    node_type type = nt_unset;
+    node_type type;
 
-    uint64_t intval = 0, intval_hi = 0;
+    uint64_t intval, intval_hi;
     std::string strval;
 
     std::string key;
-    std::vector< std::unique_ptr<node> > childs;
+    std::vector<node *> childs;
     typedef std::map<std::string, unsigned> keymap;
     keymap key2index;
 
@@ -236,14 +187,21 @@ private:
     private:
       const node * m_node_p;
       bool m_use_map;
-      unsigned m_child_idx = 0;
+      unsigned m_child_idx;
       keymap::const_iterator m_key_iter;
     };
+
+#if __cplusplus >= 201103
+    node(const node &) = delete;
+    void operator=(const node &) = delete;
+#else
+    private: node(const node &); void operator=(const node &);
+#endif
   };
 
-  bool m_enabled = false;
-  bool m_verbose = false;
-  bool m_uint128_output = false;
+  bool m_enabled;
+  bool m_verbose;
+  bool m_uint128_output;
 
   node m_root_node;
 
@@ -255,7 +213,6 @@ private:
   void set_uint128(const node_path & path, uint64_t value_hi, uint64_t value_lo);
   void set_cstring(const node_path & path, const char * value);
   void set_string(const node_path & path, const std::string & value);
-  void set_initlist_value(const node_path & path, const initlist_value & value);
 
   static void print_json(FILE * f, bool pretty, bool sorted, const node * p, int level);
   static void print_yaml(FILE * f, bool pretty, bool sorted, const node * p, int level_o,
--- work/smartmontools-7.3/smartmontools-7.3/json.cpp	2021-03-02 21:52:11.936698791 +0100
+++ work/smartmontools-7.3/smartmontools-7.3/json.cpp	2020-11-07 16:38:57.000000000 +0100
@@ -46,11 +46,6 @@ static void check_key(const char * key)
   return key;
 }
 
-json::ref::ref(json & js)
-: m_js(js)
-{
-}
-
 json::ref::ref(json & js, const char * keystr)
 : m_js(js)
 {
@@ -208,41 +203,31 @@ void json::ref::set_unsafe_le128(const v
                      sg_get_unaligned_le64(                 pvalue    ));
 }
 
-void json::ref::operator+=(std::initializer_list<initlist_key_value_pair> ilist)
-{
-  for (const initlist_key_value_pair & kv : ilist) {
-    jassert(kv.keystr && *kv.keystr);
-    switch (kv.value.type) {
-      default: operator[](kv.keystr) = kv.value; break;
-      case nt_object: operator[](kv.keystr) += kv.object; break;
-      case nt_array: operator[](kv.keystr) += kv.array; break;
-    }
-  }
-}
-
-void json::ref::operator+=(std::initializer_list<initlist_value> ilist)
-{
-  int i = 0;
-  for (const initlist_value & v : ilist)
-    operator[](i++) = v;
-}
-
 json::node::node()
+: type(nt_unset),
+  intval(0),
+  intval_hi(0)
 {
 }
 
 json::node::node(const std::string & key_)
-: key(key_)
+: type(nt_unset),
+  intval(0),
+  intval_hi(0),
+  key(key_)
 {
 }
 
 json::node::~node()
 {
+  for (size_t i = 0; i < childs.size(); i++)
+    delete childs[i];
 }
 
 json::node::const_iterator::const_iterator(const json::node * node_p, bool sorted)
 : m_node_p(node_p),
-  m_use_map(sorted && node_p->type == nt_object)
+  m_use_map(sorted && node_p->type == nt_object),
+  m_child_idx(0)
 {
   if (m_use_map)
     m_key_iter = node_p->key2index.begin();
@@ -273,9 +258,9 @@ void json::node::const_iterator::operato
 const json::node * json::node::const_iterator::operator*() const
 {
   if (m_use_map)
-    return m_node_p->childs[m_key_iter->second].get();
+    return m_node_p->childs[m_key_iter->second];
   else
-    return m_node_p->childs[m_child_idx].get();
+    return m_node_p->childs[m_child_idx];
 }
 
 json::node * json::find_or_create_node(const json::node_path & path, node_type type)
@@ -294,12 +279,13 @@ json::node * json::find_or_create_node(c
       node * p2;
       if (ni != p->key2index.end()) {
         // Object element exists
-        p2 = p->childs[ni->second].get();
+        p2 = p->childs[ni->second];
       }
       else {
         // Create new object element
         p->key2index[pi.key] = (unsigned)p->childs.size();
-        p->childs.push_back(std::unique_ptr<node>(p2 = new node(pi.key)));
+        p2 = new node(pi.key);
+        p->childs.push_back(p2);
       }
       jassert(p2 && p2->key == pi.key);
       p = p2;
@@ -315,14 +301,14 @@ json::node * json::find_or_create_node(c
       // Existing or new array element?
       if (pi.index < (int)p->childs.size()) {
         // Array index exists
-        p2 = p->childs[pi.index].get();
+        p2 = p->childs[pi.index];
         if (!p2) // Already created ?
-          p->childs[pi.index].reset(p2 = new node);
+          p->childs[pi.index] = p2 = new node;
       }
       else {
         // Grow array, fill gap, create new element
         p->childs.resize(pi.index + 1);
-        p->childs[pi.index].reset(p2 = new node);
+        p->childs[pi.index] = p2 = new node;
       }
       jassert(p2 && p2->key.empty());
       p = p2;
@@ -338,6 +324,13 @@ json::node * json::find_or_create_node(c
   return p;
 }
 
+json::json()
+: m_enabled(false),
+  m_verbose(false),
+  m_uint128_output(false)
+{
+}
+
 void json::set_bool(const node_path & path, bool value)
 {
   if (!m_enabled)
@@ -372,7 +365,7 @@ void json::set_cstring(const node_path &
 {
   if (!m_enabled)
     return;
-  jassert(value != nullptr); // Limit: nullptr not supported
+  jassert(value != 0); // Limit: nullptr not supported
   find_or_create_node(path, nt_string)->strval = value;
 }
 
@@ -383,18 +376,6 @@ void json::set_string(const node_path &
   find_or_create_node(path, nt_string)->strval = value;
 }
 
-void json::set_initlist_value(const node_path & path, const initlist_value & val)
-{
-  if (!m_enabled)
-    return;
-  node * p = find_or_create_node(path, val.type);
-  switch (p->type) {
-    case nt_bool: case nt_int: case nt_uint: p->intval = val.intval; break;
-    case nt_string: p->strval = val.strval; break;
-    default: jassert(false);
-  }
-}
-
 static void print_quoted_string(FILE * f, const char * s)
 {
   putc('"', f);
@@ -449,11 +430,13 @@ static char yaml_string_needs_quotes(con
 
 void json::print_json(FILE * f, bool pretty, bool sorted, const node * p, int level)
 {
-  bool is_obj = (p->type == nt_object);
+  if (!p->key.empty())
+    fprintf(f, "\"%s\":%s", p->key.c_str(), (pretty ? " " : ""));
+
   switch (p->type) {
     case nt_object:
     case nt_array:
-      putc((is_obj ? '{' : '['), f);
+      putc((p->type == nt_object ? '{' : '['), f);
       if (!p->childs.empty()) {
         bool first = true;
         for (node::const_iterator it(p, sorted); !it.at_end(); ++it) {
@@ -464,13 +447,10 @@ void json::print_json(FILE * f, bool pre
           const node * p2 = *it;
           if (!p2) {
             // Unset element of sparse array
-            jassert(!is_obj);
+            jassert(p->type == nt_array);
             fputs("null", f);
           }
           else {
-            jassert(is_obj == !p2->key.empty());
-            if (is_obj)
-              fprintf(f, "\"%s\":%s", p2->key.c_str(), (pretty ? " " : ""));
             // Recurse
             print_json(f, pretty, sorted, p2, level + 1);
           }
@@ -479,7 +459,7 @@ void json::print_json(FILE * f, bool pre
         if (pretty)
           fprintf(f, "\n%*s", level * 2, "");
       }
-      putc((is_obj ? '}' : ']'), f);
+      putc((p->type == nt_object ? '}' : ']'), f);
       break;
 
     case nt_bool:
@@ -583,16 +563,15 @@ void json::print_yaml(FILE * f, bool pre
 void json::print_flat(FILE * f, const char * assign, bool sorted, const node * p,
                       std::string & path)
 {
-  bool is_obj = (p->type == nt_object);
   switch (p->type) {
     case nt_object:
     case nt_array:
-      fprintf(f, "%s%s%s;\n", path.c_str(), assign, (is_obj ? "{}" : "[]"));
+      fprintf(f, "%s%s%s;\n", path.c_str(), assign, (p->type == nt_object ? "{}" : "[]"));
       if (!p->childs.empty()) {
         unsigned len = path.size();
         for (node::const_iterator it(p, sorted); !it.at_end(); ++it) {
           const node * p2 = *it;
-          if (!is_obj) {
+          if (p->type == nt_array) {
             char buf[10]; snprintf(buf, sizeof(buf), "[%u]", it.array_index());
             path += buf;
           }
@@ -601,7 +580,7 @@ void json::print_flat(FILE * f, const ch
           }
           if (!p2) {
             // Unset element of sparse array
-            jassert(!is_obj);
+            jassert(p->type == nt_array);
             fprintf(f, "%s%snull;\n", path.c_str(), assign);
           }
           else {
--- work/smartmontools-7.3/smartmontools-7.3/smartd.cpp
+++ work/smartmontools-7.3/smartmontools-7.3/smartd.cpp
@@ -344,6 +345,9 @@ enum {
 class attribute_flags
 {
 public:
+  attribute_flags()
+    { memset(m_flags, 0, sizeof(m_flags)); }
+
   bool is_set(int id, unsigned char flag) const
     { return (0 < id && id < (int)sizeof(m_flags) && (m_flags[id] & flag)); }
 
@@ -354,7 +358,7 @@ public:
     }
 
 private:
-  unsigned char m_flags[256]{};
+  unsigned char m_flags[256];
 };
 
 
@@ -362,72 +366,115 @@ private:
 /// Supports copy & assignment and is compatible with STL containers.
 struct dev_config
 {
-  int lineno{};                           // Line number of entry in file
+  int lineno;                             // Line number of entry in file
   std::string name;                       // Device name (with optional extra info)
   std::string dev_name;                   // Device name (plain, for SMARTD_DEVICE variable)
   std::string dev_type;                   // Device type argument from -d directive, empty if none
   std::string dev_idinfo;                 // Device identify info for warning emails
   std::string state_file;                 // Path of the persistent state file, empty if none
   std::string attrlog_file;               // Path of the persistent attrlog file, empty if none
-  int checktime{};                        // Individual check interval, 0 if none
-  bool ignore{};                          // Ignore this entry
-  bool id_is_unique{};                    // True if dev_idinfo is unique (includes S/N or WWN)
-  bool smartcheck{};                      // Check SMART status
-  bool usagefailed{};                     // Check for failed Usage Attributes
-  bool prefail{};                         // Track changes in Prefail Attributes
-  bool usage{};                           // Track changes in Usage Attributes
-  bool selftest{};                        // Monitor number of selftest errors
-  bool errorlog{};                        // Monitor number of ATA errors
-  bool xerrorlog{};                       // Monitor number of ATA errors (Extended Comprehensive error log)
-  bool offlinests{};                      // Monitor changes in offline data collection status
-  bool offlinests_ns{};                   // Disable auto standby if in progress
-  bool selfteststs{};                     // Monitor changes in self-test execution status
-  bool selfteststs_ns{};                  // Disable auto standby if in progress
-  bool permissive{};                      // Ignore failed SMART commands
-  char autosave{};                        // 1=disable, 2=enable Autosave Attributes
-  char autoofflinetest{};                 // 1=disable, 2=enable Auto Offline Test
+  int checktime;                          // Individual check interval, 0 if none
+  bool ignore;                            // Ignore this entry
+  bool id_is_unique;                      // True if dev_idinfo is unique (includes S/N or WWN)
+  bool smartcheck;                        // Check SMART status
+  bool usagefailed;                       // Check for failed Usage Attributes
+  bool prefail;                           // Track changes in Prefail Attributes
+  bool usage;                             // Track changes in Usage Attributes
+  bool selftest;                          // Monitor number of selftest errors
+  bool errorlog;                          // Monitor number of ATA errors
+  bool xerrorlog;                         // Monitor number of ATA errors (Extended Comprehensive error log)
+  bool offlinests;                        // Monitor changes in offline data collection status
+  bool offlinests_ns;                     // Disable auto standby if in progress
+  bool selfteststs;                       // Monitor changes in self-test execution status
+  bool selfteststs_ns;                    // Disable auto standby if in progress
+  bool permissive;                        // Ignore failed SMART commands
+  char autosave;                          // 1=disable, 2=enable Autosave Attributes
+  char autoofflinetest;                   // 1=disable, 2=enable Auto Offline Test
   firmwarebug_defs firmwarebugs;          // -F directives from drivedb or smartd.conf
-  bool ignorepresets{};                   // Ignore database of -v options
-  bool showpresets{};                     // Show database entry for this device
-  bool removable{};                       // Device may disappear (not be present)
-  char powermode{};                       // skip check, if disk in idle or standby mode
-  bool powerquiet{};                      // skip powermode 'skipping checks' message
-  int powerskipmax{};                     // how many times can be check skipped
-  unsigned char tempdiff{};               // Track Temperature changes >= this limit
-  unsigned char tempinfo{}, tempcrit{};   // Track Temperatures >= these limits as LOG_INFO, LOG_CRIT+mail
+  bool ignorepresets;                     // Ignore database of -v options
+  bool showpresets;                       // Show database entry for this device
+  bool removable;                         // Device may disappear (not be present)
+  char powermode;                         // skip check, if disk in idle or standby mode
+  bool powerquiet;                        // skip powermode 'skipping checks' message
+  int powerskipmax;                       // how many times can be check skipped
+  unsigned char tempdiff;                 // Track Temperature changes >= this limit
+  unsigned char tempinfo, tempcrit;       // Track Temperatures >= these limits as LOG_INFO, LOG_CRIT+mail
   regular_expression test_regex;          // Regex for scheduled testing
-  unsigned test_offset_factor{};          // Factor for staggering of scheduled tests
+  unsigned test_offset_factor;            // Factor for staggering of scheduled tests
 
   // Configuration of email warning messages
   std::string emailcmdline;               // script to execute, empty if no messages
   std::string emailaddress;               // email address, or empty
-  unsigned char emailfreq{};              // Emails once (1) daily (2) diminishing (3)
-  bool emailtest{};                       // Send test email?
+  unsigned char emailfreq;                // Emails once (1) daily (2) diminishing (3)
+  bool emailtest;                         // Send test email?
 
   // ATA ONLY
-  int dev_rpm{};                          // rotation rate, 0 = unknown, 1 = SSD, >1 = HDD
-  int set_aam{};                          // disable(-1), enable(1..255->0..254) Automatic Acoustic Management
-  int set_apm{};                          // disable(-1), enable(2..255->1..254) Advanced Power Management
-  int set_lookahead{};                    // disable(-1), enable(1) read look-ahead
-  int set_standby{};                      // set(1..255->0..254) standby timer
-  bool set_security_freeze{};             // Freeze ATA security
-  int set_wcache{};                       // disable(-1), enable(1) write cache
-  int set_dsn{};                          // disable(0x2), enable(0x1) DSN
-
-  bool sct_erc_set{};                     // set SCT ERC to:
-  unsigned short sct_erc_readtime{};      // ERC read time (deciseconds)
-  unsigned short sct_erc_writetime{};     // ERC write time (deciseconds)
-
-  unsigned char curr_pending_id{};        // ID of current pending sector count, 0 if none
-  unsigned char offl_pending_id{};        // ID of offline uncorrectable sector count, 0 if none
-  bool curr_pending_incr{}, offl_pending_incr{}; // True if current/offline pending values increase
-  bool curr_pending_set{},  offl_pending_set{};  // True if '-C', '-U' set in smartd.conf
+  int dev_rpm;                            // rotation rate, 0 = unknown, 1 = SSD, >1 = HDD
+  int set_aam;                            // disable(-1), enable(1..255->0..254) Automatic Acoustic Management
+  int set_apm;                            // disable(-1), enable(2..255->1..254) Advanced Power Management
+  int set_lookahead;                      // disable(-1), enable(1) read look-ahead
+  int set_standby;                        // set(1..255->0..254) standby timer
+  bool set_security_freeze;               // Freeze ATA security
+  int set_wcache;                         // disable(-1), enable(1) write cache
+  int set_dsn;                            // disable(0x2), enable(0x1) DSN
+
+  bool sct_erc_set;                       // set SCT ERC to:
+  unsigned short sct_erc_readtime;        // ERC read time (deciseconds)
+  unsigned short sct_erc_writetime;       // ERC write time (deciseconds)
+
+  unsigned char curr_pending_id;          // ID of current pending sector count, 0 if none
+  unsigned char offl_pending_id;          // ID of offline uncorrectable sector count, 0 if none
+  bool curr_pending_incr, offl_pending_incr; // True if current/offline pending values increase
+  bool curr_pending_set,  offl_pending_set;  // True if '-C', '-U' set in smartd.conf
 
   attribute_flags monitor_attr_flags;     // MONITOR_* flags for each attribute
 
   ata_vendor_attr_defs attribute_defs;    // -v options
+
+  dev_config();
 };
 
+dev_config::dev_config()
+: lineno(0),
+  ignore(false),
+  id_is_unique(false),
+  smartcheck(false),
+  usagefailed(false),
+  prefail(false),
+  usage(false),
+  selftest(false),
+  errorlog(false),
+  xerrorlog(false),
+  offlinests(false),  offlinests_ns(false),
+  selfteststs(false), selfteststs_ns(false),
+  permissive(false),
+  autosave(0),
+  autoofflinetest(0),
+  ignorepresets(false),
+  showpresets(false),
+  removable(false),
+  powermode(0),
+  powerquiet(false),
+  powerskipmax(0),
+  tempdiff(0),
+  tempinfo(0), tempcrit(0),
+  test_offset_factor(0),
+  emailfreq(0),
+  emailtest(false),
+  dev_rpm(0),
+  set_aam(0), set_apm(0),
+  set_lookahead(0),
+  set_standby(0),
+  set_security_freeze(false),
+  set_wcache(0), set_dsn(0),
+  sct_erc_set(false),
+  sct_erc_readtime(0), sct_erc_writetime(0),
+  curr_pending_id(0), offl_pending_id(0),
+  curr_pending_incr(false), offl_pending_incr(false),
+  curr_pending_set(false),  offl_pending_set(false)
+{
+}
+
 // Number of allowed mail message types
 static const int SMARTD_NMAIL = 13;
 // Type for '-M test' mails (state not persistent)
@@ -435,102 +482,155 @@ static const int MAILTYPE_TEST = 0;
 // TODO: Add const or enum for all mail types.
 
 struct mailinfo {
-  int logged{};         // number of times an email has been sent
-  time_t firstsent{};   // time first email was sent, as defined by time(2)
-  time_t lastsent{};    // time last email was sent, as defined by time(2)
+  int logged;           // number of times an email has been sent
+  time_t firstsent;     // time first email was sent, as defined by time(2)
+  time_t lastsent;      // time last email was sent, as defined by time(2)
+
+  mailinfo()
+    : logged(0), firstsent(0), lastsent(0) { }
 };
 
 /// Persistent state data for a device.
 struct persistent_dev_state
 {
-  unsigned char tempmin{}, tempmax{};     // Min/Max Temperatures
+  unsigned char tempmin, tempmax;     // Min/Max Temperatures
 
-  unsigned char selflogcount{};           // total number of self-test errors
-  unsigned short selfloghour{};           // lifetime hours of last self-test error
+  unsigned char selflogcount;           // total number of self-test errors
+  unsigned short selfloghour;           // lifetime hours of last self-test error
 
-  time_t scheduled_test_next_check{};     // Time of next check for scheduled self-tests
+  time_t scheduled_test_next_check;     // Time of next check for scheduled self-tests
 
-  uint64_t selective_test_last_start{};   // Start LBA of last scheduled selective self-test
-  uint64_t selective_test_last_end{};     // End LBA of last scheduled selective self-test
+  uint64_t selective_test_last_start;   // Start LBA of last scheduled selective self-test
+  uint64_t selective_test_last_end;     // End LBA of last scheduled selective self-test
 
   mailinfo maillog[SMARTD_NMAIL];         // log info on when mail sent
 
   // ATA ONLY
-  int ataerrorcount{};                    // Total number of ATA errors
+  int ataerrorcount;                    // Total number of ATA errors
 
   // Persistent part of ata_smart_values:
   struct ata_attribute {
-    unsigned char id{};
-    unsigned char val{};
-    unsigned char worst{}; // Byte needed for 'raw64' attribute only.
-    uint64_t raw{};
-    unsigned char resvd{};
+    unsigned char id;
+    unsigned char val;
+    unsigned char worst; // Byte needed for 'raw64' attribute only.
+    uint64_t raw;
+    unsigned char resvd;
+
+    ata_attribute() : id(0), val(0), worst(0), raw(0), resvd(0) { }
   };
   ata_attribute ata_attributes[NUMBER_ATA_SMART_ATTRIBUTES];
   
   // SCSI ONLY
 
   struct scsi_error_counter_t {
-    struct scsiErrorCounter errCounter{};
-    unsigned char found{};
+    struct scsiErrorCounter errCounter;
+    unsigned char found;
   };
   scsi_error_counter_t scsi_error_counters[3];
 
   struct scsi_nonmedium_error_t {
-    struct scsiNonMediumError nme{};
-    unsigned char found{};
+    struct scsiNonMediumError nme;
+    unsigned char found;
+    scsi_nonmedium_error_t() : found(0)
+      { memset(&nme, 0, sizeof(nme)); }
   };
   scsi_nonmedium_error_t scsi_nonmedium_error;
 
   // NVMe only
-  uint64_t nvme_err_log_entries{};
+  uint64_t nvme_err_log_entries;
+
+  persistent_dev_state();
 };
 
+persistent_dev_state::persistent_dev_state()
+: tempmin(0), tempmax(0),
+  selflogcount(0),
+  selfloghour(0),
+  scheduled_test_next_check(0),
+  selective_test_last_start(0),
+  selective_test_last_end(0),
+  ataerrorcount(0),
+  nvme_err_log_entries(0)
+{
+}
+
 /// Non-persistent state data for a device.
 struct temp_dev_state
 {
-  bool must_write{};                      // true if persistent part should be written
+  bool must_write;                      // true if persistent part should be written
 
-  bool skip{};                            // skip during next check cycle
-  time_t wakeuptime{};                    // next wakeup time, 0 if unknown or global
+  bool skip;                            // skip during next check cycle
+  time_t wakeuptime;                    // next wakeup time, 0 if unknown or global
 
-  bool not_cap_offline{};                 // true == not capable of offline testing
-  bool not_cap_conveyance{};
-  bool not_cap_short{};
-  bool not_cap_long{};
-  bool not_cap_selective{};
+  bool not_cap_offline;                 // true == not capable of offline testing
+  bool not_cap_conveyance;
+  bool not_cap_short;
+  bool not_cap_long;
+  bool not_cap_selective;
 
-  unsigned char temperature{};            // last recorded Temperature (in Celsius)
-  time_t tempmin_delay{};                 // time where Min Temperature tracking will start
+  unsigned char temperature;            // last recorded Temperature (in Celsius)
+  time_t tempmin_delay;                 // time where Min Temperature tracking will start
 
-  bool removed{};                         // true if open() failed for removable device
+  bool removed;                         // true if open() failed for removable device
 
-  bool powermodefail{};                   // true if power mode check failed
-  int powerskipcnt{};                     // Number of checks skipped due to idle or standby mode
-  int lastpowermodeskipped{};             // the last power mode that was skipped
+  bool powermodefail;                   // true if power mode check failed
+  int powerskipcnt;                     // Number of checks skipped due to idle or standby mode
+  int lastpowermodeskipped;             // the last power mode that was skipped
 
-  bool attrlog_dirty{};                   // true if persistent part has new attr values that
+  bool attrlog_dirty;                   // true if persistent part has new attr values that
                                           // need to be written to attrlog
 
   // SCSI ONLY
   // TODO: change to bool
-  unsigned char SmartPageSupported{};     // has log sense IE page (0x2f)
-  unsigned char TempPageSupported{};      // has log sense temperature page (0xd)
-  unsigned char ReadECounterPageSupported{};
-  unsigned char WriteECounterPageSupported{};
-  unsigned char VerifyECounterPageSupported{};
-  unsigned char NonMediumErrorPageSupported{};
-  unsigned char SuppressReport{};         // minimize nuisance reports
-  unsigned char modese_len{};             // mode sense/select cmd len: 0 (don't
+  unsigned char SmartPageSupported;       // has log sense IE page (0x2f)
+  unsigned char TempPageSupported;        // has log sense temperature page (0xd)
+  unsigned char ReadECounterPageSupported;
+  unsigned char WriteECounterPageSupported;
+  unsigned char VerifyECounterPageSupported;
+  unsigned char NonMediumErrorPageSupported;
+  unsigned char SuppressReport;           // minimize nuisance reports
+  unsigned char modese_len;               // mode sense/select cmd len: 0 (don't
                                           // know yet) 6 or 10
   // ATA ONLY
-  uint64_t num_sectors{};                 // Number of sectors
-  ata_smart_values smartval{};            // SMART data
-  ata_smart_thresholds_pvt smartthres{};  // SMART thresholds
-  bool offline_started{};                 // true if offline data collection was started
-  bool selftest_started{};                // true if self-test was started
+  uint64_t num_sectors;                   // Number of sectors
+  ata_smart_values smartval;              // SMART data
+  ata_smart_thresholds_pvt smartthres;    // SMART thresholds
+  bool offline_started;                   // true if offline data collection was started
+  bool selftest_started;                  // true if self-test was started
+
+  temp_dev_state();
 };
 
+temp_dev_state::temp_dev_state()
+: must_write(false),
+  not_cap_offline(false),
+  not_cap_conveyance(false),
+  not_cap_short(false),
+  not_cap_long(false),
+  not_cap_selective(false),
+  temperature(0),
+  tempmin_delay(0),
+  removed(false),
+  powermodefail(false),
+  powerskipcnt(0),
+  lastpowermodeskipped(0),
+  attrlog_dirty(false),
+  SmartPageSupported(false),
+  TempPageSupported(false),
+  ReadECounterPageSupported(false),
+  WriteECounterPageSupported(false),
+  VerifyECounterPageSupported(false),
+  NonMediumErrorPageSupported(false),
+  SuppressReport(false),
+  modese_len(0),
+  num_sectors(0),
+  offline_started(false),
+  selftest_started(false)
+{
+  memset(&smartval, 0, sizeof(smartval));
+  memset(&smartthres, 0, sizeof(smartthres));
+}
+
 /// Runtime state data for a device.
 struct dev_state
 : public persistent_dev_state,
@@ -805,13 +905,14 @@ static bool write_dev_attrlog(const char
   }
 
   
-  time_t now = time(nullptr);
+  time_t now = time(0);
   struct tm tmbuf, * tms = time_to_tm_local(&tmbuf, now);
   fprintf(f, "%d-%02d-%02d %02d:%02d:%02d;",
              1900+tms->tm_year, 1+tms->tm_mon, tms->tm_mday,
              tms->tm_hour, tms->tm_min, tms->tm_sec);
   // ATA ONLY
-  for (const auto & pa : state.ata_attributes) {
+  for (int i = 0; i < NUMBER_ATA_SMART_ATTRIBUTES; i++) {
+    const persistent_dev_state::ata_attribute & pa = state.ata_attributes[i];
     if (!pa.id)
       continue;
     fprintf(f, "\t%d;%d;%" PRIu64 ";", pa.id, pa.val, pa.raw);
@@ -981,13 +1082,15 @@ static inline void capabilities_log_erro
 class env_buffer
 {
 public:
-  env_buffer() = default;
-  env_buffer(const env_buffer &) = delete;
-  void operator=(const env_buffer &) = delete;
+  env_buffer()
+    : m_buf((char *)0) { }
 
   void set(const char * name, const char * value);
 private:
-  char * m_buf = nullptr;
+  char * m_buf;
+
+  env_buffer(const env_buffer &);
+  void operator=(const env_buffer &);
 };
 
 void env_buffer::set(const char * name, const char * value)
@@ -1059,7 +1162,7 @@ static void MailWarning(const dev_config
     return;
   
   // To decide if to send mail, we need to know what time it is.
-  time_t epoch = time(nullptr);
+  time_t epoch = time(0);
 
   // Return if less than one day has gone by
   const int day = 24*3600;
@@ -1398,7 +1501,7 @@ static int daemon_init()
 
   // flush all buffered streams.  Else we might get two copies of open
   // streams since both parent and child get copies of the buffers.
-  fflush(nullptr);
+  fflush(0);
 
   if (do_fork) {
     pid_t pid;
@@ -1451,7 +1554,7 @@ static int daemon_init()
 
   // No fork() on native Win32
   // Detach this process from console
-  fflush(nullptr);
+  fflush(0);
   if (daemon_detach("smartd")) {
     PrintOut(LOG_CRIT,"smartd unable to detach from console!\n");
     return EXIT_STARTUP;
@@ -1542,7 +1645,7 @@ static void Directives()
 }
 
 /* Returns a pointer to a static string containing a formatted list of the valid
-   arguments to the option opt or nullptr on failure. */
+   arguments to the option opt or NULL on failure. */
 static const char *GetValidArgList(char opt)
 {
   switch (opt) {
@@ -1576,7 +1679,7 @@ static const char *GetValidArgList(char
     return "mail, <no_argument>";
 #endif
   default:
-    return nullptr;
+    return 0;
   }
 }
 
@@ -1798,7 +1901,7 @@ static void log_offline_data_coll_status
     case 0x04: msg = "was suspended by an interrupting command from host"; break;
     case 0x05: msg = "was aborted by an interrupting command from host"; break;
     case 0x06: msg = "was aborted by the device with a fatal error"; break;
-    default:   msg = nullptr;
+    default:   msg = 0;
   }
 
   if (msg)
@@ -1824,7 +1927,7 @@ static void log_self_test_exec_status(co
     case 0x6: msg = "completed with error (servo/seek test element)"; break;
     case 0x7: msg = "completed with error (read test element)"; break;
     case 0x8: msg = "completed with error (handling damage?)"; break;
-    default:  msg = nullptr;
+    default:  msg = 0;
   }
 
   if (msg)
@@ -1876,7 +1979,7 @@ static void finish_device_scan(dev_confi
 
   // Start self-test regex check now if time was not read from state file
   if (!cfg.test_regex.empty() && !state.scheduled_test_next_check)
-    state.scheduled_test_next_check = time(nullptr);
+    state.scheduled_test_next_check = time(0);
 }
 
 // Common function to format result message for ATA setting
@@ -1902,14 +2005,14 @@ static bool is_duplicate_dev_idinfo(cons
   if (!cfg.id_is_unique)
     return false;
 
-  for (const auto & prev_cfg : prev_cfgs) {
-    if (!prev_cfg.id_is_unique)
+  for (unsigned i = 0; i < prev_cfgs.size(); i++) {
+    if (!prev_cfgs[i].id_is_unique)
       continue;
-    if (cfg.dev_idinfo != prev_cfg.dev_idinfo)
+    if (cfg.dev_idinfo != prev_cfgs[i].dev_idinfo)
       continue;
 
     PrintOut(LOG_INFO, "Device: %s, same identity as %s, ignored\n",
-             cfg.dev_name.c_str(), prev_cfg.dev_name.c_str());
+             cfg.dev_name.c_str(), prev_cfgs[i].dev_name.c_str());
     return true;
   }
 
@@ -2412,7 +2515,7 @@ static int SCSIDeviceScan(dev_config & c
 
   if (supported_vpd_pages_p) {
     delete supported_vpd_pages_p;
-    supported_vpd_pages_p = nullptr;
+    supported_vpd_pages_p = 0;
   }
   supported_vpd_pages_p = new supported_vpd_pages(scsidev);
 
@@ -2422,7 +2525,7 @@ static int SCSIDeviceScan(dev_config & c
     if (0 == scsiInquiryVpd(scsidev, SCSI_VPD_DEVICE_IDENTIFICATION,
                             vpdBuf, sizeof(vpdBuf))) {
       len = vpdBuf[3];
-      scsi_decode_lu_dev_id(vpdBuf + 4, len, lu_id, sizeof(lu_id), nullptr);
+      scsi_decode_lu_dev_id(vpdBuf + 4, len, lu_id, sizeof(lu_id), 0);
     }
   }
   serial[0] = '\0';
@@ -2640,9 +2743,9 @@ static uint64_t le128_to_uint64(const un
 static int nvme_get_max_temp_kelvin(const nvme_smart_log & smart_log)
 {
   int k = (smart_log.temperature[1] << 8) | smart_log.temperature[0];
-  for (auto s : smart_log.temp_sensor) {
-    if (s > k)
-      k = s; // cppcheck-suppress useStlAlgorithm
+  for (int i = 0; i < 8; i++) {
+    if (smart_log.temp_sensor[i] > k)
+      k = smart_log.temp_sensor[i];
   }
   return k;
 }
@@ -2890,7 +2993,7 @@ static char next_scheduled_test(const de
     FixGlibcTimeZoneBug();
   
   // Is it time for next check?
-  time_t now = (!usetime ? time(nullptr) : usetime);
+  time_t now = (!usetime ? time(0) : usetime);
   if (now < state.scheduled_test_next_check) {
     if (state.scheduled_test_next_check <= now + 3600)
       return 0; // Next check within one hour
@@ -3006,7 +3109,7 @@ static void PrintTestSchedule(const dev_
   PrintOut(LOG_INFO, "\nNext scheduled self tests (at most 5 of each type per device):\n");
 
   // FixGlibcTimeZoneBug(); // done in PrintOut()
-  time_t now = time(nullptr);
+  time_t now = time(0);
   char datenow[DATEANDEPOCHLEN], date[DATEANDEPOCHLEN];
   dateandtimezoneepoch(datenow, now);
 
@@ -3053,7 +3156,7 @@ static void PrintTestSchedule(const dev_
 static int DoSCSISelfTest(const dev_config & cfg, dev_state & state, scsi_device * device, char testtype)
 {
   int retval = 0;
-  const char *testname = nullptr;
+  const char *testname = 0;
   const char *name = cfg.name.c_str();
   int inProgress;
 
@@ -3080,7 +3183,7 @@ static int DoSCSISelfTest(const dev_conf
     break;
   }
   // If we can't do the test, exit
-  if (!testname) {
+  if (NULL == testname) {
     PrintOut(LOG_CRIT, "Device: %s, not capable of %c Self-Test\n", name, 
              testtype);
     return 1;
@@ -3122,7 +3225,7 @@ static int DoATASelfTest(const dev_confi
   
   // Check for capability to do the test
   int dotest = -1, mode = 0;
-  const char *testname = nullptr;
+  const char *testname = 0;
   switch (testtype) {
   case 'O':
     testname="Offline Immediate ";
@@ -3209,7 +3312,7 @@ static int DoATASelfTest(const dev_confi
   }
 
   // execute the test, and return status
-  int retval = smartcommandhandler(device, IMMEDIATE_OFFLINE, dotest, nullptr);
+  int retval = smartcommandhandler(device, IMMEDIATE_OFFLINE, dotest, NULL);
   if (retval) {
     PrintOut(LOG_CRIT, "Device: %s, execute %sTest failed.\n", name, testname);
     return retval;
@@ -3290,7 +3393,7 @@ static void CheckTemperature(const dev_c
     // First check
     if (!state.tempmin || currtemp < state.tempmin)
         // Delay Min Temperature update by ~ 30 minutes.
-        state.tempmin_delay = time(nullptr) + default_checktime - 60;
+        state.tempmin_delay = time(0) + default_checktime - 60;
     PrintOut(LOG_INFO, "Device: %s, initial Temperature is %d Celsius (Min/Max %s/%u%s)\n",
       cfg.name.c_str(), (int)currtemp, fmt_temp(state.tempmin, buf), state.tempmax, maxchg);
     if (triptemp)
@@ -3301,7 +3404,7 @@ static void CheckTemperature(const dev_c
     if (state.tempmin_delay) {
       // End Min Temperature update delay if ...
       if (   (state.tempmin && currtemp > state.tempmin) // current temp exceeds recorded min,
-          || (state.tempmin_delay <= time(nullptr))) {   // or delay time is over.
+          || (state.tempmin_delay <= time(0))) {   // or delay time is over.
         state.tempmin_delay = 0;
         if (!state.tempmin)
           state.tempmin = 255;
@@ -3541,13 +3644,13 @@ static int ATACheckDevice(const dev_conf
           name, mode, state.powerskipcnt, (state.powerskipcnt==1?"":"s"));
       }
       state.powerskipcnt = 0;
-      state.tempmin_delay = time(nullptr) + default_checktime - 60; // Delay Min Temperature update
+      state.tempmin_delay = time(0) + default_checktime - 60; // Delay Min Temperature update
     }
     else if (state.powerskipcnt) {
       PrintOut(LOG_INFO, "Device: %s, is back in %s mode, resuming checks (%d check%s skipped)\n",
         name, mode, state.powerskipcnt, (state.powerskipcnt==1?"":"s"));
       state.powerskipcnt = 0;
-      state.tempmin_delay = time(nullptr) + default_checktime - 60; // Delay Min Temperature update
+      state.tempmin_delay = time(0) + default_checktime - 60; // Delay Min Temperature update
     }
   }
 
@@ -3837,11 +3940,12 @@ static int NVMeCheckDevice(const dev_con
 // 0=not used, 1=not disabled, 2=disable rejected by OS, 3=disabled
 static int standby_disable_state = 0;
 
-static void init_disable_standby_check(const dev_config_vector & configs)
+static void init_disable_standby_check(dev_config_vector & configs)
 {
   // Check for '-l offlinests,ns' or '-l selfteststs,ns' directives
   bool sts1 = false, sts2 = false;
-  for (const auto & cfg : configs) {
+  for (unsigned i = 0; i < configs.size() && !(sts1 || sts2); i++) {
+    const dev_config & cfg = configs.at(i);
     if (cfg.offlinests_ns)
       sts1 = true;
     if (cfg.selfteststs_ns)
@@ -3992,7 +4096,7 @@ static time_t dosleep(time_t wakeuptime,
   dev_state_vector & states, bool & sigwakeup)
 {
   // If past wake-up-time, compute next wake-up-time
-  time_t timenow = time(nullptr);
+  time_t timenow = time(NULL);
   unsigned n = configs.size();
   int ct;
   if (!checktime_min) {
@@ -4041,7 +4145,7 @@ static time_t dosleep(time_t wakeuptime,
     }
 #endif
 
-    timenow = time(nullptr);
+    timenow = time(NULL);
 
     // Actual sleep time too long?
     if (!addtime && timenow > wakeuptime+60) {
@@ -4183,14 +4287,14 @@ static int Get3Integers(const char *arg,
 // Concatenate strtok() results if quoted with "..."
 static const char * strtok_dequote(const char * delimiters)
 {
-  const char * t = strtok(nullptr, delimiters);
+  const char * t = strtok(0, delimiters);
   if (!t || t[0] != '"')
     return t;
 
   static std::string token;
   token = t+1;
   for (;;) {
-    t = strtok(nullptr, delimiters);
+    t = strtok(0, delimiters);
     if (!t || !*t)
       return "\"";
     token += ' ';
@@ -4242,7 +4346,7 @@ static int ParseToken(char * token, dev_
   switch (sym) {
   case 'C':
     // monitor current pending sector count (default 197)
-    if ((val = GetInteger((arg = strtok(nullptr, delim)), name, token, lineno, configfile, 0, 255, plus)) < 0)
+    if ((val = GetInteger(arg=strtok(NULL,delim), name, token, lineno, configfile, 0, 255, plus)) < 0)
       return -1;
     cfg.curr_pending_id = (unsigned char)val;
     cfg.curr_pending_incr = (*plus == '+');
@@ -4250,7 +4354,7 @@ static int ParseToken(char * token, dev_
     break;
   case 'U':
     // monitor offline uncorrectable sectors (default 198)
-    if ((val = GetInteger((arg = strtok(nullptr, delim)), name, token, lineno, configfile, 0, 255, plus)) < 0)
+    if ((val = GetInteger(arg=strtok(NULL,delim), name, token, lineno, configfile, 0, 255, plus)) < 0)
       return -1;
     cfg.offl_pending_id = (unsigned char)val;
     cfg.offl_pending_incr = (*plus == '+');
@@ -4258,7 +4362,7 @@ static int ParseToken(char * token, dev_
     break;
   case 'T':
     // Set tolerance level for SMART command failures
-    if (!(arg = strtok(nullptr, delim))) {
+    if ((arg = strtok(NULL, delim)) == NULL) {
       missingarg = 1;
     } else if (!strcmp(arg, "normal")) {
       // Normal mode: exit on failure of a mandatory S.M.A.R.T. command, but
@@ -4274,7 +4378,7 @@ static int ParseToken(char * token, dev_
     break;
   case 'd':
     // specify the device type
-    if (!(arg = strtok(nullptr, delim))) {
+    if ((arg = strtok(NULL, delim)) == NULL) {
       missingarg = 1;
     } else if (!strcmp(arg, "ignore")) {
       cfg.ignore = true;
@@ -4290,7 +4394,7 @@ static int ParseToken(char * token, dev_
     break;
   case 'F':
     // fix firmware bug
-    if (!(arg = strtok(nullptr, delim)))
+    if (!(arg = strtok(0, delim)))
       missingarg = 1;
     else if (!parse_firmwarebug_def(arg, cfg.firmwarebugs))
       badarg = 1;
@@ -4318,7 +4422,7 @@ static int ParseToken(char * token, dev_
     break;
   case 'l':
     // track changes in SMART logs
-    if (!(arg = strtok(nullptr, delim))) {
+    if ((arg = strtok(NULL, delim)) == NULL) {
       missingarg = 1;
     } else if (!strcmp(arg, "selftest")) {
       // track changes in self-test log
@@ -4368,7 +4472,7 @@ static int ParseToken(char * token, dev_
     break;
   case 'o':
     // automatic offline testing enable/disable
-    if (!(arg = strtok(nullptr, delim))) {
+    if ((arg = strtok(NULL, delim)) == NULL) {
       missingarg = 1;
     } else if (!strcmp(arg, "on")) {
       cfg.autoofflinetest = 2;
@@ -4380,17 +4484,16 @@ static int ParseToken(char * token, dev_
     break;
   case 'n':
     // skip disk check if in idle or standby mode
-    if (!(arg = strtok(nullptr, delim)))
+    if (!(arg = strtok(NULL, delim)))
       missingarg = 1;
     else {
-      char *endptr = nullptr;
+      char *endptr = NULL;
       char *next = strchr(const_cast<char*>(arg), ',');
 
       cfg.powerquiet = false;
       cfg.powerskipmax = 0;
 
-      if (next)
-        *next = '\0';
+      if (next!=NULL) *next='\0';
       if (!strcmp(arg, "never"))
         cfg.powermode = 0;
       else if (!strcmp(arg, "sleep"))
@@ -4403,7 +4506,7 @@ static int ParseToken(char * token, dev_
         badarg = 1;
 
       // if optional arguments are present
-      if (!badarg && next) {
+      if (!badarg && next!=NULL) {
         next++;
         cfg.powerskipmax = strtol(next, &endptr, 10);
         if (endptr == next)
@@ -4425,7 +4528,7 @@ static int ParseToken(char * token, dev_
     break;
   case 'S':
     // automatic attribute autosave enable/disable
-    if (!(arg = strtok(nullptr, delim))) {
+    if ((arg = strtok(NULL, delim)) == NULL) {
       missingarg = 1;
     } else if (!strcmp(arg, "on")) {
       cfg.autosave = 2;
@@ -4443,7 +4546,7 @@ static int ParseToken(char * token, dev_
       cfg.test_regex = regular_expression();
     }
     // check for missing argument
-    if (!(arg = strtok(nullptr, delim))) {
+    if (!(arg = strtok(NULL, delim))) {
       missingarg = 1;
     }
     // Compile regex
@@ -4472,7 +4575,7 @@ static int ParseToken(char * token, dev_
     break;
   case 'm':
     // send email to address that follows
-    if (!(arg = strtok(nullptr, delim)))
+    if (!(arg = strtok(NULL,delim)))
       missingarg = 1;
     else {
       if (!cfg.emailaddress.empty())
@@ -4483,7 +4586,7 @@ static int ParseToken(char * token, dev_
     break;
   case 'M':
     // email warning options
-    if (!(arg = strtok(nullptr, delim)))
+    if (!(arg = strtok(NULL, delim)))
       missingarg = 1;
     else if (!strcmp(arg, "once"))
       cfg.emailfreq = 1;
@@ -4504,7 +4607,7 @@ static int ParseToken(char * token, dev_
         return -1;
       }
 #else
-      arg = strtok(nullptr, delim);
+      arg = strtok(0, delim);
 #endif
       if (!arg) {
         PrintOut(LOG_CRIT, "File %s line %d (drive %s): Directive %s 'exec' argument must be followed by executable path.\n",
@@ -4522,19 +4625,19 @@ static int ParseToken(char * token, dev_
     break;
   case 'i':
     // ignore failure of usage attribute
-    if ((val = GetInteger((arg = strtok(nullptr, delim)), name, token, lineno, configfile, 1, 255)) < 0)
+    if ((val = GetInteger(arg=strtok(NULL,delim), name, token, lineno, configfile, 1, 255))<0)
       return -1;
     cfg.monitor_attr_flags.set(val, MONITOR_IGN_FAILUSE);
     break;
   case 'I':
     // ignore attribute for tracking purposes
-    if ((val = GetInteger((arg = strtok(nullptr, delim)), name, token, lineno, configfile, 1, 255)) < 0)
+    if ((val = GetInteger(arg=strtok(NULL,delim), name, token, lineno, configfile, 1, 255))<0)
       return -1;
     cfg.monitor_attr_flags.set(val, MONITOR_IGNORE);
     break;
   case 'r':
     // print raw value when tracking
-    if ((val = GetInteger((arg = strtok(nullptr, delim)), name, token, lineno, configfile, 1, 255, excl)) < 0)
+    if ((val = GetInteger(arg=strtok(NULL,delim), name, token, lineno, configfile, 1, 255, excl)) < 0)
       return -1;
     cfg.monitor_attr_flags.set(val, MONITOR_RAW_PRINT);
     if (*excl == '!') // attribute change is critical
@@ -4542,7 +4645,7 @@ static int ParseToken(char * token, dev_
     break;
   case 'R':
     // track changes in raw value (forces printing of raw value)
-    if ((val = GetInteger((arg = strtok(nullptr, delim)), name, token, lineno, configfile, 1, 255, excl)) < 0)
+    if ((val = GetInteger(arg=strtok(NULL,delim), name, token, lineno, configfile, 1, 255, excl)) < 0)
       return -1;
     cfg.monitor_attr_flags.set(val, MONITOR_RAW_PRINT|MONITOR_RAW);
     if (*excl == '!') // raw value change is critical
@@ -4550,13 +4653,13 @@ static int ParseToken(char * token, dev_
     break;
   case 'W':
     // track Temperature
-    if (Get3Integers((arg = strtok(nullptr, delim)), name, token, lineno, configfile,
+    if (Get3Integers(arg=strtok(NULL, delim), name, token, lineno, configfile,
                      &cfg.tempdiff, &cfg.tempinfo, &cfg.tempcrit) < 0)
       return -1;
     break;
   case 'v':
     // non-default vendor-specific attribute meaning
-    if (!(arg = strtok(nullptr, delim))) {
+    if (!(arg = strtok(NULL,delim))) {
       missingarg = 1;
     } else if (!parse_attribute_def(arg, cfg.attribute_defs, PRIOR_USER)) {
       badarg = 1;
@@ -4564,7 +4667,7 @@ static int ParseToken(char * token, dev_
     break;
   case 'P':
     // Define use of drive-specific presets.
-    if (!(arg = strtok(nullptr, delim))) {
+    if (!(arg = strtok(NULL, delim))) {
       missingarg = 1;
     } else if (!strcmp(arg, "use")) {
       cfg.ignorepresets = false;
@@ -4581,7 +4684,7 @@ static int ParseToken(char * token, dev_
 
   case 'e':
     // Various ATA settings
-    if (!(arg = strtok(nullptr, delim))) {
+    if (!(arg = strtok(NULL, delim))) {
       missingarg = true;
     }
     else {
@@ -4656,7 +4759,7 @@ static int ParseToken(char * token, dev_
   case 'c':
     // Override command line options
     {
-      if (!(arg = strtok(nullptr, delim))) {
+      if (!(arg = strtok(0, delim))) {
         missingarg = true;
         break;
       }
@@ -4736,7 +4839,7 @@ static int ParseConfigLine(dev_config_ve
   cfg.lineno = lineno;
 
   // parse tokens one at a time from the file.
-  while (char * token = strtok(nullptr, delim)) {
+  while (char * token = strtok(0, delim)) {
     int rc = ParseToken(token, cfg, scan_types);
     if (rc < 0)
       // error found on the line
@@ -5033,12 +5136,12 @@ static int parse_options(int argc, char
 
   opterr=optopt=0;
   bool badarg = false;
-  const char * badarg_msg = nullptr;
+  const char * badarg_msg = 0;
   bool use_default_db = true; // set false on '-B FILE'
 
   // Parse input options.
   int optchar;
-  while ((optchar = getopt_long(argc, argv, shortopts, longopts, nullptr)) != -1) {
+  while ((optchar = getopt_long(argc, argv, shortopts, longopts, NULL)) != -1) {
     char *arg;
     char *tailptr;
     long lchecktime;
@@ -5241,7 +5344,7 @@ static int parse_options(int argc, char
       // Check whether the option is a long option that doesn't map to -h.
       if (arg[1] == '-' && optchar != 'h') {
         // Iff optopt holds a valid option then argument must be missing.
-        if (optopt && strchr(shortopts, optopt)) {
+        if (optopt && (strchr(shortopts, optopt) != NULL)) {
           PrintOut(LOG_CRIT, "=======> ARGUMENT REQUIRED FOR OPTION: %s <=======\n",arg+2);
           PrintValidArgs(optopt);
         } else {
@@ -5252,7 +5355,7 @@ static int parse_options(int argc, char
       }
       if (optopt) {
         // Iff optopt holds a valid option then argument must be missing.
-        if (strchr(shortopts, optopt)){
+        if (strchr(shortopts, optopt) != NULL){
           PrintOut(LOG_CRIT, "=======> ARGUMENT REQUIRED FOR OPTION: %c <=======\n",optopt);
           PrintValidArgs(optopt);
         } else {
@@ -5600,7 +5703,8 @@ static bool register_devices(const dev_c
   // Set minimum check time and factors for staggered tests
   checktime_min = 0;
   unsigned factor = 0;
-  for (auto & cfg : configs) {
+  for (unsigned i = 0; i < configs.size(); i++) {
+    dev_config & cfg = configs[i];
     if (cfg.checktime && (!checktime_min || checktime_min > cfg.checktime))
       checktime_min = cfg.checktime;
     if (!cfg.test_regex.empty())
@@ -5763,7 +5867,7 @@ static int main_worker(int argc, char **
       install_signal_handlers();
 
       // Initialize wakeup time to CURRENT time
-      wakeuptime = time(nullptr);
+      wakeuptime = time(0);
 
       firstpass = false;
     }
