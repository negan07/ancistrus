--- work/rp-pppoe-3.15/src/common.c
+++ work/rp-pppoe-3.15/src/common.c
@@ -26,7 +26,7 @@
 #ifdef HAVE_SYSLOG_H
 #include <syslog.h>
 #endif
-
+#define dsyslog(format, args...)
 #include <string.h>
 #include <errno.h>
 #include <stdlib.h>
@@ -65,17 +65,17 @@ parsePacket(PPPoEPacket *packet, ParseFu
     UINT16_t tagType, tagLen;
 
     if (PPPOE_VER(packet->vertype) != 1) {
-	syslog(LOG_ERR, "Invalid PPPoE version (%d)", PPPOE_VER(packet->vertype));
+	dsyslog(LOG_ERR, "Invalid PPPoE version (%d)", PPPOE_VER(packet->vertype));
 	return -1;
     }
     if (PPPOE_TYPE(packet->vertype) != 1) {
-	syslog(LOG_ERR, "Invalid PPPoE type (%d)", PPPOE_TYPE(packet->vertype));
+	dsyslog(LOG_ERR, "Invalid PPPoE type (%d)", PPPOE_TYPE(packet->vertype));
 	return -1;
     }
 
     /* Do some sanity checks on packet */
     if (len > ETH_JUMBO_LEN - PPPOE_OVERHEAD) { /* 6-byte overhead for PPPoE header */
-	syslog(LOG_ERR, "Invalid PPPoE packet length (%u)", len);
+	dsyslog(LOG_ERR, "Invalid PPPoE packet length (%u)", len);
 	return -1;
     }
 
@@ -89,7 +89,7 @@ parsePacket(PPPoEPacket *packet, ParseFu
 	    return 0;
 	}
 	if ((curTag - packet->payload) + tagLen + TAG_HDR_SIZE > len) {
-	    syslog(LOG_ERR, "Invalid PPPoE tag length (%u)", tagLen);
+	    dsyslog(LOG_ERR, "Invalid PPPoE tag length (%u)", tagLen);
 	    return -1;
 	}
 	func(tagType, tagLen, curTag+TAG_HDR_SIZE, extra);
@@ -118,17 +118,17 @@ findTag(PPPoEPacket *packet, UINT16_t ty
     UINT16_t tagType, tagLen;
 
     if (PPPOE_VER(packet->vertype) != 1) {
-	syslog(LOG_ERR, "Invalid PPPoE version (%d)", PPPOE_VER(packet->vertype));
+	dsyslog(LOG_ERR, "Invalid PPPoE version (%d)", PPPOE_VER(packet->vertype));
 	return NULL;
     }
     if (PPPOE_TYPE(packet->vertype) != 1) {
-	syslog(LOG_ERR, "Invalid PPPoE type (%d)", PPPOE_TYPE(packet->vertype));
+	dsyslog(LOG_ERR, "Invalid PPPoE type (%d)", PPPOE_TYPE(packet->vertype));
 	return NULL;
     }
 
     /* Do some sanity checks on packet */
     if (len > ETH_JUMBO_LEN - 6) { /* 6-byte overhead for PPPoE header */
-	syslog(LOG_ERR, "Invalid PPPoE packet length (%u)", len);
+	dsyslog(LOG_ERR, "Invalid PPPoE packet length (%u)", len);
 	return NULL;
     }
 
@@ -144,7 +144,7 @@ findTag(PPPoEPacket *packet, UINT16_t ty
 	    return NULL;
 	}
 	if ((curTag - packet->payload) + tagLen + TAG_HDR_SIZE > len) {
-	    syslog(LOG_ERR, "Invalid PPPoE tag length (%u)", tagLen);
+	    dsyslog(LOG_ERR, "Invalid PPPoE tag length (%u)", tagLen);
 	    return NULL;
 	}
 	if (tagType == type) {
@@ -233,22 +233,6 @@ dropPrivs(void)
 }
 
 /**********************************************************************
-*%FUNCTION: printErr
-*%ARGUMENTS:
-* str -- error message
-*%RETURNS:
-* Nothing
-*%DESCRIPTION:
-* Prints a message to stderr and syslog.
-***********************************************************************/
-void
-printErr(char const *str)
-{
-    fprintf(stderr, "pppoe: %s\n", str);
-    syslog(LOG_ERR, "%s", str);
-}
-
-/**********************************************************************
 *%FUNCTION: computeTCPChecksum
 *%ARGUMENTS:
 * ipHdr -- pointer to IP header
@@ -383,7 +367,7 @@ clampMSS(PPPoEPacket *packet, char const
        checksum */
     csum = computeTCPChecksum(ipHdr, tcpHdr);
     if (csum) {
-	syslog(LOG_ERR, "Bad TCP checksum %x", (unsigned int) csum);
+	dsyslog(LOG_ERR, "Bad TCP checksum %x", (unsigned int) csum);
 
 	/* Upper layers will drop it */
 	return;
@@ -402,7 +386,7 @@ clampMSS(PPPoEPacket *packet, char const
 	case 2:
 	    if (opt[1] != 4) {
 		/* Something fishy about MSS option length. */
-		syslog(LOG_ERR,
+		dsyslog(LOG_ERR,
 		       "Bogus length for MSS option (%u) from %u.%u.%u.%u",
 		       (unsigned int) opt[1],
 		       (unsigned int) ipHdr[12],
@@ -416,7 +400,7 @@ clampMSS(PPPoEPacket *packet, char const
 	default:
 	    if (opt[1] < 2) {
 		/* Someone's trying to attack us? */
-		syslog(LOG_ERR,
+		dsyslog(LOG_ERR,
 		       "Bogus TCP option length (%u) from %u.%u.%u.%u",
 		       (unsigned int) opt[1],
 		       (unsigned int) ipHdr[12],
@@ -540,7 +524,7 @@ sendPADT(PPPoEConnection *conn, char con
 	fflush(conn->debugFile);
     }
 #endif
-    syslog(LOG_INFO,"Sent PADT");
+    dsyslog(LOG_INFO,"Sent PADT");
 }
 
 /***********************************************************************
@@ -599,7 +583,7 @@ pktLogErrs(char const *pkt,
 	str = "Generic-Error";
     }
 
-    syslog(LOG_ERR, fmt, pkt, str, (int) len, data);
+    dsyslog(LOG_ERR, fmt, pkt, str, (int) len, data);
     fprintf(stderr, fmt, pkt, str, (int) len, data);
     fprintf(stderr, "\n");
 }
--- work/rp-pppoe-3.15/src/discovery.c
+++ work/rp-pppoe-3.15/src/discovery.c
@@ -51,6 +51,8 @@
 int persist = 0;
 #endif
 
+extern int optSkipSession;
+
 /* Structure used by parseForHostUniq */
 struct HostUniqInfo {
     char *hostUniq;
@@ -804,6 +806,7 @@ discovery(PPPoEConnection *conn)
 		return;
 	    }
 	}
+    if (optSkipSession) sleep(1);
 	sendPADR(conn);
 	conn->discoveryState = STATE_SENT_PADR;
 	waitForPADS(conn, timeout);
--- work/rp-pppoe-3.15/src/if.c
+++ work/rp-pppoe-3.15/src/if.c
@@ -16,6 +16,7 @@
 *
 ***********************************************************************/
 
+#include <string.h>
 #include "pppoe.h"
 #if defined(HAVE_LINUX_IF_H)
 #include <linux/if.h>
@@ -51,7 +52,6 @@
 
 #include <errno.h>
 #include <stdlib.h>
-#include <string.h>
 
 #ifdef HAVE_NET_IF_ARP_H
 #include <net/if_arp.h>
--- work/rp-pppoe-3.15/src/pppoe.c
+++ work/rp-pppoe-3.15/src/pppoe.c
@@ -20,7 +20,8 @@
 #ifdef HAVE_SYSLOG_H
 #include <syslog.h>
 #endif
-
+#define dsyslog(format, args...)  
+#define dopenlog(format,args...)
 #ifdef HAVE_GETOPT_H
 #include <getopt.h>
 #endif
@@ -143,7 +144,7 @@ sessionDiscoveryPacket(PPPoEPacket *pack
 	return;
     }
 
-    syslog(LOG_INFO,
+    dsyslog(LOG_INFO,
 	   "Session %d terminated -- received PADT from peer",
 	   (int) ntohs(packet->session));
     parsePacket(packet, parseLogErrs, NULL);
@@ -173,7 +174,7 @@ sessionDiscoveryPacket(PPPoEConnection *
 
     /* Check length */
     if (ntohs(packet.length) + HDR_SIZE > len) {
-	syslog(LOG_ERR, "Bogus PPPoE length field (%u)",
+	dsyslog(LOG_ERR, "Bogus PPPoE length field (%u)",
 	       (unsigned int) ntohs(packet.length));
 	return;
     }
@@ -208,7 +209,7 @@ sessionDiscoveryPacket(PPPoEConnection *
 	fflush(conn->debugFile);
     }
 #endif
-    syslog(LOG_INFO,
+    dsyslog(LOG_INFO,
 	   "Session %d terminated -- received PADT from peer",
 	   (int) ntohs(packet.session));
     parsePacket(&packet, parseLogErrs, NULL);
@@ -285,7 +286,7 @@ session(PPPoEConnection *conn)
 	    fatalSys("select (session)");
 	}
 	if (r == 0) { /* Inactivity timeout */
-	    syslog(LOG_ERR, "Inactivity timeout... something wicked happened on session %d",
+	    dsyslog(LOG_ERR, "Inactivity timeout... something wicked happened on session %d",
 		   (int) ntohs(conn->session));
 	    sendPADT(conn, "RP-PPPoE: Inactivity timeout");
 	    exit(EXIT_FAILURE);
@@ -323,6 +324,54 @@ session(PPPoEConnection *conn)
     }
 }
 
+/**********************************************************************
+*%FUNCTION: send_lcp_termReq
+*%ARGUMENTS:
+* conn -- PPPoE connection info
+*%RETURNS:
+* Nothing
+*%DESCRIPTION:
+* Handles the "session" phase of PPPoE
+***********************************************************************/
+/* 
+ * Follow Spec 1.9 wan detect request:
+ * If there is a corresponding PPPoE offer (PADO) received, DUT must 
+ * wait for 1 second, then send a corresponding PPPoE Request (PADR) 
+ * back. However, for each PPPoE server from which one or more PADO's
+ * are received, at most one PADR can be sent to that server within 1 
+ * second, even if there are more than one PADO received from the 
+ * server in that second. Then if a corresponding PADS is then 
+ * responded back, the connection type is PPPoE and the router has to 
+ * terminate the PPPoE session just created (by sending LCP Termination
+ * Request first then PADT). [Detection Done]
+ */
+void
+send_lcp_termReq(PPPoEConnection *conn)
+{
+    PPPoEPacket packet;
+    LCPPacket *lcp = NULL;    
+    int len = 0;
+
+    /* Now use discover socket as session terminate finish socket */
+    if (conn->discoverySocket < 0) return;
+    /* Fill in the constant fields of the packet to save time */
+    memcpy(packet.ethHdr.h_dest, conn->peerEth, ETH_ALEN);
+    memcpy(packet.ethHdr.h_source, conn->myEth, ETH_ALEN);
+    packet.ethHdr.h_proto = htons(Eth_PPPOE_Session);
+    packet.vertype = PPPOE_VER_TYPE(1, 1);
+    packet.code = CODE_SESS;
+    packet.session = conn->session;
+    /* Fill PPP LCP packte part */
+    lcp = (LCPPacket *)(packet.payload);
+    lcp->protocol= htons(LCP_PRO_TYPE);
+    lcp->code = LCP_TERM_REQ;
+    lcp->id = 0x01; /* normal it should begin from 0x01 */
+    memcpy(lcp->payload, LCP_TERM_REASON,strlen(LCP_TERM_REASON));
+    len = LCP_HDR_SIZE+strlen((char *)lcp->payload);
+    lcp->length = htons(len);
+    packet.length = htons(len+LCP_PRO_SIZE);
+    sendPacket(conn, conn->discoverySocket, &packet, (int) (len+LCP_PRO_SIZE + HDR_SIZE));
+}
 
 /***********************************************************************
 *%FUNCTION: sigPADT
@@ -337,7 +386,7 @@ session(PPPoEConnection *conn)
 static void
 sigPADT(int src)
 {
-  syslog(LOG_DEBUG,"Received signal %d on session %d.",
+  dsyslog(LOG_DEBUG,"Received signal %d on session %d.",
 	 (int)src, (int) ntohs(Connection->session));
   sendPADTf(Connection, "RP-PPPoE: Received signal %d", src);
   exit(EXIT_SUCCESS);
@@ -355,44 +404,12 @@ sigPADT(int src)
 void
 usage(char const *argv0)
 {
-    fprintf(stderr, "Usage: %s [options]\n", argv0);
-    fprintf(stderr, "Options:\n");
-#ifdef USE_BPF
-    fprintf(stderr, "   -I if_name     -- Specify interface (REQUIRED)\n");
-#else
-    fprintf(stderr, "   -I if_name     -- Specify interface (default %s.)\n",
-	    DEFAULT_IF);
-#endif
-#ifdef DEBUGGING_ENABLED
-    fprintf(stderr, "   -D filename    -- Log debugging information in filename.\n");
-#endif
-    fprintf(stderr,
-	    "   -T timeout     -- Specify inactivity timeout in seconds.\n"
-	    "   -t timeout     -- Initial timeout for discovery packets in seconds\n"
-	    "   -V             -- Print version and exit.\n"
-	    "   -A             -- Print access concentrator names and exit.\n"
-	    "   -S name        -- Set desired service name.\n"
-	    "   -C name        -- Set desired access concentrator name.\n"
-	    "   -U             -- Use Host-Unique to allow multiple PPPoE sessions.\n"
-	    "   -W value       -- Use Host-Unique set to 'value' specifically.\n"
-	    "   -s             -- Use synchronous PPP encapsulation.\n"
-	    "   -m MSS         -- Clamp incoming and outgoing MSS options.\n"
-	    "   -p pidfile     -- Write process-ID to pidfile.\n"
-	    "   -e sess:mac    -- Skip discovery phase; use existing session.\n"
-	    "   -n             -- Do not open discovery socket.\n"
-	    "   -k             -- Kill a session with PADT (requires -e)\n"
-	    "   -d             -- Perform discovery, print session info and exit.\n"
-	    "   -f disc:sess   -- Set Ethernet frame types (hex).\n"
-	    "   -h             -- Print usage information.\n\n"
-	    "RP-PPPoE Version %s, Copyright (C) 2001-2018 Roaring Penguin Software Inc.\n"
-	    "                 %*s  Copyright (C) 2018-2021 Dianne Skoll\n"
-	    "RP-PPPoE comes with ABSOLUTELY NO WARRANTY.\n"
-	    "This is free software, and you are welcome to redistribute it under the terms\n"
-	    "of the GNU General Public License, version 2 or any later version.\n"
-	    "https://dianne.skoll.ca/projects/rp-pppoe/\n", RP_VERSION, (int) strlen(RP_VERSION), "");
     exit(EXIT_SUCCESS);
 }
 
+int pppoe_main(int argc, char *argv[]);
+extern int relay_main(int argc, char *argv[]);
+
 /**********************************************************************
 *%FUNCTION: main
 *%ARGUMENTS:
@@ -405,6 +422,16 @@ usage(char const *argv0)
 int
 main(int argc, char *argv[])
 {
+	if(strstr(argv[0],"pppoe-relay"))
+		relay_main(argc,argv);
+	else
+		pppoe_main(argc,argv);
+	return 0;
+}
+
+int
+pppoe_main(int argc, char *argv[])
+{
     int opt;
     int n;
     unsigned int m[6];		/* MAC address in -e option */
@@ -435,7 +462,7 @@ main(int argc, char *argv[])
     Connection = &conn;
 
     /* Initialize syslog */
-    openlog("pppoe", LOG_PID, LOG_DAEMON);
+    dopenlog("pppoe", LOG_PID, LOG_DAEMON);
 
 #ifdef DEBUGGING_ENABLED
     options = "I:VAT:D:hS:C:UW:sm:np:e:kdf:F:t:";
@@ -613,7 +640,7 @@ main(int argc, char *argv[])
 		printErr("Unable to set line discipline to N_HDLC.  Make sure your kernel supports the N_HDLC line discipline, or do not use the SYNCHRONOUS option.  Quitting.");
 		exit(EXIT_FAILURE);
 	    } else {
-		syslog(LOG_INFO,
+		dsyslog(LOG_INFO,
 		       "Changed pty line discipline to N_HDLC for synchronous mode");
 	    }
 	    /* There is a bug in Linux's select which returns a descriptor
@@ -660,8 +687,28 @@ main(int argc, char *argv[])
         conn.discoverySocket =
 	    openInterface(conn.ifName, Eth_PPPOE_Discovery, conn.myEth, NULL);
         discovery(&conn);
+/* define in filenames.h */    
+#define DETECTOUT_PPPOE         "/tmp/detect_pppoe"
     }
     if (optSkipSession) {
+    FILE *fp;
+    if ((fp = fopen(DETECTOUT_PPPOE, "w")) != NULL)
+        fclose(fp);
+/* 
+ * Follow Spec 1.9 wan detect request:
+ * If there is a corresponding PPPoE offer (PADO) received, DUT must 
+ * wait for 1 second, then send a corresponding PPPoE Request (PADR) 
+ * back. However, for each PPPoE server from which one or more PADO's
+ * are received, at most one PADR can be sent to that server within 1 
+ * second, even if there are more than one PADO received from the 
+ * server in that second. Then if a corresponding PADS is then 
+ * responded back, the connection type is PPPoE and the router has to 
+ * terminate the PPPoE session just created (by sending LCP Termination
+ * Request first then PADT). [Detection Done]
+ */
+    send_lcp_termReq(&conn);
+    usleep(500000L);
+    sendPADT(&conn, "Detection Done");
 	printf("%u:%02x:%02x:%02x:%02x:%02x:%02x\n",
 	       ntohs(conn.session),
 	       conn.peerEth[0],
@@ -714,9 +761,6 @@ fatalSys(char const *str)
 void
 sysErr(char const *str)
 {
-    char buf[1024];
-    sprintf(buf, "%.256s: %.256s", str, strerror(errno));
-    printErr(buf);
 }
 
 /**********************************************************************
@@ -772,7 +816,7 @@ asyncReadFromEth(PPPoEConnection *conn,
 
     /* Check length */
     if (ntohs(packet.length) + HDR_SIZE > len) {
-	syslog(LOG_ERR, "Bogus PPPoE length field (%u)",
+	dsyslog(LOG_ERR, "Bogus PPPoE length field (%u)",
 	       (unsigned int) ntohs(packet.length));
 	return;
     }
@@ -796,15 +840,15 @@ asyncReadFromEth(PPPoEConnection *conn,
 
     /* Sanity check */
     if (packet.code != CODE_SESS) {
-	syslog(LOG_ERR, "Unexpected packet code %d", (int) packet.code);
+	dsyslog(LOG_ERR, "Unexpected packet code %d", (int) packet.code);
 	return;
     }
     if (PPPOE_VER(packet.vertype) != 1) {
-	syslog(LOG_ERR, "Unexpected packet version %d", PPPOE_VER(packet.vertype));
+	dsyslog(LOG_ERR, "Unexpected packet version %d", PPPOE_VER(packet.vertype));
 	return;
     }
     if (PPPOE_TYPE(packet.vertype) != 1) {
-	syslog(LOG_ERR, "Unexpected packet type %d", PPPOE_TYPE(packet.vertype));
+	dsyslog(LOG_ERR, "Unexpected packet type %d", PPPOE_TYPE(packet.vertype));
 	return;
     }
     if (memcmp(packet.ethHdr.h_dest, conn->myEth, ETH_ALEN)) {
@@ -823,7 +867,7 @@ asyncReadFromEth(PPPoEConnection *conn,
     }
     plen = ntohs(packet.length);
     if (plen + HDR_SIZE > len) {
-	syslog(LOG_ERR, "Bogus length field in session packet %d (%d)",
+	dsyslog(LOG_ERR, "Bogus length field in session packet %d (%d)",
 	       (int) plen, (int) len);
 	return;
     }
@@ -901,7 +945,7 @@ syncReadFromEth(PPPoEConnection *conn, i
 
     /* Check length */
     if (ntohs(packet.length) + HDR_SIZE > len) {
-	syslog(LOG_ERR, "Bogus PPPoE length field (%u)",
+	dsyslog(LOG_ERR, "Bogus PPPoE length field (%u)",
 	       (unsigned int) ntohs(packet.length));
 	return;
     }
@@ -925,15 +969,15 @@ syncReadFromEth(PPPoEConnection *conn, i
 
     /* Sanity check */
     if (packet.code != CODE_SESS) {
-	syslog(LOG_ERR, "Unexpected packet code %d", (int) packet.code);
+	dsyslog(LOG_ERR, "Unexpected packet code %d", (int) packet.code);
 	return;
     }
     if (PPPOE_VER(packet.vertype) != 1) {
-	syslog(LOG_ERR, "Unexpected packet version %d", PPPOE_VER(packet.vertype));
+	dsyslog(LOG_ERR, "Unexpected packet version %d", PPPOE_VER(packet.vertype));
 	return;
     }
     if (PPPOE_TYPE(packet.vertype) != 1) {
-	syslog(LOG_ERR, "Unexpected packet type %d", PPPOE_TYPE(packet.vertype));
+	dsyslog(LOG_ERR, "Unexpected packet type %d", PPPOE_TYPE(packet.vertype));
 	return;
     }
     if (memcmp(packet.ethHdr.h_dest, conn->myEth, ETH_ALEN)) {
@@ -953,7 +997,7 @@ syncReadFromEth(PPPoEConnection *conn, i
     }
     plen = ntohs(packet.length);
     if (plen + HDR_SIZE > len) {
-	syslog(LOG_ERR, "Bogus length field in session packet %d (%d)",
+	dsyslog(LOG_ERR, "Bogus length field in session packet %d (%d)",
 	       (int) plen, (int) len);
 	return;
     }
--- work/rp-pppoe-3.15/src/pppoe.h
+++ work/rp-pppoe-3.15/src/pppoe.h
@@ -189,10 +189,10 @@ extern void dropPrivs(void);
 #define STATE_TERMINATED    4
 
 /* How many PADI/PADS attempts? */
-#define MAX_PADI_ATTEMPTS 3
+#define MAX_PADI_ATTEMPTS 1
 
 /* Initial timeout for PADO/PADS */
-#define PADI_TIMEOUT 5
+#define PADI_TIMEOUT 1
 
 /* States for scanning PPP frames */
 #define STATE_WAITFOR_FRAME_ADDR 0
@@ -227,6 +227,31 @@ typedef struct PPPoEPacketStruct {
 #define PPPOE_TYPE(vt)	((vt) & 0xf)
 #define PPPOE_VER_TYPE(v, t)	(((v) << 4) | (t))
 
+/* 
+ * Follow Spec 1.9 wan detect request:
+ * If there is a corresponding PPPoE offer (PADO) received, DUT must 
+ * wait for 1 second, then send a corresponding PPPoE Request (PADR) 
+ * back. However, for each PPPoE server from which one or more PADO
+ * are received, at most one PADR can be sent to that server within 1 
+ * second, even if there are more than one PADO received from the 
+ * server in that second. Then if a corresponding PADS is then 
+ * responded back, the connection type is PPPoE and the router has to 
+ * terminate the PPPoE session just created (by sending LCP Termination
+ * Request first then PADT). [Detection Done]
+ */
+#define LCP_TERM_REQ        0x05
+#define LCP_TERM_REASON     "PPPoE detect done"
+#define LCP_HDR_SIZE        4/* not include lcp protocol type */
+#define LCP_PRO_SIZE        2
+#define LCP_PRO_TYPE        0xc021
+typedef struct LCPPacketStruct {   
+    unsigned int protocol:16; /* PPP LCP protocol type */ 
+    unsigned int code:8;	/* LCP code type */
+    unsigned int id:8;	    /* LCP session id */
+    unsigned int length:16;	/* LCP length */
+    unsigned char payload[ETH_DATA_LEN]; /* A bit of room to spare */
+} LCPPacket;
+
 /* Header size of a PPPoE packet */
 #define PPPOE_OVERHEAD 6  /* type, code, session, length */
 #define HDR_SIZE (sizeof(struct ethhdr) + PPPOE_OVERHEAD)
@@ -313,7 +338,7 @@ int sendPacket(PPPoEConnection *conn, in
 int receivePacket(int sock, PPPoEPacket *pkt, int *size);
 void fatalSys(char const *str);
 void rp_fatal(char const *str);
-void printErr(char const *str);
+#define printErr(f,a...)
 void sysErr(char const *str);
 #ifdef DEBUGGING_ENABLED
 void dumpPacket(FILE *fp, PPPoEPacket *packet, char const *dir);
@@ -343,7 +368,8 @@ unsigned char *findTag(PPPoEPacket *pack
 size_t strlcpy(char *dst, const char *src, size_t size);
 #endif
 
-#define SET_STRING(var, val) do { if (var) free(var); var = strdup(val); if (!var) rp_fatal("strdup failed"); } while(0);
+extern char *strdup(const char *s);
+#define SET_STRING(var, val) do { if (var) free(var); var = (char *)strdup(val); if (!var) rp_fatal("strdup failed"); } while(0);
 
 #define CHECK_ROOM(cursor, start, len) \
 do {\
@@ -357,3 +383,4 @@ do {\
 #define NOT_UNICAST(e) ((e[0] & 0x01) != 0)
 #define BROADCAST(e) ((e[0] & e[1] & e[2] & e[3] & e[4] & e[5]) == 0xFF)
 #define NOT_BROADCAST(e) ((e[0] & e[1] & e[2] & e[3] & e[4] & e[5]) != 0xFF)
+#define dumpPacket(msg...)
--- work/rp-pppoe-3.15/src/relay.c
+++ work/rp-pppoe-3.15/src/relay.c
@@ -30,7 +30,9 @@
 #ifdef HAVE_SYSLOG_H
 #include <syslog.h>
 #endif
-
+#define dsyslog(format, args...)  
+#define dopenlog(format,args...)
+#define dcloselog()
 #ifdef HAVE_GETOPT_H
 #include <getopt.h>
 #endif
@@ -200,24 +202,8 @@ removeBytes(PPPoEPacket *packet,
 * Prints usage information and exits.
 ***********************************************************************/
 void
-usage(char const *argv0)
+relay_usage(char const *argv0)
 {
-    fprintf(stderr, "Usage: %s [options]\n", argv0);
-    fprintf(stderr, "Options:\n");
-    fprintf(stderr, "   -S if_name     -- Specify interface for PPPoE Server\n");
-    fprintf(stderr, "   -C if_name     -- Specify interface for PPPoE Client\n");
-    fprintf(stderr, "   -B if_name     -- Specify interface for both clients and server\n");
-    fprintf(stderr, "   -n nsess       -- Maxmimum number of sessions to relay\n");
-    fprintf(stderr, "   -i timeout     -- Idle timeout in seconds (0 = no timeout)\n");
-    fprintf(stderr, "   -F             -- Do not fork into background\n");
-    fprintf(stderr, "   -h             -- Print this help message\n");
-
-    fprintf(stderr, "\nPPPoE Version %s, Copyright (C) 2001-2006 Roaring Penguin Software Inc.\n", RP_VERSION);
-    fprintf(stderr, "              %*s  Copyright (C) 2018-2021 Dianne Skoll\n", (int) strlen(RP_VERSION), "");
-    fprintf(stderr, "PPPoE comes with ABSOLUTELY NO WARRANTY.\n");
-    fprintf(stderr, "This is free software, and you are welcome to redistribute it under the terms\n");
-    fprintf(stderr, "of the GNU General Public License, version 2 or any later version.\n");
-    fprintf(stderr, "https://dianne.skoll.ca/projects/rp-pppoe/\n");
     exit(EXIT_SUCCESS);
 }
 
@@ -235,7 +221,7 @@ usage(char const *argv0)
 * -n sessions         -- Maximum of "n" sessions
 ***********************************************************************/
 int
-main(int argc, char *argv[])
+relay_main(int argc, char *argv[])
 {
     int opt;
     int nsess = DEFAULT_SESSIONS;
@@ -249,12 +235,12 @@ main(int argc, char *argv[])
     }
 
 
-    openlog("pppoe-relay", LOG_PID, LOG_DAEMON);
+    dopenlog("pppoe-relay", LOG_PID, LOG_DAEMON);
 
     while((opt = getopt(argc, argv, "hC:S:B:n:i:F")) != -1) {
 	switch(opt) {
 	case 'h':
-	    usage(argv[0]);
+	    relay_usage(argv[0]);
 	    break;
 	case 'F':
 	    beDaemon = 0;
@@ -287,21 +273,18 @@ main(int argc, char *argv[])
 	    }
 	    break;
 	default:
-	    usage(argv[0]);
+	    relay_usage(argv[0]);
 	}
     }
 
 #ifdef USE_LINUX_PACKET
 #ifndef HAVE_STRUCT_SOCKADDR_LL
-    fprintf(stderr, "The PPPoE relay does not work on Linux 2.0 kernels.\n");
     exit(EXIT_FAILURE);
 #endif
 #endif
 
     /* Check that at least two interfaces were defined */
     if (NumInterfaces < 2) {
-	fprintf(stderr, "%s: Must define at least two interfaces\n",
-		argv[0]);
 	exit(EXIT_FAILURE);
     }
 
@@ -341,14 +324,14 @@ main(int argc, char *argv[])
 	}
 
 	chdir("/");
-	closelog();
+	dcloselog();
 	for (i=0; i<CLOSEFD; i++) {
 	    if (!keepDescriptor(i)) {
 		close(i);
 	    }
 	}
 	/* We nuked our syslog descriptor... */
-	openlog("pppoe-relay", LOG_PID, LOG_DAEMON);
+	dopenlog("pppoe-relay", LOG_PID, LOG_DAEMON);
     }
 
     /* Kick off SIGALRM if there is an idle timeout */
@@ -532,7 +515,7 @@ createSession(PPPoEInterface const *ac,
     addHash(cliHash);
 
     /* Log */
-    syslog(LOG_INFO,
+    dsyslog(LOG_INFO,
 	   "Opened session: server=%02x:%02x:%02x:%02x:%02x:%02x(%s:%d), client=%02x:%02x:%02x:%02x:%02x:%02x(%s:%d)",
 	   acHash->peerMac[0], acHash->peerMac[1],
 	   acHash->peerMac[2], acHash->peerMac[3],
@@ -562,7 +545,7 @@ createSession(PPPoEInterface const *ac,
 void
 freeSession(PPPoESession *ses, char const *msg)
 {
-    syslog(LOG_INFO,
+    dsyslog(LOG_INFO,
 	   "Closed session: server=%02x:%02x:%02x:%02x:%02x:%02x(%s:%d), client=%02x:%02x:%02x:%02x:%02x:%02x(%s:%d): %s",
 	   ses->acHash->peerMac[0], ses->acHash->peerMac[1],
 	   ses->acHash->peerMac[2], ses->acHash->peerMac[3],
@@ -693,57 +676,6 @@ findSession(unsigned char const *mac, UI
 }
 
 /**********************************************************************
-*%FUNCTION: fatalSys
-*%ARGUMENTS:
-* str -- error message
-*%RETURNS:
-* Nothing
-*%DESCRIPTION:
-* Prints a message plus the errno value to stderr and syslog and exits.
-***********************************************************************/
-void
-fatalSys(char const *str)
-{
-    char buf[1024];
-    sprintf(buf, "%.256s: %.256s", str, strerror(errno));
-    printErr(buf);
-    exit(EXIT_FAILURE);
-}
-
-/**********************************************************************
-*%FUNCTION: sysErr
-*%ARGUMENTS:
-* str -- error message
-*%RETURNS:
-* Nothing
-*%DESCRIPTION:
-* Prints a message plus the errno value to syslog.
-***********************************************************************/
-void
-sysErr(char const *str)
-{
-    char buf[1024];
-    sprintf(buf, "%.256s: %.256s", str, strerror(errno));
-    printErr(buf);
-}
-
-/**********************************************************************
-*%FUNCTION: rp_fatal
-*%ARGUMENTS:
-* str -- error message
-*%RETURNS:
-* Nothing
-*%DESCRIPTION:
-* Prints a message to stderr and syslog and exits.
-***********************************************************************/
-void
-rp_fatal(char const *str)
-{
-    printErr(str);
-    exit(EXIT_FAILURE);
-}
-
-/**********************************************************************
 *%FUNCTION: relayLoop
 *%ARGUMENTS:
 * None
@@ -834,7 +766,7 @@ relayGotDiscoveryPacket(PPPoEInterface c
 
     /* Validate length */
     if (ntohs(packet.length) + HDR_SIZE > size) {
-	syslog(LOG_ERR, "Bogus PPPoE length field (%u)",
+	dsyslog(LOG_ERR, "Bogus PPPoE length field (%u)",
 	       (unsigned int) ntohs(packet.length));
 	return;
     }
@@ -861,7 +793,7 @@ relayGotDiscoveryPacket(PPPoEInterface c
 	relayHandlePADS(iface, &packet, size);
 	break;
     default:
-	syslog(LOG_ERR, "Discovery packet on %s with unknown code %d",
+	dsyslog(LOG_ERR, "Discovery packet on %s with unknown code %d",
 	       iface->name, (int) packet.code);
     }
 }
@@ -894,7 +826,7 @@ relayGotSessionPacket(PPPoEInterface con
 
     /* Must be a session packet */
     if (packet.code != CODE_SESS) {
-	syslog(LOG_ERR, "Session packet with code %d", (int) packet.code);
+	dsyslog(LOG_ERR, "Session packet with code %d", (int) packet.code);
 	return;
     }
 
@@ -905,7 +837,7 @@ relayGotSessionPacket(PPPoEInterface con
 
     /* Validate length */
     if (ntohs(packet.length) + HDR_SIZE > size) {
-	syslog(LOG_ERR, "Bogus PPPoE length field (%u)",
+	dsyslog(LOG_ERR, "Bogus PPPoE length field (%u)",
 	       (unsigned int) ntohs(packet.length));
 	return;
     }
@@ -1004,7 +936,7 @@ relayHandlePADI(PPPoEInterface const *if
 
     /* Can a client legally be behind this interface? */
     if (!iface->clientOK) {
-	syslog(LOG_ERR,
+	fprintf(stderr,
 	       "PADI packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s not permitted",
 	       packet->ethHdr.h_source[0],
 	       packet->ethHdr.h_source[1],
@@ -1018,7 +950,7 @@ relayHandlePADI(PPPoEInterface const *if
 
     /* Source address must be unicast */
     if (NOT_UNICAST(packet->ethHdr.h_source)) {
-	syslog(LOG_ERR,
+	fprintf(stderr,
 	       "PADI packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s not from a unicast address",
 	       packet->ethHdr.h_source[0],
 	       packet->ethHdr.h_source[1],
@@ -1032,7 +964,7 @@ relayHandlePADI(PPPoEInterface const *if
 
     /* Destination address must be broadcast */
     if (NOT_BROADCAST(packet->ethHdr.h_dest)) {
-	syslog(LOG_ERR,
+	fprintf(stderr,
 	       "PADI packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s not to a broadcast address",
 	       packet->ethHdr.h_source[0],
 	       packet->ethHdr.h_source[1],
@@ -1097,7 +1029,7 @@ relayHandlePADO(PPPoEInterface const *if
 
     /* Can a server legally be behind this interface? */
     if (!iface->acOK) {
-	syslog(LOG_ERR,
+	fprintf(stderr,
 	       "PADO packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s not permitted",
 	       packet->ethHdr.h_source[0],
 	       packet->ethHdr.h_source[1],
@@ -1113,7 +1045,7 @@ relayHandlePADO(PPPoEInterface const *if
 
     /* Source address can't be broadcast */
     if (BROADCAST(packet->ethHdr.h_source)) {
-	syslog(LOG_ERR,
+	dsyslog(LOG_ERR,
 	       "PADO packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s from a broadcast address",
 	       packet->ethHdr.h_source[0],
 	       packet->ethHdr.h_source[1],
@@ -1133,7 +1065,7 @@ relayHandlePADO(PPPoEInterface const *if
     /* Find relay tag */
     loc = findTag(packet, TAG_RELAY_SESSION_ID, &tag);
     if (!loc) {
-	syslog(LOG_ERR,
+	dsyslog(LOG_ERR,
 	       "PADO packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s does not have Relay-Session-Id tag",
 	       packet->ethHdr.h_source[0],
 	       packet->ethHdr.h_source[1],
@@ -1147,7 +1079,7 @@ relayHandlePADO(PPPoEInterface const *if
 
     /* If it's the wrong length, ignore it */
     if (ntohs(tag.length) != MY_RELAY_TAG_LEN) {
-	syslog(LOG_ERR,
+	dsyslog(LOG_ERR,
 	       "PADO packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s does not have correct length Relay-Session-Id tag",
 	       packet->ethHdr.h_source[0],
 	       packet->ethHdr.h_source[1],
@@ -1165,7 +1097,7 @@ relayHandlePADO(PPPoEInterface const *if
     if (ifIndex < 0 || ifIndex >= NumInterfaces ||
 	!Interfaces[ifIndex].clientOK ||
 	iface == &Interfaces[ifIndex]) {
-	syslog(LOG_ERR,
+	dsyslog(LOG_ERR,
 	       "PADO packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s has invalid interface in Relay-Session-Id tag",
 	       packet->ethHdr.h_source[0],
 	       packet->ethHdr.h_source[1],
@@ -1213,7 +1145,7 @@ relayHandlePADR(PPPoEInterface const *if
 
     /* Can a client legally be behind this interface? */
     if (!iface->clientOK) {
-	syslog(LOG_ERR,
+	fprintf(stderr,
 	       "PADR packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s not permitted",
 	       packet->ethHdr.h_source[0],
 	       packet->ethHdr.h_source[1],
@@ -1229,7 +1161,7 @@ relayHandlePADR(PPPoEInterface const *if
 
     /* Source address must be unicast */
     if (NOT_UNICAST(packet->ethHdr.h_source)) {
-	syslog(LOG_ERR,
+	fprintf(stderr,
 	       "PADR packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s not from a unicast address",
 	       packet->ethHdr.h_source[0],
 	       packet->ethHdr.h_source[1],
@@ -1249,7 +1181,7 @@ relayHandlePADR(PPPoEInterface const *if
     /* Find relay tag */
     loc = findTag(packet, TAG_RELAY_SESSION_ID, &tag);
     if (!loc) {
-	syslog(LOG_ERR,
+	fprintf(stderr,
 	       "PADR packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s does not have Relay-Session-Id tag",
 	       packet->ethHdr.h_source[0],
 	       packet->ethHdr.h_source[1],
@@ -1263,7 +1195,7 @@ relayHandlePADR(PPPoEInterface const *if
 
     /* If it's the wrong length, ignore it */
     if (ntohs(tag.length) != MY_RELAY_TAG_LEN) {
-	syslog(LOG_ERR,
+	fprintf(stderr,
 	       "PADR packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s does not have correct length Relay-Session-Id tag",
 	       packet->ethHdr.h_source[0],
 	       packet->ethHdr.h_source[1],
@@ -1281,7 +1213,7 @@ relayHandlePADR(PPPoEInterface const *if
     if (ifIndex < 0 || ifIndex >= NumInterfaces ||
 	!Interfaces[ifIndex].acOK ||
 	iface == &Interfaces[ifIndex]) {
-	syslog(LOG_ERR,
+	fprintf(stderr,
 	       "PADR packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s has invalid interface in Relay-Session-Id tag",
 	       packet->ethHdr.h_source[0],
 	       packet->ethHdr.h_source[1],
@@ -1331,7 +1263,7 @@ relayHandlePADS(PPPoEInterface const *if
 
     /* Can a server legally be behind this interface? */
     if (!iface->acOK) {
-	syslog(LOG_ERR,
+	dsyslog(LOG_ERR,
 	       "PADS packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s not permitted",
 	       packet->ethHdr.h_source[0],
 	       packet->ethHdr.h_source[1],
@@ -1345,7 +1277,7 @@ relayHandlePADS(PPPoEInterface const *if
 
     /* Source address must be unicast */
     if (NOT_UNICAST(packet->ethHdr.h_source)) {
-	syslog(LOG_ERR,
+	fprintf(stderr,
 	       "PADS packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s not from a unicast address",
 	       packet->ethHdr.h_source[0],
 	       packet->ethHdr.h_source[1],
@@ -1359,13 +1291,14 @@ relayHandlePADS(PPPoEInterface const *if
 
     /* Destination address must be interface's MAC address */
     if (memcmp(packet->ethHdr.h_dest, iface->mac, ETH_ALEN)) {
+	fprintf(stderr,"Destination address must be interface's MAC address\n");
 	return;
     }
 
     /* Find relay tag */
     loc = findTag(packet, TAG_RELAY_SESSION_ID, &tag);
     if (!loc) {
-	syslog(LOG_ERR,
+	fprintf(stderr,
 	       "PADS packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s does not have Relay-Session-Id tag",
 	       packet->ethHdr.h_source[0],
 	       packet->ethHdr.h_source[1],
@@ -1379,7 +1312,7 @@ relayHandlePADS(PPPoEInterface const *if
 
     /* If it's the wrong length, ignore it */
     if (ntohs(tag.length) != MY_RELAY_TAG_LEN) {
-	syslog(LOG_ERR,
+	fprintf(stderr,
 	       "PADS packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s does not have correct length Relay-Session-Id tag",
 	       packet->ethHdr.h_source[0],
 	       packet->ethHdr.h_source[1],
@@ -1397,7 +1330,7 @@ relayHandlePADS(PPPoEInterface const *if
     if (ifIndex < 0 || ifIndex >= NumInterfaces ||
 	!Interfaces[ifIndex].clientOK ||
 	iface == &Interfaces[ifIndex]) {
-	syslog(LOG_ERR,
+	fprintf(stderr,
 	       "PADS packet from %02x:%02x:%02x:%02x:%02x:%02x on interface %s has invalid interface in Relay-Session-Id tag",
 	       packet->ethHdr.h_source[0],
 	       packet->ethHdr.h_source[1],
